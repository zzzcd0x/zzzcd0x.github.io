<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzzcd0x.github.io</id>
    <title>zzzcd0x &apos;s Blog</title>
    <updated>2020-07-18T03:04:43.122Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzzcd0x.github.io"/>
    <link rel="self" href="https://zzzcd0x.github.io/atom.xml"/>
    <subtitle>越学越倒退选手</subtitle>
    <logo>https://zzzcd0x.github.io/images/avatar.png</logo>
    <icon>https://zzzcd0x.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, zzzcd0x &apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[链表]]></title>
        <id>https://zzzcd0x.github.io/post/lian-biao/</id>
        <link href="https://zzzcd0x.github.io/post/lian-biao/">
        </link>
        <updated>2020-07-18T03:01:32.000Z</updated>
        <content type="html"><![CDATA[<h2 id="什么是链表">什么是链表</h2>
<p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序通过链表中的指针链接次序实现<br>
链表最大的特点是不以下标来寻找某一元素，而是通过相邻元素中的联系来寻找，也可以理解为链表不需要每一个元素相邻，只需要他们记住自己<strong>旁边的元素</strong><br>
链表又分为单向链表、双向链表、循环链表<br>
一个简单的链表仅需要支持插入、删除、查询三种操作</p>
<h2 id="单向链表">单向链表</h2>
<p>单向链表中的每一个元素记住自己前一个或后一个元素的地址，因此在查找元素时只能单向查找，即没有回头的机会<br>
下面创建了一个顺序为1，2，4，3的单向链表</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200411112059111.png" alt="" loading="lazy"></figure>
<h3 id="插入结点">插入结点</h3>
<p>假设我们要将5插入到2的后面</p>
<ol>
<li>首先从头结点开始找到储存2的结点</li>
<li>然后将需要插入的结点的指针指向2的下一个结点，也就是4</li>
<li>最后将2的指针指向5<br>
也就是这样的一个过程</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20200411115209494.gif" alt="" loading="lazy"></figure>
<h3 id="删除结点">删除结点</h3>
<p>假设我们不喜欢刚刚插入的5想要把他删除</p>
<ol>
<li>首先我们要找到<strong>下一个结点是5的结点</strong>所在的位置</li>
<li>然后将这个结点的指针指向5结点的指向的下一个结点的位置</li>
<li>最后将储存5结点的指针指向NULL</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20200411120008932.gif" alt="" loading="lazy"></figure>
<h3 id="查询结点">查询结点</h3>
<p>如果我们要查询某个结点的位置，我们只需要从头结点开始从搜索，直到找到该结点<br>
搜索4结点 过程如下</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20200411120359139.gif" alt="" loading="lazy"></figure>
<h3 id="操作实现">操作实现</h3>
<p>下面我们使用指针来建立一个单向链表实现上述操作</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

struct point{

    int key;
    point* next;

    point(int _key, point* _next)
    {
        next = _next;
        key = _key;
    }

};

point *root;

void init(){           //初始化链表

    root = new point(-1,NULL);    //在链表最开始的位置扔一个伪结点
}

void ins(int x, int y){           //在x后面插入y

    for(point*p = root; p != NULL; p = p-&gt;next)
    {
        if(p-&gt;key == x)          //找到存储x的结点
        {
            point *n = new point(y,p-&gt;next);  //新建存储y的结点
            p-&gt;next = n;         //调整存储x的结点的指针
            break;
        }
    }
}

void ask(int x){                 //查询是否有存储x的结点

    for(point*p = root-&gt;next; p != NULL; p=p-&gt;next)
        if(p-&gt;key == x)
            cout &lt;&lt; p-&gt;next &lt;&lt; endl;
}

void del(int x){                 //删除存储x的结点

    for(point*p = root; p ; p=p-&gt;next)
        if(p-&gt;next-&gt;key == x)   //找到存储x的结点的前一个结点
        {
            point *n = p-&gt;next;
            p-&gt;next = p-&gt;next-&gt;next;
            delete n;
            break;
        }

}

void out(){                    //输出链表

    for(point*p = root-&gt;next; p ; p=p-&gt;next)
    {
        cout &lt;&lt; p-&gt;key &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

int main(){

    init();

    ins(-1,1);
    ins(1,2);
    ins(2,4);
    ins(4,3);
    out();

    ins(2,5);
    out();

    del(5);
    out();

    ask(4);
    out();

    return 0;
}
</code></pre>
<h2 id="双向链表">双向链表</h2>
<p>双向链表与单向链表不同的地方就是双向链表的每一个结点存储了他前一个结点和后一个结点的位置<br>
用双向链表来实现上述的三个步骤的过程为</p>
<h3 id="插入结点-2">插入结点</h3>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20200411143646887.gif" alt="" loading="lazy"></figure>
<h3 id="删除结点-2">删除结点</h3>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20200411144147406.gif" alt="" loading="lazy"></figure>
<h3 id="查询结点-2">查询结点</h3>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20200411144259737.gif" alt="" loading="lazy"></figure>
<h3 id="实现">实现</h3>
<h3 id="指针写法">指针写法</h3>
<p>对单向链表进行部分修改即可得到双向链表</p>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

struct point{

    int key;
    point* next;
    point* front;

    point(int _key, point* _next, point* _front)
    {
        next = _next;
        key = _key;
        front = _front;
    }

};

point *root;

void init(){           //初始化链表

    root = new point(-1,NULL,NULL);    //在链表最开始的位置扔一个伪结点
}

void ins(int x, int y){           //在x后面插入y

    for(point*p = root; p != NULL; p = p-&gt;next)
    {
        if(p-&gt;key == x)          //找到存储x的结点
        {
            point *n = new point(y,p-&gt;next,p);
            if(p-&gt;next)          //判断p是不是尾结点
                p-&gt;next-&gt;front = n;
            p-&gt;next = n;
        }
    }
}

void ask(int x){                 //查询是否有存储x的结点

    for(point*p = root-&gt;next; p != NULL; p=p-&gt;next)
        if(p-&gt;key == x)
            cout &lt;&lt; p-&gt;next &lt;&lt; endl;
}

void del(int x){                 //删除存储x的结点

    for(point*p = root; p ; p=p-&gt;next)
        if(p-&gt;next-&gt;key == x)   //找到存储x的结点的前一个结点
        {
            point *n = p-&gt;next;
            p-&gt;next = p-&gt;next-&gt;next;
            delete n;
            break;
        }

}

void out(){                    //输出链表

    for(point*p = root-&gt;next; p ; p=p-&gt;next)
    {
        cout &lt;&lt; p-&gt;key &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
}

int main(){

    init();

    ins(-1,1);
    ins(1,2);
    ins(2,4);
    ins(4,3);
    out();

    ins(2,5);
    out();

    del(5);
    out();

    ask(4);
    out();

    return 0;
}
</code></pre>
<h3 id="数组写法">数组写法</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;

struct point{
    int pre = 0;    //默认每一个结点前驱和后继为0
    int next = 0;
    int key;
};

point p[105];
int root = 0;
int cnt = 0;

void init(){       //初始化

    p[root].key = -1;
    p[root].next = 0;
    p[root].pre = 0;
}

void ins(int x,int y){
    
    int i = root;
    do
    {
        if(p[i].key == x)
        {
            p[++cnt].key = y;
            p[cnt].next = p[i].next;
            p[cnt].pre = i; 
            if(p[i].next)
                p[p[i].next].pre = cnt;
            p[i].next = cnt;
            break;
        }
        i = p[i].next;
    }while(i != 0);
}

void ask(int x){

    int i = root;
    do
    {
        if(p[i].key == x)
        {
            cout &lt;&lt; i &lt;&lt; endl;
            return;
        }
        i = p[i].next;
    }while(i != 0);
}

void del(int x){

    int le = p[x].pre;
    int rt = p[x].next;
    p[le].next = rt;
    p[rt].pre = le;
}

void out(){

    for(int i = p[root].next; i != 0; i = p[i].next)
        cout &lt;&lt; p[i].key &lt;&lt; &quot; &quot;;

    cout &lt;&lt; endl;
}

int main(){

    init();

    ins(-1,1);
    ins(1,2);
    ins(2,4);
    ins(4,3);
    out();

    ins(2,5);
    out();

    del(5);
    out();

    ask(4);
    out();

    return 0;
}
</code></pre>
<h2 id="循环链表">循环链表</h2>
<p>循环链表与上述两种链表不同的是他的尾结点存储指向头结点的指针，从而可以达到循环的效果</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并查集DSU]]></title>
        <id>https://zzzcd0x.github.io/post/bing-cha-ji-dsu/</id>
        <link href="https://zzzcd0x.github.io/post/bing-cha-ji-dsu/">
        </link>
        <updated>2020-07-17T02:29:14.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<h1 id="引入">引入</h1>
<p>假设现在有n个仅知道自己的父亲是谁的人，现在要存储他们每个人之间的关系，并查询其中几个人是否属于同一家族</p>
</li>
<li>
<h2 id="思路">思路</h2>
<p>首先可以想到每一个家族可以组成一个树，但如果每一个结点都只储存自己的父亲是谁，那这几棵树就会 <s>进化</s> 变成一个森林<br>
所以在存储两个结点的父子关系时，我们应该认定两个结点的最远古的父结点之间有亲缘关系，从而防止森林的诞生<br>
对于查询两个结点的是否属于同一家族，我们仅需要查询他们的最远古祖先是否相同，但当某一个结点没有父结点时，这个结点就一定是当前家族的最远古祖先<br>
思路就是这样了 那么我们用代码来实现一下</p>
</li>
<li>
<h2 id="朴素写法">朴素写法</h2>
</li>
</ul>
<pre><code class="language-cpp">int dad[10005];       //存储每个结点的父结点

int anc(int x){       //查询每个结点的远古祖先

    if(dad[x])
        return anc(dad[x]);
    else 
        return x;     //当该结点没有父结点时当前结点即为最远古祖先
}

bool ask(int x, int y){   //查询两个结点是否在同一家族
    return anc(x) == anc(y);
}

void uni(int x, int y){   //设定亲属关系

    x = anc(x);
    y = anc(y);

    if(x != y)
        dad[x] = y;
}
</code></pre>
<p>以上就是并查集的一种朴素写法</p>
<ul>
<li>
<h2 id="路径压缩优化">路径压缩优化</h2>
<p>分析一下这种写法的复杂度我们就可以发现，<code>ask()</code>和<code>uni()</code>函数都是通过<code>anc()</code>来实现的，但如果碰到了子子孙孙无穷匮也的情况，整棵树就会被退化为一条链，所以每次查找需要消耗O(n)的复杂度<br>
既然我们只关心某一个结点的最远古祖先，那么我们仅需要存储每个结点的最远古祖先即可，优化写法可以使用一下记忆化搜索的技巧</p>
</li>
</ul>
<pre><code class="language-cpp">int anc(int x){

    if(dad[x] != x)
        return dad[x] = anc(dad[x]);
    else 
        return x;
}
</code></pre>
<p>所以我们可以对<code>anc()</code>函数进行这样的修改，此时每次操作的平均复杂度可以接近O(1)</p>
<ul>
<li>
<h1 id="并查集">并查集</h1>
<p>这个数据结构就叫是并查集，并查集可以用来维护不相交集合<br>
支持两种操作：</p>
</li>
</ul>
<ol>
<li>查询x和y是否在同一个集合</li>
<li>将x、y所在集合合并</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[gcd lcm]]></title>
        <id>https://zzzcd0x.github.io/post/gcd-lcm/</id>
        <link href="https://zzzcd0x.github.io/post/gcd-lcm/">
        </link>
        <updated>2020-07-14T08:33:34.000Z</updated>
        <content type="html"><![CDATA[<h2 id="最大公因数gcd">最大公因数(gcd)</h2>
<h3 id="性质">性质：</h3>
<ol>
<li>gcd(1,n) = 1</li>
<li>设d = gcd(a,b) 则 gcd(a/d,b/d) = 1</li>
<li>gcd(a,b) = gcd(a+-b,b) = gcd(a,b+-a)</li>
</ol>
<h3 id="辗转相除法求解">辗转相除法求解：</h3>
<p>由gcd(a,b) = gcd(a-b,b) 得 gcd(a,b) = gcd(a%b,b)</p>
<p>因此求解过程可写为：</p>
<ol>
<li>如果a&lt;b,则交换a,b</li>
<li>如果b = 0，则返回a</li>
<li>令a = a%b</li>
</ol>
<p>重复上述过程</p>
<pre><code class="language-cpp">int gcd(int a, int b) {
    if (a &lt; b) {
        int t = b;
        b = a;
        a = t;
    }
    if (b == 0) return a;
    return gcd(a % b, b);
}
</code></pre>
<h2 id="最小公倍数lcm">最小公倍数(lcm)</h2>
<pre><code class="language-math">lcm(a,b) = {ab\over gcd(a,b)}
</code></pre>
<p><s>怎么求就不用说了吧</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[素数筛]]></title>
        <id>https://zzzcd0x.github.io/post/su-shu-shai/</id>
        <link href="https://zzzcd0x.github.io/post/su-shu-shai/">
        </link>
        <updated>2020-07-14T08:32:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="埃氏筛">埃氏筛</h1>
<ul>
<li>
<h2 id="主要过程">主要过程</h2>
</li>
<li>
<p>从2到n枚举，如果该数字没有标记(是素数)</p>
</li>
<li>
<p>枚举范围内的该数字的倍数，将枚举到的数字标记为素数<br>
这样枚举结束后所有的合数就被打了标记，没打标记的就是素数</p>
</li>
</ul>
<h2 id="实现">实现</h2>
<p>以找100以内的素数为例</p>
<pre><code class="language-cpp">int n = 100;
bool flag[105];

void sieve(){
    for(int i = 2; i &lt;= n; i++)
            if(!flag[i])
            {
                printf(&quot;%d &quot;,i);
                for(int j = 2; i*j &lt;= n; j++)
                    flag[i*j] = true;
            }
}
</code></pre>
<p>时间复杂度：<code>O(n\log(\log(n)))</code></p>
<h1 id="欧拉筛">欧拉筛</h1>
<p>埃氏筛中有一部分数被筛了不止一次，例如6被2筛完又被3筛<br>
然而一个合数被标记只需要被其最小素因子筛就好了<br>
这样的筛法就是欧拉筛，也叫线性筛</p>
<ul>
<li>
<h2 id="过程">过程</h2>
</li>
<li>
<p>i从2开始枚举，在枚举的过程中，记录当前已知的素数</p>
</li>
<li>
<p>枚举的每一步都去筛当前已知的所有的素数的i倍</p>
</li>
<li>
<p><strong>当i能被枚举到的素数整除即已经筛到了当前情况下将要被筛的数的最小素因子则跳出循环</strong>应该被筛却没有被筛的数会在i更大的情况下被筛掉</p>
</li>
</ul>
<h2 id="实现-2">实现</h2>
<p>以找100以内的素数为例</p>
<pre><code class="language-cpp">int cnt;
int n = 100;
int prime[100];
bool flag[100];

void sieve(){

    for(int i = 2; i &lt;= n; i++)
        {
            if(!flag[i])
            {
                prime[++cnt] = i;
                printf(&quot;%d &quot;,i);
            }
            for(int j = 1; prime[j] * i &lt;= n &amp;&amp; j &lt;= cnt; j++)
            {
                flag[prime[j]*i] = true;
                if(i % prime[j] == 0) break;
            }
        }   
}
</code></pre>
<p>时间复杂度：<code>O(n)</code><br>
适合处理数据范围巨大的情况</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[链式前向星]]></title>
        <id>https://zzzcd0x.github.io/post/lian-shi-qian-xiang-xing/</id>
        <link href="https://zzzcd0x.github.io/post/lian-shi-qian-xiang-xing/">
        </link>
        <updated>2020-07-14T08:32:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="原理">原理</h1>
<pre><code>链式前向星与邻接表类似，用一个数组存储了一个点可以到达的所有的点，区别是链式前向星使用链表将从每一个点出发的每一条边用链表的形式链在了一起，对边的存储方式是存储指向的顶点，边权，以及一下一条边的编号
</code></pre>
<h1 id="怎么写呢">怎么写呢</h1>
<ul>
<li>结构体写法</li>
</ul>
<pre><code class="language-cpp">struct Edge{
    int to;
    int val;
    int nxt;
    int from; 
}edge[10005];
int head[10005];                //每一个点的链表的头结点编号
int tot = 0;                    //用于存储每一个点的头结点

void add(int x,int y,int z){
    edge[++tot].nxt = head[x];
    head[x] = tot;
    edge[tot].to = y;
    edge[tot].from = x;
    edge[tot].val = z;
}
</code></pre>
<ul>
<li>数组写法</li>
</ul>
<pre><code class="language-cpp">int tot;
int to[MAXN];
int from[MAXN];
int head[MAXN];
int val[MAXN];

void add(int x,int y) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    from[tot] = x;
}
</code></pre>
<h1 id="遍历">遍历</h1>
<pre><code>与每一个点相连的边已经以链表的形式存储，头结点存储在head数组中，因此我们可以使用类似遍历链表的方式遍历与每一个点相连的每一条边
</code></pre>
<pre><code class="language-cpp">void search(){

    for(int i = 1; i &lt;= n; i++)
        for(int j = head[i]; j ; j = edge[j].next)
            printf(&quot;%d %d %d\n&quot;,edge[j].to,edge[j].val,edge[j].next);

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[拓扑排序]]></title>
        <id>https://zzzcd0x.github.io/post/tuo-bu-pai-xu/</id>
        <link href="https://zzzcd0x.github.io/post/tuo-bu-pai-xu/">
        </link>
        <updated>2020-07-14T08:31:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是dag">什么是DAG</h1>
<pre><code>通俗来说DAG就是有向无环图的简称，通过名字就可以看出，DAG的基本特点是边为有向边，且图内无环
</code></pre>
<p>这个图虽然看似有环，但因为边都是有向边，所以并没有构成环。<br>
观察一下上面那个图，不难发现以每一个结点为起点都可以找到对应的一条链，因此许多图论问题都可以抽象为找DAG中的最短链或者最长链。<br>
然而在一些图论问题中结点之间存在先后关系，这样就不能直接用平常的遍历方式来对图进行遍历，而是需要先对结点按照先后顺序进行排序，转化为一个序列后再进行遍历</p>
<h1 id="拓扑排序">拓扑排序</h1>
<pre><code>上述过程应用的排序算法就是拓扑排序，排序后整张图就被转化成了一个序列，然后通过这个序列来解决问题
</code></pre>
<h2 id="过程">过程</h2>
<ol>
<li>在存图是记录每个结点的入度和出度</li>
<li>存图结束后将入度为0的点加入序列</li>
<li>那处序列头部的点x，遍历该点可以到达的所有点y</li>
<li>删掉x到y的边，即y点的入度减一</li>
<li>如果y点入度为0则加入序列</li>
<li>重复2~5直至序列为空</li>
</ol>
<pre><code class="language-cpp">struct edge{
    int to;
    int val;
    int next;
}e[10005];

int n, m;
int ind[10005];    //入度
int head[100005];

queue&lt;int&gt;q;

void topsort(){

    for(int i = 1; i &lt;= n; i++)                   //将入度为0的结点放入序列
        if(!ind[i])
            q.push(i);

    while(!q.empty())
    {
        int x = q.front();
        q.pop();

        for(int i = head[x]; i; i = e[i].next)    //遍历x能到达的点
        {
            int y = e[i].to;
            ind[y]--;                             //删边
            if(!ind[y])                               //如果y点入度为0则放入序列
            	q.push(y);
        }
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[kruskal]]></title>
        <id>https://zzzcd0x.github.io/post/kruskal/</id>
        <link href="https://zzzcd0x.github.io/post/kruskal/">
        </link>
        <updated>2020-07-14T08:31:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="kruskal">kruskal</h1>
<h2 id="是什么呢">是什么呢</h2>
<p>是一种求一个图的最小生成树的算法，核心思想是贪心，其实就是个贪心，与prime相比更加适合求边比较稀疏的图的最小生成树</p>
<p>时间复杂度是<code>O(mlogm)</code></p>
<h2 id="运行过程">运行过程</h2>
<p>kruskal里面的边的作用可以理解为只是为了表达两个点的具有长度的连接关系</p>
<p>首先将所有的边按照边权从小到大排序</p>
<p>然后枚举每一条边，如果正在枚举的边的两个结点无联通关系，则将该边边权计入答案中、并用并查集标记两点的联通关系</p>
<p>当生成树联通后即可跳出循环</p>
<p><strong>注意建边只要建单向即可</strong></p>
<h2 id="模板">模板</h2>
<pre><code class="language-cpp">
struct Edge {

    int to;
    int val;
    int nxt;
    int from;
}edge[MAXM];

int dad[MAXN];

bool judge(Edge x,Edge y) {return x.val &lt; y.val;}

void kruskal() {

    for(int i = 1; i &lt;= n; i++)
        dad[i] = i;

    sort(edge+1,edge+n+1,judge);

    for(int i = 1; i &lt;= tot; i++) {
        int x = anc(edge[i].from);
        int y = anc(edge[i].to);

        if(x != y) {
            ans += edge[i].val;
            dad[x] = y;
        }
    }
}
</code></pre>
<h2 id="注意事项">注意事项</h2>
<p>真正的边权可能并不是输入的边权</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Floyd]]></title>
        <id>https://zzzcd0x.github.io/post/floyd/</id>
        <link href="https://zzzcd0x.github.io/post/floyd/">
        </link>
        <updated>2020-07-14T08:30:51.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<h1 id="干什么的呢">干什么的呢</h1>
<p>大多用于求多源图中两点间的最短路，也可以用于判图是否连通</p>
</li>
<li>
<h1 id="写法">写法</h1>
</li>
</ul>
<pre><code class="language-cpp">for(int k = 1; k &lt;= n; k++)
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
                dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);
</code></pre>
<p><strong>时间复杂度 O(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)</strong></p>
<ul>
<li>
<h1 id="正确性证明">正确性证明</h1>
<p>Floyd算法核心思想是动态规划<br>
原dp数组为 dp[k][i][j] 表示经过1~k号节点的情况下i到j的最短路<br>
状态转移可以写成 dp[k][i][j] = dp[k-1][i][j] + dp[k-1][i][j]<br>
但是k可以用滚动数组优化掉，来节约一大部分空间复杂度<br>
最终的dp数组为 dp[i][j] 表示i~j的最短路<br>
因为i到j经过1到k号节点的最短路是基于i到j经过1到k-1号节点的最短路计算的，所以k的枚举要放在最外层</p>
</li>
<li>
<h1 id="细节">细节</h1>
<p>dp[0][i][j]表示初始权值，未连接的节点用INF表示<br>
一般用Floyd时还要考虑边的权值</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dijkstra]]></title>
        <id>https://zzzcd0x.github.io/post/dijkstra/</id>
        <link href="https://zzzcd0x.github.io/post/dijkstra/">
        </link>
        <updated>2020-07-14T08:30:12.000Z</updated>
        <content type="html"><![CDATA[<p>Dijkstra算法是一种用于解决无负权边的有向图的单源最短路问题的算法</p>
<h2 id="大致思想">大致思想</h2>
<p>初始时将图的源点的最短路设为0<br>
其他点最短路长度设为INF<br>
将图中的点分为两类 一类是已经更新过最短路的点称为红点，另一类是未找到确定的最短路的点，称为蓝点<br>
从源点开始更新能达到的点的最短路，将已经求出最短路的点放入队列<br>
找出当前最短路最小的蓝点，将该点改为红点，再去更新这个点能达到的点的最短路<br>
重复上述过程直到队列中没有点</p>
<h2 id="正确性证明">正确性证明</h2>
<p>首先源点能够到达的点的最短路一定是与源点相连的边的权值<br>
可是为什么当前最短路最小的蓝点可以改为红点呢？<br>
用反证法证明<br>
假设取出的蓝点为u<br>
如果取出的蓝点还可以更新最短路，即还不能改为红点，那么能更新该点的最短路的点一定在队列后面，设该点为x<br>
然而队是按最短路大小从小到大排序的 因此<br>
<code>$ d[u] &lt; d[x] ,d[x]+val_{x-&gt;u} &gt; d[u] $</code><br>
得证</p>
<h2 id="朴素写法">朴素写法</h2>
<p><strong>链式前向星部分已省略</strong></p>
<pre><code class="language-cpp">int d[1005];
bool b[1005];

void dijkstra(){

    memset(d,0x3f,sizeof(d));
    int inf = d[s];
    d[s] = 0;
    for(int i = 1; i &lt;= n; i++)
    {
        int Min = inf;
        for(int j = 1; j &lt;= n; j++)
            if(!b[j])
                if(Min == inf || d[j]&lt;d[Min])
                    Min = j;
        if(Min == inf) return ;
        b[Min] = true;
        for(int i = head[Min]; i ;i = edge[i].next)
        {
            int to = edge[i].to;
            int val = edge[i].val;
            if(!b[to])
                d[to] = d[Min]+val;
        }
    }
}
</code></pre>
<p><strong>时间复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></strong></p>
<h2 id="堆优化">堆优化</h2>
<p>朴素写法最大的瓶颈是寻找当前路径最短的蓝点，这个过程可以用优先队列和堆优化</p>
<pre><code class="language-cpp">int d[1005];
bool b[1005];
priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, greater&lt;pair&lt;int ,int&gt; &gt; &gt; q;

void dijkstra(){

    d[s] = 0;
    q.push(make_pair(0,s));
    while(!q.empty())
    {
        int x = q.top().second;
        q.pop();
        if(b[x]) continue;
        b[x] = true;
        for(int i = head[x]; i ; i = edge[i].next)
        {
            int to = edge[i].to;
            int val = edge[i].val;
            if(d[to]&gt;d[x]+val)
            {
                d[to] = d[x]+val;
                if(!b[x])
                    q.push(make_pair(d[to],to));
            }
        }
    }
}
</code></pre>
<p>优化后时间复杂度可以降为 O(nlogn+m)<br>
<s>其实还有线段树优化 然后我不会T-T</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树状数组]]></title>
        <id>https://zzzcd0x.github.io/post/shu-zhuang-shu-zu/</id>
        <link href="https://zzzcd0x.github.io/post/shu-zhuang-shu-zu/">
        </link>
        <updated>2020-07-14T08:28:50.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<h1 id="树状数组是什么">树状数组是什么</h1>
<p>设树状数组为C，x的二进制表达形式末尾有k个0，则C[x]表示区间A[<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x-2^k+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>]的和<br>
使位运算lowbit(x) = x&amp;-x可求出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>的值</p>
</li>
</ul>
<pre><code>大致原理
假设x=6
6用二进制表示位110
-6是求6的补码，即反码+1，位010
110&amp;010即为最低位1的位置
</code></pre>
<p><strong>概念想不明白可以看一下这张图</strong><br>
<img src="https://img-blog.csdnimg.cn/20200512205527176.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1BhUnpWYUw=,size_16,color_FFFFFF,t_70" alt="" loading="lazy"><br>
<strong>信息可减的情况下，可以差分:</strong></p>
<ul>
<li>
<p>单点加，区间查询</p>
<p>查询区间[l,r]可差分为前r个数的和减去前l-1个数的和</p>
</li>
<li>
<p>区间加，单点查询</p>
<p>把区间[l,r]加差分为前缀r加，前缀l-1减，查询单点只需要查询包含这个点的所有前缀修改</p>
</li>
<li>
<p>区间加，区间查询</p>
<p>查询[l,r]只要用前r个数减去前l-1个数的和即可</p>
</li>
<li>
<h1 id="基本写法">基本写法</h1>
</li>
<li>
<p>构建</p>
<p>构建方法因题而异</p>
</li>
<li>
<p>查询x的前缀和</p>
<p>根据定义可得，C[x]存的是A[x-2^k+1,x]的和，因此只需要x-lowbit(x)并且加上C[x]的值就可以得到x的前缀和，直到减到0</p>
</li>
</ul>
<pre><code class="language-cpp"> int aks(int x){
   int ans = 0;
   for(int i = x; i ; i-=lowbit(i))
   ans+=c[i];
}
</code></pre>
<ul>
<li>修改<br>
再根据定义，更改A[x]的值，需要改变C中x+lowbit(x)直到大于n的值，迭代解决即可<br>
第x位的数加k的写法</li>
</ul>
<pre><code class="language-cpp">void modify(int x,int k){
	for(int i = x; i &lt;= n; i+=lowbit(i))
    c[i]+=k;
}
</code></pre>
]]></content>
    </entry>
</feed>