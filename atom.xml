<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zzzcd0x.github.io</id>
    <title>KiMi &apos;s Blog</title>
    <updated>2021-02-18T12:08:28.322Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zzzcd0x.github.io"/>
    <link rel="self" href="https://zzzcd0x.github.io/atom.xml"/>
    <subtitle>越学越倒退选手</subtitle>
    <logo>https://zzzcd0x.github.io/images/avatar.png</logo>
    <icon>https://zzzcd0x.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, KiMi &apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Treap]]></title>
        <id>https://zzzcd0x.github.io/post/treap/</id>
        <link href="https://zzzcd0x.github.io/post/treap/">
        </link>
        <updated>2021-02-18T09:46:49.000Z</updated>
        <content type="html"><![CDATA[<p><strong>是啥呢</strong></p>
<p>平衡树的一种（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mo>+</mo><mi>H</mi><mi>e</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">Tree+Heap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span></span></span></span>），用二叉堆的一些性质来防止二叉搜索树退化成链。</p>
<h2 id="复习一下二叉搜索树">复习一下二叉搜索树</h2>
<p><strong>性质：</strong> 对于每一个节点，该节点的权值一定大于其左儿子，小于其右儿子。</p>
<p><strong>可以干嘛呢：</strong></p>
<ol>
<li>查询第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 大的数：跟权值线段树类似，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 小于当前节点的左子树的大小加以，则从左子树中查找第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 大的数，否则去右子树查找第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mo>−</mo><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k-x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 大的数，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 为左子树大小。</li>
<li>查找 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 是第几大：如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的值等于当前节点权值，则 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的排名是当前节点的左子树大小加一，如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的值大于当前节点权值则递归到右子树，最终的排名为左子树大小+1+ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 在右子树的排名。</li>
<li>查找小于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 且最大的数：如果当前节点权值小于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> ，则递归到根的左子树，否则去根和右子树的最大值中较大的一个。</li>
<li>查找大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 且最小的数：如果当前节点权值大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> ，则递归到根的右子树，否则取根和左子树的最小值中较小的一个。</li>
</ol>
<p>二叉搜索树最坏的情况是所有数插入后使整棵树退化成一条链，复杂度就退化到了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<p>因此在插入节点时，给该节点赋一个随机值，插入后如果父节点的随机值小于该节点随机值则进行相应的旋转。</p>
<h2 id="左旋和右旋">左旋和右旋</h2>
<p>一句话说，右旋用于解决左子树过大的情况，左旋用于解决右子树过大的情况，直接模拟就可以实现，实现方法在代码里。</p>
<p><strong>举个栗子</strong></p>
<p>右旋之前</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/j1f9ine9.png" alt="" loading="lazy"></figure>
<p>右旋之后</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/q04a0v7e.png" alt="" loading="lazy"></figure>
<p>左旋之前</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.luogu.com.cn/upload/image_hosting/gunurbqp.png" alt="" loading="lazy"></figure>
<p>左旋之后</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.luogu.com.cn/upload/image_hosting/rg61qkh8.png" alt="" loading="lazy"></figure>
<h2 id="模板">模板</h2>
<p><a href="https://www.luogu.com.cn/problem/P3369">模板题</a></p>
<p><em>代码+注释</em></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int MAXN=1e5+5;
const int INF=1e7+7;
int tot;
int root;
int v[MAXN];
int w[MAXN];
int rd[MAXN];
int size[MAXN];
int son[MAXN][2];
//切记这里要加上 w[p]
void pushup(int p) {size[p]=size[son[p][0]]+size[son[p][1]]+w[p];}
// 旋转 0是左旋，1是右旋
int rotate(int &amp;p,int d) {
    int k=son[p][d^1];
    son[p][d^1]=son[k][d],son[k][d]=p;
    pushup(p);pushup(k);
    p=k;
}
void ins(int &amp;p,int x) {
    if(!p) {//p=0表示当前节点为空，则可以插入到该节点
        p=++tot;
        w[p]=size[p]=1;
        v[p]=x;
        rd[p]=rand();
        return;
    }
    if(x==v[p]) {
        w[p]++;size[p]++;
        return;
    }
    int d=(x&gt;v[p]); //判断应该去哪棵子树
    ins(son[p][d],x);
    if(rd[p]&lt;rd[son[p][d]]) //根据随机堆性质进行旋转
    rotate(p,d^1);
    pushup(p);
}
void del(int &amp;p,int x) {
    if(!p) return;
    if(x&gt;v[p]) del(son[p][1],x);
    else if(x&lt;v[p]) del(son[p][0],x);
    else {
        if(!son[p][0]&amp;&amp;!son[p][1]) {        //叶子节点
            w[p]--;size[p]--;
            if(w[p]==0) p=0;
        }
        else if(!son[p][0]&amp;&amp;son[p][1]) {    //左子树为空
            rotate(p,0);        //保证平衡性
            del(son[p][0],x);
        }
        else if(son[p][0]&amp;&amp;!son[p][1]) {    //右子树为空
            rotate(p,1);        //保证平衡性
            del(son[p][1],x);
        }
        else if(son[p][0]&amp;&amp;son[p][1]) {     //不缺子树
            int d=(rd[son[p][0]]&gt;rd[son[p][1]]);    //根据随机堆维护平衡性
            rotate(p,d);
            del(son[p][d],x);
        }
    }
    pushup(p);//别忘了pushup
}
int _rank(int p,int x) {
    if(!p) return 0;
    if(x==v[p]) return size[son[p][0]]+1;
    else if(x&gt;v[p]) return size[son[p][0]]+w[p]+_rank(son[p][1],x);
    else if(x&lt;v[p]) return _rank(son[p][0],x);
}
int query(int p,int x) {
    if(!p) return 0;
    if(size[son[p][0]]&gt;=x) return query(son[p][0],x);
    else if(size[son[p][0]]+w[p]&lt;x)
        return query(son[p][1],x-size[son[p][0]]-w[p]);
    else return v[p];
}
int pre(int p,int x) {
    if(!p) return -INF;
    if(v[p]&gt;=x) return pre(son[p][0],x);
    else return max(v[p],pre(son[p][1],x));
}
int suc(int p,int x) {
    if(!p) return INF;
    if(v[p]&lt;=x) return suc(son[p][1],x);
    else return min(v[p],suc(son[p][0],x));
}
int main() {
    int T;
    tot=root=0;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--) {
        int opt,x;
        scanf(&quot;%d %d&quot;,&amp;opt,&amp;x);
        if(opt==1) ins(root,x);
        else if(opt==2) del(root,x);
        else if(opt==3) printf(&quot;%d\n&quot;,_rank(root,x));
        else if(opt==4) printf(&quot;%d\n&quot;,query(root,x));
        else if(opt==5) printf(&quot;%d\n&quot;,pre(root,x));
        else if(opt==6) printf(&quot;%d\n&quot;,suc(root,x));
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[树链剖分]]></title>
        <id>https://zzzcd0x.github.io/post/shu-lian-pou-fen/</id>
        <link href="https://zzzcd0x.github.io/post/shu-lian-pou-fen/">
        </link>
        <updated>2020-12-06T14:27:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="轻重链剖分">轻重链剖分</h3>
<p>树链剖分的一种，一般树链剖分都默认为轻重链剖分。</p>
<h4 id="是什么呢">是什么呢</h4>
<p><strong>前置概念：</strong></p>
<ul>
<li>重儿子：一个非叶子节点的儿子中子树（以该儿子为根）最大的儿子。</li>
<li>轻儿子：一个非叶子节点的儿子中除重儿子外的其他儿子。</li>
<li>重边：父节点连接其重儿子的边。</li>
<li>轻边：父节点连接其轻儿子的边。</li>
<li>轻链：轻边组成的链。</li>
<li>重链：重边组成的链。</li>
</ul>
<p><strong>轻重链剖分：</strong></p>
<p>将一颗树剖分成轻链和重链，通过 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 序将树转化为线性区间，然后就可以用线段树等数据结构来维护树上信息。</p>
<p>是一种码量小但功能强大易于理解的算法。</p>
<h3 id="实现过程">实现过程</h3>
<p>轻重链剖分主要由两遍 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 完成。</p>
<p><strong>dfs1​</strong></p>
<p>从根节点开始（不然从哪开始），求出每个节点的深度和每个节点的父节点，更新每个节点的子树大小并求出每个节点的重儿子。</p>
<p><strong>怎么判断一个节点的重儿子是谁呢？</strong></p>
<p>在更新子树时判断一下去 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 的子节点的子树大小是否大于之前搜过的节点的子树大小，如果大于则更新重儿子，否则不更新。</p>
<pre><code class="language-cpp">void dfs1(int now,int fa,int d) {
    dep[now]=d;     //深度
    dad[now]=fa;    //父节点
    size[now]=1;    //子树大小
    for(int i=head[now];i;i=nxt[i]) {
        int y=to[i];
        if(y==fa) continue;
        dfs1(y,now,d+1);
        size[now]+=size[y];                         //统计子树大小
        if(size[y]&gt;size[sonv[now]]) sonv[now]=y;    //更新重儿子
    }
}
</code></pre>
<p><strong>dfs2</strong></p>
<p>从根节点开始搜索，在搜索每个节点的子节点时，优先搜索重儿子，同时更新搜索过的每个节点的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 序，并求出每个节点所在链的顶端节点。</p>
<p><strong>为什么搜索一个节点的子节点时优先搜索重儿子呢？</strong></p>
<p>每次搜索先处理重链，得出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 序后重链是连续的。</p>
<pre><code class="language-cpp">void dfs2(int now,int topn) {
    dfn[now]=++dfscnt;      //dfs序
    f[dfscnt]=num[now];     //存储节点信息
    top[now]=topn;          //链的顶端节点
    if(!sonv[now]) return;
    dfs2(sonv[now],topn);   //优先处理重儿子
    for(int i=head[now];i;i=nxt[i]) {
        int y=to[i];
        if(y==dad[now]||y==sonv[now]) continue;
        dfs2(y,y);          //处理轻儿子 此时轻链的顶端为子节点。
    }
}
</code></pre>
<h3 id="那么剖完之后怎么维护信息呢">那么剖完之后怎么维护信息呢？</h3>
<ol>
<li>
<p>处理两点间路径的点权和</p>
<p>通过树剖时求出了可以知道每一个节点所在链的顶端节点是谁，也就是说，我们可以知道哪两个节点在同一个链中。</p>
<p>处理两点间的路径时，设两点的所在链的顶端节点深度较浅的节点为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 。</p>
<ol>
<li>
<p>通过线段树区间查询求出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 到其所在链顶端节点这段区间的点权和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>，然后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>+</mo><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">ans += v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span> 统计答案。</p>
</li>
<li>
<p>最后将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 跳到所在链的顶端节点的父节点。</p>
</li>
</ol>
<p>重复上述步骤，直至两点属于同一条链，此时再统计一下两个节点所构成的区间之前的点权和即为所求。</p>
<pre><code class="language-cpp">ll querylian(int x,int y) {
    ll res=0;
    while(top[x]!=top[y]) {                         //两节点不在同一条链中
        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);      //处理所在链顶端节点深度较低的那个
        res=(res+query(1,dfn[top[x]],dfn[x]))%mod;
        x=top[x];
        x=dad[x];
    }
    if(dep[x]&gt;dep[y]) swap(x,y);                    //处理两节点之间的节点
    res=(res+query(1,dfn[x],dfn[y]))%mod;
    return res;
}
</code></pre>
</li>
<li>
<p>处理一点及其子树的点权和</p>
<p>树剖时我们统计了以每个节点为根节点的子树的节点个数，用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 序处理过之后这些节点一定是连续的所以直接在线段树上查就好。</p>
<pre><code class="language-cpp">query(1,dfn[x],dfn[x]+size[x]-1)
</code></pre>
</li>
<li>
<p>类似的修改过程同理。</p>
</li>
</ol>
<p>模板（<a href="https://www.luogu.com.cn/problem/P3384">洛谷P3384</a>）</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int MAXN = 2e5+5;
template&lt;class T&gt; inline bool read(T &amp;x) {
    x = 0;
    bool f = false;
    char c = getchar();
    while(!isdigit(c)) {
        if(c == EOF) return false;
        f ^= c == '-';
        c = getchar();
    }
    while(isdigit(c)) {
        x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48);
        c = getchar();
    }
    if(f) x = -x;
    return true;
}
template&lt;class T&gt; inline void print(T x) {
    if(x &lt; 0) {
        putchar('-');
        x = -x;
    }
    if(x &gt; 9) print(x/10);
    putchar(x%10^48);
}
template&lt;class T,class ...S&gt; inline void print(T x,char c) {print(x),putchar(c);}
template&lt;class T,class ...S&gt; inline bool read(T &amp;x,S &amp;...y) {return read(x) &amp;&amp; read(y...);}
int tot;
ll dfscnt;
int n,m,r,mod;
ll f[MAXN&lt;&lt;1];
ll to[MAXN&lt;&lt;1];
ll num[MAXN&lt;&lt;1];
ll top[MAXN&lt;&lt;1];
ll dep[MAXN&lt;&lt;1];
ll nxt[MAXN&lt;&lt;1];
ll dad[MAXN&lt;&lt;1];
ll dfn[MAXN&lt;&lt;1];
int le[MAXN&lt;&lt;2];
int ri[MAXN&lt;&lt;2];
ll tag[MAXN&lt;&lt;2];
ll sum[MAXN&lt;&lt;2];
ll sonv[MAXN&lt;&lt;1];
ll size[MAXN&lt;&lt;1];
ll head[MAXN&lt;&lt;1];
inline int ls(int p) {return p&lt;&lt;1;}
inline int rs(int p) {return p&lt;&lt;1|1;}
inline void pushup(int p) {sum[p]=(sum[ls(p)]+sum[rs(p)])%mod;}
void add(int x,int y) {
    nxt[++tot]=head[x];
    head[x]=tot;
    to[tot]=y;
}
void pushdown(int p) {
    if(tag[p]==0) return;
    ll len=1ll*(ri[p]-le[p]+1);
    int l=ls(p);
    int r=rs(p);
    tag[l]+=tag[p];
    tag[r]+=tag[p];
    sum[l]+=tag[p]*(len-(len&gt;&gt;1));
    sum[r]+=tag[p]*(len&gt;&gt;1);
    sum[l]=sum[l]%mod;
    sum[r]=sum[r]%mod;
    tag[p]=0;
}
void dfs1(int now,int fa,int d) {
    dep[now]=d;     //深度
    dad[now]=fa;    //父节点
    size[now]=1;    //子树大小
    for(int i=head[now];i;i=nxt[i]) {
        int y=to[i];
        if(y==fa) continue;
        dfs1(y,now,d+1);
        size[now]+=size[y];                         //统计子树大小
        if(size[y]&gt;size[sonv[now]]) sonv[now]=y;    //更新重儿子
    }
}
void dfs2(int now,int topn) {
    dfn[now]=++dfscnt;      //dfs序
    f[dfscnt]=num[now];     //存储节点信息
    top[now]=topn;          //链的顶端节点
    if(!sonv[now]) return;
    dfs2(sonv[now],topn);   //优先处理重儿子
    for(int i=head[now];i;i=nxt[i]) {
        int y=to[i];
        if(y==dad[now]||y==sonv[now]) continue;
        dfs2(y,y);          //处理轻儿子 此时轻链的顶端为子节点。
    }
}
void build(int now,int l,int r) {
    le[now]=l;
    ri[now]=r;
    if(l==r) {
        sum[now]=f[l];
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    build(ls(now),l,mid);
    build(rs(now),mid+1,r);
    pushup(now);
}
ll query(int now,int L,int R) {
    ll res=0;
    int l=le[now];
    int r=ri[now];
    if(l&gt;=L&amp;&amp;R&gt;=r) return sum[now];
    pushdown(now);
    int mid=(l+r)&gt;&gt;1;
    if(mid&gt;=L) res+=query(ls(now),L,R);
    if(mid&lt;R) res+=query(rs(now),L,R);
    return res%mod;
}
void modify(int now,int L,int R,ll k) {
    int l=le[now];
    int r=ri[now];
    ll len=1ll*(r-l+1);
    if(l&gt;=L &amp;&amp; R&gt;=r) {
        sum[now]=(sum[now]+len*k)%mod;
        tag[now]=(tag[now]+k)%mod;
        return;
    }
    pushdown(now);
    int mid=(l+r)&gt;&gt;1;
    if(mid&gt;=L) modify(ls(now),L,R,k);
    if(R&gt;mid) modify(rs(now),L,R,k);
    pushup(now);
}
ll querylian(int x,int y) {
    ll res=0;
    while(top[x]!=top[y]) {                         //两节点不在同一条链中
        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);      //处理所在链顶端节点深度较低的那个
        res=(res+query(1,dfn[top[x]],dfn[x]))%mod;
        x=top[x];
        x=dad[x];
    }
    if(dep[x]&gt;dep[y]) swap(x,y);                    //处理两节点之间的节点
    res=(res+query(1,dfn[x],dfn[y]))%mod;
    return res;
}
void modifylian(int x,int y,ll k) {
    while(top[x]!=top[y]) {
        if(dep[top[x]]&lt;dep[top[y]]) swap(x,y);
        modify(1,dfn[top[x]],dfn[x],k);
        x=dad[top[x]];
    }
    if(dep[x]&gt;dep[y]) swap(x,y);
    modify(1,dfn[x],dfn[y],k);
}
int main() {
    read(n,m,r,mod);
    for(int i=1;i&lt;=n;i++) read(num[i]);
    for(int i=1;i&lt;n;i++) {
        int x,y;
        read(x,y);
        add(x,y);
        add(y,x);
    }
    dfs1(r,0,1);dfs2(r,r);
    build(1,1,n);
    for(int i=1;i&lt;=m;i++) {
        int opt;
        read(opt);
        if(opt==1) {
            int x,y;
            ll z;
            read(x,y,z);
            modifylian(x,y,z);
        }
        else if(opt==2) {
            int x,y;
            read(x,y);
            print(querylian(x,y),'\n');
        }
        else if(opt==3) {
            int x;
            ll z;
            read(x,z);
            modify(1,dfn[x],dfn[x]+size[x]-1,z);
        }
        else if(opt==4) {
            int x;
            read(x);
            print(query(1,dfn[x],dfn[x]+size[x]-1),'\n');
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[权值线段树解题报告]]></title>
        <id>https://zzzcd0x.github.io/post/quan-zhi-xian-duan-shu-jie-ti-bao-gao/</id>
        <link href="https://zzzcd0x.github.io/post/quan-zhi-xian-duan-shu-jie-ti-bao-gao/">
        </link>
        <updated>2020-11-13T13:52:49.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1637">洛谷P1637</a></p>
<p><strong>题目大意</strong></p>
<p>给定一个序列，要求求出其中的三元上升子序列的个数，三元上升子序列的定义是序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">a_1,a_2...a_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><msub><mi>a</mi><mi>j</mi></msub><mo>&lt;</mo><msub><mi>a</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">a_i&lt;a_j&lt;a_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8252079999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">i&lt;j&lt;k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 。</p>
<p><strong>思路</strong></p>
<p>权值线段树维护序列中每个数出现的次数，顺序遍历序列，遍历每个数字时查询比他小的数字的个数，然后将该数字插入线段树。清空线段树，然后倒叙遍历序列，遍历每个数字时查询比他大的数字的个数。</p>
<p>每个数字的三元上升子序列的个数即为比他小的数字个数乘比他多的数字的个数（比他小的数和比他大的数两两匹配），遍历一遍统计一下答案即可</p>
<p><strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int MAXN = 3e4+5;
template&lt;class T&gt; inline bool read(T &amp;x) {
    x = 0;
    bool f = false;
    char c = getchar();
    while(!isdigit(c)) {
        if(c == EOF) return false;
        f ^= c == '-';
        c = getchar();
    }
    while(isdigit(c)) {
        x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48);
        c = getchar();
    }
    if(f) x = -x;
    return true;
}
template&lt;class T&gt; inline void print(T x) {
    if(x &lt; 0) {
        putchar('-');
        x = -x;
    }
    if(x &gt; 9) print(x/10);
    putchar(x%10^48);
}
template&lt;class T&gt;inline void print(T x,char c) {print(x),putchar(c);}
template&lt;class T&gt;inline bool read(T &amp;x,T &amp;y) {return read(x)&amp;&amp;read(y);}
int n;
int num[MAXN];
int aft[MAXN];
int big[MAXN];
int small[MAXN];
int le[MAXN&lt;&lt;2];
int ri[MAXN&lt;&lt;2];
int sum[MAXN&lt;&lt;2];
inline int ls(int p) {return p&lt;&lt;1;}
inline int rs(int p) {return p&lt;&lt;1|1;}
void pushup(int p) {sum[p]=sum[ls(p)]+sum[rs(p)];}
void build(int now,int l,int r) {
    le[now]=l;
    ri[now]=r;
    sum[now]=0;
    if(l==r) return;
    int mid=(l+r)&gt;&gt;1;
    build(ls(now),l,mid);
    build(rs(now),mid+1,r);
}
void modify(int now,int pos) {
    int l=le[now];
    int r=ri[now];
    if(l==r) {
        sum[now]++;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if(mid&gt;=pos) modify(ls(now),pos);
    else modify(rs(now),pos);
    pushup(now);
}
int queryS(int now,int pos) {
    int l=le[now];
    int r=ri[now];
    if(l&gt;=pos) return 0;
    if(pos&gt;r) return sum[now];
    int ans=0;
    ans+=queryS(ls(now),pos);
    ans+=queryS(rs(now),pos);
    return ans;
}
int queryB(int now,int pos) {
    int l=le[now];
    int r=ri[now];
    if(r&lt;=pos) return 0;
    if(pos&lt;l) return sum[now];
    int ans=0;
    ans+=queryB(ls(now),pos);
    ans+=queryB(rs(now),pos);
    return ans;
}
map&lt;int,int&gt;Map;
int main() {
    read(n);
    for(int i = 1; i &lt;= n; i++) {
        read(num[i]);
        aft[i]=num[i];
    }
    sort(aft+1,aft+n+1);
    int len=1;
    Map[aft[1]]=1;
    for(int i=2; i&lt;=n;i++)
    if(aft[i]!=aft[i-1])
    Map[aft[i]]=++len;
    ll ans=0;
    build(1,1,len);
    for(int i=1; i&lt;=n; i++){
        small[i]=queryS(1,Map[num[i]]);
        modify(1,Map[num[i]]);
    }
    build(1,1,len);
    for(int i=n; i&gt;=1; i--) {
        big[i]=queryB(1,Map[num[i]]);
        modify(1,Map[num[i]]);
        ans += small[i]*big[i];
    }
    print(ans,'\n');
    return 0;
}
</code></pre>
<p><a href="https://www.luogu.com.cn/problem/P6186">洛谷P6186</a></p>
<p><strong>题目大意</strong></p>
<p>给定一个序列，对该序列执行两种操作：一种为交换序列中的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个数，另一种为对该序列进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 轮冒泡排序，询问完成后序列中的逆序对个数。</p>
<p><strong>解题思路</strong></p>
<p>设数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">ans[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span> 表示在每个数之前有多少个比自己大的数。</p>
<p>对于每一轮冒泡排序对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 数组的影响，如果一个数之前有比自己大的数那么一轮冒泡排序后一定会有一个被移动到这个数后面， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 值会减 1。</p>
<p>因此如果进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 轮冒泡排序，最终对答案有影响的只有排序前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 值大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 的个数。</p>
<p>设比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 值的和为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> ，一共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span> 个比 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 大的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span> 值。</p>
<p>则最终答案为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>−</mo><mi>k</mi><mo>∗</mo><mi>c</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">sum-k*cnt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span></p>
<p>对于每次交换，分会使逆序对减少或者会使逆序对增加两种情况处理。</p>
<p><strong>AC代码</strong></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int MAXN = 2e5+5;
template&lt;class T&gt; inline bool read(T &amp;x) {
    x = 0;
    bool f = false;
    char c = getchar();
    while(!isdigit(c)) {
        if(c == EOF) return false;
        f ^= c == '-';
        c = getchar();
    }
    while(isdigit(c)) {
        x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48);
        c = getchar();
    }
    if(f) x = -x;
    return true;
}
template&lt;class T&gt; inline void print(T x) {
    if(x &lt; 0) {
        putchar('-');
        x = -x;
    }
    if(x &gt; 9) print(x/10);
    putchar(x%10^48);
}
template&lt;class T&gt;inline void print(T x,char c) {print(x),putchar(c);}
template&lt;class T&gt;inline bool read(T &amp;x,T &amp;y) {return read(x)&amp;&amp;read(y);}
int n,m;
int c[MAXN];
int num[MAXN];
int ans[MAXN];
ll sum[MAXN&lt;&lt;2];
ll cnt[MAXN&lt;&lt;2];
inline int ls(int p) {return p&lt;&lt;1;}
inline int rs(int p) {return p&lt;&lt;1|1;}
inline int lowbit(int p) {return p&amp;(-p);}
void ins(int p,int v) {
    for(int i=p;i&lt;=n;i+=lowbit(i))
    c[i]+=v;
}
int find(int p) {
    int res=0;
    for(int i=p;i;i-=lowbit(i))
    res+=c[i];
    return res;
}
void pushup(int now) {
    sum[now]=sum[ls(now)]+sum[rs(now)];
    cnt[now]=cnt[ls(now)]+cnt[rs(now)];
}
void modify(int now,int l,int r,int v,int k) {
    if(l==r) {
        sum[now]+=v*k;
        cnt[now]+=k;
        return;
    }
    int mid=(l+r)&gt;&gt;1;
    if(mid&gt;=v) modify(ls(now),l,mid,v,k);
    else modify(rs(now),mid+1,r,v,k);
    pushup(now);
}
ll query(int now,int L,int R,int l,int r,int flag) {
    if(l&gt;=L &amp;&amp; R&gt;=r) {
        if(flag==1) return sum[now];
        if(flag==2) return cnt[now];
    }
    ll tmp=0;
    int mid=(l+r)&gt;&gt;1;
    if(mid&gt;=L) tmp+=query(ls(now),L,R,l,mid,flag);
    if(mid&lt;R) tmp+=query(rs(now),L,R,mid+1,r,flag);
    return tmp; 
}
int main() {
    read(n,m);
    for(int i=1;i&lt;=n;i++) {
        read(num[i]);
        ans[i]=find(n)-find(num[i]);
        ins(num[i],1);
        modify(1,0,n,ans[i],1);
    }
    for(int i=1;i&lt;=m;i++) {
        int opt,x;
        read(opt,x);
        if(opt==1) {
            swap(num[x],num[x+1]);
            swap(ans[x],ans[x+1]);
            if(num[x+1]&gt;num[x]) {
                modify(1,0,n,ans[x],-1);
                ans[x]--;
                modify(1,0,n,ans[x],1);
            }
            else {
                modify(1,0,n,ans[x+1],-1);
                ans[x+1]++;
                modify(1,0,n,ans[x+1],1);
            }
        }
        else {
            x=min(n,x);
            ll res=query(1,x,n,0,n,1)-x*query(1,x,n,0,n,2);
            print(res,'\n');
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[权值线段树]]></title>
        <id>https://zzzcd0x.github.io/post/quan-zhi-xian-duan-shu/</id>
        <link href="https://zzzcd0x.github.io/post/quan-zhi-xian-duan-shu/">
        </link>
        <updated>2020-11-12T04:23:38.000Z</updated>
        <content type="html"><![CDATA[<h2 id="是什么呢">是什么呢</h2>
<p>算是线段树的一种拓展数据结构吧，基于线段树但与线段树不同。</p>
<p>线段树可以维护一系列具有区间可加性的信息，而权值线段树可以维护一个序列中每个数字出现的次数。</p>
<p>因此权值线段树要开的空间依据值域的大小，线段树依据定义域的大小。</p>
<p>值域很大时可以考虑离散化或动态开点。</p>
<p>基于这些特性，权值线段树的功能有：查询序列中第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 大或者 第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 小的数，查询某个数的排名，查询某个数的前驱和后继等等。</p>
<h2 id="基本操作">基本操作</h2>
<p><strong>单点修改</strong></p>
<p>也就是更新一个数字出现的次数。</p>
<pre><code class="language-cpp">void modify(int now,int pos,int l,int r) {
    if(l==r) {
        sum[now]++;
        return;
    }
    int mid = (l+r)&gt;&gt;1;
    if(mid&gt;=pos) modify(ls(now),pos,l,mid);
    if(mid&lt;pos) modify(rs(now),pos,mid+1,r);
    pushup(now);
}
</code></pre>
<p><strong>区间查询</strong></p>
<p>查询一个值域区间总共出现次数</p>
<pre><code class="language-cpp">int query(int now,int L,int R,int l,int r) {
    if(l&gt;=L &amp;&amp; R&gt;=r) return sum[now];
    int ans = 0;
    int mid = (l+r)&gt;&gt;1;
    if(mid&gt;=L) ans += query(ls(now),L,R,l,mid);
    if(mid&lt;R) ans += query(rs(now),L,R,mid+1,r);
    return ans;
}
</code></pre>
<p><strong>单点查询</strong></p>
<pre><code class="language-cpp">int query(int now,int pos,int l,int r) {
    if(l==r) return sum[now];
    int mid = (l+r)&gt;&gt;1;
    if(mid &gt;= pos) return query(ls(now),pos,l,mid);
    else return query(rs(now),pos,mid+1,r);
}
</code></pre>
<p><strong>查询第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 大</strong></p>
<p>在每个节点，如果右子树的维护的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 值大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> ，则第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 大出现在右子树中，否则在左子树中。</p>
<p><strong>去左子树的时候要将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 值减去右子树的大小。</strong></p>
<pre><code class="language-cpp">int queryK(int now,int l,int r,int k) {
    if(l==r) return l;
    int mid = (l+r)&gt;&gt;1;
    if(sum[rs(now)]&gt;=k) return queryK(rs(now),mid+1,r,k);
    else return queryK(ls(now),l,mid,sum[rs(now)]);
}
</code></pre>
<h2 id="模板">模板</h2>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1394">HDU1394</a></p>
<p><strong>题目大意</strong></p>
<p>给定一个序列，从左向右将序列中的元素移到最右边，问每次移动后最小的逆序对个数是多少？</p>
<p><strong>思路</strong></p>
<p><s>其实可以暴力</s></p>
<p>顺序读入每一个数字，读入每个数字时查询已经读入的数字中比他大的数字的个数即为当前逆序对的个数。</p>
<p>完成输入后即可得出整个区间的逆序对个数。</p>
<p>假设将数字 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 移到序列最右边，此时原来的逆序对变为顺序对，顺序对边为逆序对，而且移动之前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的顺序对个数一定为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">n-x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> ，逆序对个数一定是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。</p>
<p>所以移动后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 对答案的贡献为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>x</mi><mo>−</mo><mo>(</mo><mi>x</mi><mo>−</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">n-x-(x-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;ctype.h&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 5e3+5;
template&lt;class T&gt; inline bool read(T &amp;x) {
    x = 0;
    bool f = false;
    char c = getchar();
    while(!isdigit(c)) {
        if(c == EOF) return false;
        f ^= c == '-';
        c = getchar();
    }
    while(isdigit(c)) {
        x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48);
        c = getchar();
    }
    if(f) x = -x;
    return true;
}
template&lt;class T&gt; inline void print(T x) {
    if(x &lt; 0) {
        putchar('-');
        x = -x;
    }
    if(x &gt; 9) print(x/10);
    putchar(x%10^48);
}
template&lt;class T&gt;inline void print(T x,char c) {print(x),putchar(c);}
template&lt;class T&gt;inline bool read(T &amp;x,T &amp;y) {return read(x)&amp;&amp;read(y);}
int n;
int num[MAXN];
int sum[MAXN&lt;&lt;2];
inline int ls(int p) {return p&lt;&lt;1;}
inline int rs(int p) {return p&lt;&lt;1|1;}
void pushup(int p) { sum[p] = sum[ls(p)] + sum[rs(p)];}
void modify(int now,int pos,int l,int r) {
    if(l==r) {
        sum[now]++;
        return;
    }
    int mid = (l+r)&gt;&gt;1;
    if(mid&gt;=pos) modify(ls(now),pos,l,mid);
    if(mid&lt;pos) modify(rs(now),pos,mid+1,r);
    pushup(now);
}
int query(int now,int L,int R,int l,int r) {
    if(l&gt;=L &amp;&amp; R&gt;=r) return sum[now];
    int ans = 0;
    int mid = (l+r)&gt;&gt;1;
    if(mid&gt;=L) ans += query(ls(now),L,R,l,mid);
    if(mid&lt;R) ans += query(rs(now),L,R,mid+1,r);
    return ans;
}
int main() {
    while(~scanf(&quot;%d&quot;,&amp;n)) {
        int cnt = 0;
        memset(sum,0,sizeof(sum));
        for(int i = 1; i &lt;= n; i++) {
            read(num[i]);
            num[i];
            cnt += query(1,num[i]+1,n,1,n);
            modify(1,num[i]+1,1,n);
        }
        int ans = cnt;
        for(int i = 1; i &lt;= n; i++) {
            cnt += n-2*num[i]-1;
            ans = min(ans,cnt);
        }
        print(ans,'\n');
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前缀和与差分解题报告]]></title>
        <id>https://zzzcd0x.github.io/post/qian-zhui-he-yu-chai-fen-jie-ti-bao-gao/</id>
        <link href="https://zzzcd0x.github.io/post/qian-zhui-he-yu-chai-fen-jie-ti-bao-gao/">
        </link>
        <updated>2020-10-06T02:45:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="最大正方形">最大正方形</h2>
<p><a href="https://www.luogu.com.cn/problem/P1387">题目链接</a></p>
<h3 id="题目描述">题目描述</h3>
<p>给定一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n*m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span> 的只包含0和1的矩阵，求出矩阵中不包含0的最大正方形</p>
<h3 id="解题思路">解题思路</h3>
<p>求出给定矩阵的二维前缀和，枚举每一个可能的顶点和以该顶点做左上角的每一个可能的正方形，差分求出该矩阵中1的个数，如果1的个数等于正方形面积，则为一个合法矩形。</p>
<h3 id="ac代码">AC代码</h3>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e2+5;

template&lt;class T&gt; inline bool read(T &amp;x) {
    x = 0;
    bool f = false;
    char c = getchar();
    while(!isdigit(c)) {
        if(c == EOF) return false;
        f ^= c == '-';
        c = getchar();
    }
    while(isdigit(c)) {
        x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48);
        c = getchar();
    }
    if(f) x = -x;
    return true;
}

int l;
int n, m;
int sum[MAXN][MAXN];
int Map[MAXN][MAXN];

void inp() {
    read(n);
    read(m);
    l = min(n,m);
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++) {
            read(Map[i][j]);
            sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + Map[i][j];
        }
}

int main() {
    inp();
    int ans = 1;
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++) {
            for(int k = 1; k &lt;= l &amp;&amp; i-k &gt;= 0 &amp;&amp; j-k &gt;= 0; k++) {
                int tox = i-k;
                int toy = j-k;
                int x = sum[tox][toy] - sum[i][toy] - sum[tox][j] + sum[i][j];
                if(x == k*k &amp;&amp; k &gt; ans)
                    ans = k;
            }
        }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>
<h2 id="tallest-cow-s">Tallest Cow S</h2>
<p><a href="https://www.luogu.com.cn/problem/P2879">题目链接</a></p>
<h3 id="题目描述-2">题目描述</h3>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">FJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 头奶牛，他们按顺序排成一排，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">FJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span> 只知道这些奶牛中最高的奶牛是第几个，以及这头奶牛的身高，现在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">FJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 条信息，每条信息有两头奶牛的编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> ，表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的身高一定大于等于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 的身高，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 之间的奶牛身高一定低于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mi>J</mi></mrow><annotation encoding="application/x-tex">FJ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span></span></span></span> 想根据这些信息知道每一头奶牛可能的最大身高。</p>
<h3 id="解题思路-2">解题思路</h3>
<p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span> 条信息，将每一条信息中给出的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 之间的奶牛身高减一，最终根据最高的奶牛的身高还原出序列即可。<strong>注意信息判重</strong></p>
<h3 id="ac代码-2">AC代码</h3>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e4+5;

template&lt;class T&gt;inline bool read(T &amp;x) {
    x = 0;
    register bool f = false;
    register char c = getchar();
    while(!isdigit(c)) {
        if(c == EOF) return false;
        f ^= c == '-';
        c = getchar();
    }
    while(isdigit(c)) {
        x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48);
        c = getchar();
    }
    if(f) x = -x;
    return true;
}
template&lt;class T&gt; inline void print(T x) {
    if(x &lt; 0) {
        putchar('-');
        x = -x;
    }
    if(x &gt; 9) print(x/10);
    putchar(x%10^48);
}
template&lt;class T,class ...S&gt; inline bool read(T &amp;x,S &amp;...y) {return read(x) &amp;&amp; read(y...);}
template&lt;class T,class ...S&gt; inline void print(T x,char c) {print(x),putchar(c);}

int n,r,I,h;
int f[MAXN];
int num[MAXN];
bool vis[MAXN][MAXN];

int main() {
    read(n,I,h,r);
    num[I] = h;

    for(register int i = 1; i &lt;= r; i++) {
        int x, y;
        read(x,y);
        if(x &gt; y) swap(x,y);
        if(vis[x][y]) continue;
        vis[x][y] = true;
        f[x+1]--;
        f[y]++;
    }
    for(register int i = I+1; i &lt;= n; i++) {
        num[i] = num[i-1] + f[i];
    }
    for(register int i = I; i &gt;= 1; i--) {
        num[i-1] = num[i] - f[i];
    }
    for(register int i = 1; i &lt;= n; i++)
        print(num[i],'\n');

    return 0;
}
</code></pre>
<h2 id="incdec-sequence">IncDec Sequence</h2>
<p><a href="https://www.luogu.com.cn/problem/P4552">题目链接</a></p>
<h3 id="题目描述-3">题目描述</h3>
<p>给定一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的数列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">{a_1,a_2,\cdots,a_n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> ，每次可以选择一个区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> ，使这个区间内的数都加 1 或者都减 1。</p>
<p>请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。</p>
<h3 id="解题思路-3">解题思路</h3>
<p>用差分考虑这道题，数列中所有的数都一样即差分数组中除第一个数外，其他数都为0。操作时可以选一个数加一或者减一，这样的话差分数组中的正数和负数就可以互相消，如果找不到可以一起消的数就和 1 或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 消，这样不影响差分数组中其他数的值。可以看出，最少的操作次数一定是原始差分数组中最大的正数或最小的负数。</p>
<p>对于第二个子任务，消数时的目标是将其他数消到等于数列的第一个数，因此第一个数可能的数即为答案，当整个差分数组中只剩下正数或负数时，这些数只能和第一个数消，也可以选择跟第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 个数消，答案也就是这些数跟第一个数消的时候产生的。所以答案为差分数组中最大的正数与最小的负数的绝对值的差加一。</p>
<h3 id="ac代码-3">AC代码</h3>
<pre><code class="language-cpp">#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;ctype.h&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int MAXN = 1e5+5;

template&lt;class T&gt; inline bool read(T &amp;x) {
    x = 0;
    register bool f = false;
    register char c = getchar();
    while(!isdigit(c)) {
        if(c == EOF) return false;
        f ^= c == '-';
        c = getchar();
    }
    while(isdigit(c)) {
        x = (x&lt;&lt;3) + (x&lt;&lt;1) + (c^48);
        c = getchar();
    }
    if(f) x = -x;
    return true;
}
template&lt;class T&gt; inline void print(T x) {
    if(x &lt; 0) {
        putchar('-');
        x = -x;
    }
    if(x &gt; 9) print(x/10);
    putchar(x%10^48);
}
template&lt;class T,class ...S&gt; inline bool read(T &amp;x,S &amp;...y) {return read(x) &amp;&amp; read(y...);}
template&lt;class T,class ...S&gt; inline void print(T x,char c) {print(x),putchar(c);}

int n;
ll a,b;
ll x[MAXN];
ll num[MAXN];

int main() {
    read(n);
    for(register int i = 1; i &lt;= n; i++) {
        read(num[i]);
        x[i] = num[i]-num[i-1];
        if(i &gt;= 2) {
            if(x[i] &gt; 0) a += x[i];
            else b += x[i];
        }
    }
    b = -b;
    print(max(a,b),'\n');
    print(1+abs(a-b));
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前缀和与差分]]></title>
        <id>https://zzzcd0x.github.io/post/qian-zhui-he-yu-chai-fen/</id>
        <link href="https://zzzcd0x.github.io/post/qian-zhui-he-yu-chai-fen/">
        </link>
        <updated>2020-10-06T00:04:21.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前缀和">前缀和</h2>
<p>对于一个给定的序列 num ，维护一个序列 sum ，sum[i] 表示给定的序列中前 i 个数的和。</p>
<p>递推式为 sum[i] = sum[i-1] + num[1]</p>
<h3 id="干什么用呢">干什么用呢</h3>
<p>对于需要维护一个给定的序列中一段区间的和的问题，用前缀和可以将暴力做法的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的复杂度降低到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p>
<p>对于其他具有逆运算的信息都可以用前缀和维护。</p>
<p>例如求一个区间的异或和等等。</p>
<h3 id="二维前缀和">二维前缀和</h3>
<p>对于一个给定的二维的序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> ，维护一个序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">sum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 表示点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 到点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> 左上角顶点的矩形内的和。</p>
<p>递推式为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + num[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 。</p>
<p>根据下图可以看出，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 由 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[i][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>  、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">num[i][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 组成，但是  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[i][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>  和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>  相加后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">sum[i-1][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 被重复统计了一次，所以要减掉。</p>
<figure data-type="image" tabindex="1"><img src="https://img2018.cnblogs.com/blog/1674973/201907/1674973-20190710110625195-1169353097.png" alt="" loading="lazy"></figure>
<h2 id="差分">差分</h2>
<p>给定一个序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">num</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span> ，对该序列进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 次操作，每次将序列中一个区间 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[l,r]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">]</span></span></span></span> 中所有的数都加上 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> ，求出修改后的序列。</p>
<p>对于这种问题考虑维护一个序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">dif</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span> , <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dif[i] = num[i] - num[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> ，这样在每次区间加的时候只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dif[l]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mo>[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dif[r+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 会发生改变，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mo>[</mo><mi>l</mi><mo>]</mo><mo>+</mo><mo>=</mo><mi>x</mi><mi mathvariant="normal">，</mi><mi>d</mi><mi>i</mi><mi>f</mi><mo>[</mo><mi>r</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">dif[l] += x，dif[r+1] -= x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 。</p>
<h3 id="二维差分">二维差分</h3>
<p>类比一维差分，可以求出递推公式为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dif[i][j] = num[i][j] + num[i-1][j-1] - num[i-1][j] - num[i][j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 。</p>
<p>对于将点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x1,y1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mn>2</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">(x2,y2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 之间的矩形区间中的数都加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的操作，可以转化为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mo>[</mo><mi>x</mi><mn>1</mn><mo>]</mo><mo>[</mo><mi>y</mi><mn>1</mn><mo>]</mo><mo>+</mo><mo>=</mo><mi>x</mi><mi mathvariant="normal">，</mi><mi>d</mi><mi>i</mi><mi>f</mi><mo>[</mo><mi>x</mi><mn>1</mn><mo>]</mo><mo>[</mo><mi>y</mi><mn>2</mn><mo>+</mo><mn>1</mn><mo>]</mo><mo>−</mo><mo>=</mo><mi>x</mi><mo separator="true">,</mo><mi>d</mi><mi>i</mi><mi>f</mi><mo>[</mo><mi>x</mi><mn>2</mn><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>y</mi><mn>1</mn><mo>]</mo><mo>−</mo><mo>=</mo><mi>x</mi><mo separator="true">,</mo><mi>d</mi><mi>i</mi><mi>f</mi><mo>[</mo><mi>x</mi><mn>2</mn><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>y</mi><mn>2</mn><mo>+</mo><mn>1</mn><mo>]</mo><mo>+</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">dif[x1][y1] += x，dif[x1][y2+1] -= x,dif[x2+1][y1] -= x, dif[x2+1][y2+1] += x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mclose">]</span><span class="mord">−</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tarjan解题报告]]></title>
        <id>https://zzzcd0x.github.io/post/tarjan-jie-ti-bao-gao/</id>
        <link href="https://zzzcd0x.github.io/post/tarjan-jie-ti-bao-gao/">
        </link>
        <updated>2020-09-05T12:54:10.000Z</updated>
        <content type="html"><![CDATA[<h3 id="洛谷p2341-受欢迎的牛">洛谷P2341 受欢迎的牛</h3>
<p>将题目给定的数据建图后可以发现，图中必然会出现许多强连通分量，对于这些强连通分量，如果他可以指向另一个强连通分量，则必然不会得到指向的强连通分量中的奶牛的爱慕，里面的奶牛也就必然不会成为明星，因此能够成为明星的奶牛只能是唯一一个强连通分量的出度为0中的全部奶牛。如果有多个强连通分量出度为0，则没有可以成为明星的奶牛，因为必然没有一个强连通分量可以得到全部奶牛的爱慕。</p>
<p>缩点后统计出度即可</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e4+5;
const int MAXM = 5e4+5;

inline int read() {
    int x = 0;
    int k = 1;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9') {
        if(c == '-') k = -1;
        c = getchar();
    }
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int num;
int tot;
int top;
int n, m;
int dfscnt;
int s[MAXN];
int d[MAXN];
int dp[MAXN];
int to[MAXM];
int scc[MAXN];
int nxt[MAXM];
int low[MAXN];
int dfn[MAXN];
int out[MAXN];
int head[MAXM];
bool ins[MAXN];

void add(int x,int y) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
}

void tarjan(int now) {
    low[now] = dfn[now] = ++dfscnt;
    s[++top] = now;
    ins[now] = true;
    for(int i = head[now]; i ; i = nxt[i]) {
        int y = to[i];
        if(!dfn[y]) {
            tarjan(y);
            low[now] = min(low[now],low[y]);
        }
        else if(ins[y]) {
            low[now] = min(dfn[y],low[now]);
        }
    }
    if(low[now] == dfn[now]) {
        num++;
        while(s[top+1] != now) {
            d[num]++;          
            scc[s[top]] = num;
            ins[s[top--]] = false;
        }
    }
}

void inp() {
    n = read();
    m = read();
    for(int i = 1; i &lt;= m; i++) {
        int x = read();
        int y = read();
        add(x,y);
    }
}

int main() {
    inp();

    for(int i = 1; i &lt;= n; i++)
        if(!dfn[i])
            tarjan(i);

    for(int i = 1; i &lt;= n; i++) {
        int y = scc[i];
        for(int j = head[i]; j ; j = nxt[j]) {
            if(y != scc[to[j]])
                out[y]++;
        }
    }

    int ans = 0;
    int cnt = 0;
    for(int i = 1; i &lt;= num; i++)
        if(!out[i]) {
            ans += d[i];
            cnt++;
        }

    if(cnt != 1) printf(&quot;%d\n&quot;,0);
    else printf(&quot;%d\n&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2746-校园网">洛谷P2746 校园网</h3>
<p>对于子任务A，即为图中强连通分量的个数。</p>
<p>对于子任务B，分别入度或出度为0的强连通分量的个数的较大值，因为如果入度为0则该强连通分量之外的点不可能可以将软件传到该强连通分量之内的任何一个点上，出度为0则他们不会把软件传给任何一个强连通分量之外的点。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e2+5;
const int MAXM = 1e4+5;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int n;
int num;
int tot;
int cnt;
int stop;
int dfscnt;
int d[MAXN];
int s[MAXN];
int x[MAXM];
int y[MAXM];
int in[MAXN];
int to[MAXM];
int low[MAXN];
int dfn[MAXN];
int out[MAXM];
int nxt[MAXM];
int head[MAXN];
bool ins[MAXN];

void add(int x,int y) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
}

void inp() {
    n = read();
    for(int i = 1; i &lt;= n; i++) {
        int t = read();
        while(t != 0) {
            add(i,t);
            x[++cnt] = i;
            y[cnt] = t;
            t = read();
        }
    }
}

void tarjan(int now) {
    dfn[now] = low[now] = ++dfscnt;
    s[++stop] = now;
    ins[now] = true;
    for(int i = head[now]; i ; i = nxt[i]) {
        int y = to[i];
        if(!dfn[y]) {
            tarjan(y);
            low[now] = min(low[now],low[y]);
        }
        else if(ins[y]) {
            low[now] = min(low[now],dfn[y]);
        }
    }
    if(low[now] == dfn[now]) {
        ++num;
        while(s[stop+1] != now) {
            d[s[stop]] = num;
            ins[s[stop--]] = false;
        }
    }
}

int main() {
    inp();

    for(int i = 1; i &lt;= n; i++)
        if(!dfn[i])
            tarjan(i);

    for(int i = 1; i &lt;= cnt; i++) {
        if(d[x[i]] != d[y[i]]) {
            out[d[x[i]]]++;
            in[d[y[i]]]++;
        }
    }

    int In = 0;
    int Out = 0;
    for(int i = 1; i &lt;= num; i++) {
        if(!in[i]) In++;
        if(!out[i]) Out++;
    }

    int ans = 0;
    ans = max(In,Out);
    
    if(num == 1)
        ans = 0;

    printf(&quot;%d\n&quot;,In);
    printf(&quot;%d\n&quot;,ans);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线段树解题报告]]></title>
        <id>https://zzzcd0x.github.io/post/xian-duan-shu-jie-ti-bao-gao/</id>
        <link href="https://zzzcd0x.github.io/post/xian-duan-shu-jie-ti-bao-gao/">
        </link>
        <updated>2020-09-02T11:22:12.000Z</updated>
        <content type="html"><![CDATA[<h3 id="最大子段和">最大子段和</h3>
<p><a href="https://www.luogu.com.cn/problem/P4513">题目链接</a></p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;

int n,m;
int a[500005];

struct Node{

    int l,r;
    int sum;
    int Max;
    int lm,rm;
}node[2000005];

void pushup(int now){

    node[now].sum = node[now&lt;&lt;1].sum+node[now&lt;&lt;1|1].sum;
    node[now].lm = max(node[now&lt;&lt;1].lm,node[now&lt;&lt;1].sum+node[now&lt;&lt;1|1].lm);
    node[now].rm = max(node[now&lt;&lt;1|1].rm,node[now&lt;&lt;1|1].sum+node[now&lt;&lt;1].rm);
    node[now].Max = max(max(node[now&lt;&lt;1].Max,node[now&lt;&lt;1|1].Max),node[now&lt;&lt;1].rm+node[now&lt;&lt;1|1].lm);
}

void build(int now,int l,int r){

    node[now].l = l;
    node[now].r = r;

    if(l == r)
    {
        node[now].sum = a[l];
        node[now].lm = a[l];
        node[now].rm = a[l];
        node[now].Max = a[l];
        return;
    }
    int mid = (l+r)&gt;&gt;1;

    build(now&lt;&lt;1,l,mid);
    build(now&lt;&lt;1|1,mid+1,r);

    pushup(now);
}

void modify(int now,int to,int k){

    int l = node[now].l;
    int r = node[now].r;

    if(l == r)
    {
        // a[now] = k;
        node[now].sum = k;
        node[now].Max = k;        
        node[now].lm = k;
        node[now].rm = k;

        return;
    }
    int mid = (l+r)&gt;&gt;1;

    if(to &lt;= mid) modify(now&lt;&lt;1,to,k);
    else modify(now&lt;&lt;1|1,to,k);

    pushup(now);
}

Node ask(int now,int L,int R){

    int l = node[now].l;
    int r = node[now].r;

    if(L &lt;= l &amp;&amp; R &gt;= r) return node[now];

    int mid = (l+r)&gt;&gt;1;

    if(mid &gt;= R) return ask(now&lt;&lt;1,L,R);
    else if(mid &lt; L) return ask(now&lt;&lt;1|1,L,R);
    else
    {
        Node ans;
        Node left = ask(now&lt;&lt;1,L,R);
        Node right = ask(now&lt;&lt;1|1,L,R);
        ans.sum = left.sum + right.sum;
        ans.lm = max(left.lm,left.sum+right.lm);
        ans.rm = max(right.rm,right.sum+left.rm);
        ans.Max = max(left.rm+right.lm,max(left.Max,right.Max));
        return ans;
    }
}

int main(){

    int k,x,y;

    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);

    for(int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;,&amp;a[i]);

    build(1,1,n);
    
    for(int i = 1; i &lt;= m; i++)
    {
        scanf(&quot;%d %d %d&quot;,&amp;k,&amp;x,&amp;y);
        if(k == 1)
        {
            if(x &gt; y)
            {
                int t = x;
                x = y;
                y = t;
            }
            Node ans = ask(1,x,y);
            printf(&quot;%d\n&quot;,ans.Max);
        }
        if(k == 2)
            modify(1,x,y);
    }

    return 0;
}
</code></pre>
<h3 id="线段树状压">线段树+状压</h3>
<p><a href="http://poj.org/problem?id=2777">题目链接</a></p>
<p>本题是给一个木板的不同区间染色，一共有30种颜色，可以考虑用一个二进制数字来储存该区间内的数被染了哪一种颜色，<strong>线段树中第i个结点存储的数字的二进制第j位为1，则该结点被染成了颜色j，若为0则没有染成颜色j</strong>，区间颜色个数统计使用按位与运算，将最终结果进行二进制拆分统计为1的个数即可。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int MAXN = 1e5+5;

int n,t,o;
int le[MAXN&lt;&lt;2];
int ri[MAXN&lt;&lt;2];
int tag[MAXN&lt;&lt;2];
int color[MAXN&lt;&lt;2];

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int ls(int p) {return p&lt;&lt;1;}
int rs(int p) {return p&lt;&lt;1|1;}
void pushup(int p) {color[p] = color[ls(p)] | color[rs(p)];}

void upd(int p,int v) {
    color[p] = v;
    tag[p] = v;
}

void pushdown(int p) {
    if(tag[p]) {
        upd(ls(p),tag[p]);
        upd(rs(p),tag[p]);
        tag[p] = 0;
    }
}

void build(int now,int l,int r) {
    le[now] = l;
    ri[now] = r;
    color[now] = 0;
    tag[now] = 0;
    if(l == r) {
        color[now] = 1;
        return;
    }
    int mid = (l+r)&gt;&gt;1;
    build(ls(now),l,mid);
    build(rs(now),mid+1,r);
    pushup(now);
}

void modify(int now,int l,int r,int v) {
    int L = le[now];
    int R = ri[now];
    if(r &lt; L || l &gt; R) return;
    if(l &lt;= L &amp;&amp; r &gt;= R) {
        tag[now] = 1&lt;&lt;(v-1);
        color[now] = 1&lt;&lt;(v-1);
        return;
    }
    pushdown(now);
    int mid = (L+R)&gt;&gt;1;
    if(l &lt;= mid) modify(ls(now),l,r,v);
    if(r &gt; mid) modify(rs(now),l,r,v);
    pushup(now);
}

int query(int now,int l,int r) {
    int L = le[now];
    int R = ri[now];
    if(r &lt; L || l &gt; R) return 0;
    if(l &lt;= L &amp;&amp; r &gt;= R) {
        return color[now];
    }
    int ans = 0;
    int mid = (L+R)&gt;&gt;1;
    pushdown(now);
    if(l &lt;= mid) ans |= query(ls(now),l,r);
    if(r &gt; mid) ans |= query(rs(now),l,r);
    return ans;
}

int main() {
    while(~scanf(&quot;%d %d %d&quot;,&amp;n,&amp;t,&amp;o)) {
        int x, y, z;
        char c[2];
        build(1,1,n);
        while(o--) {
            scanf(&quot;%s&quot;,c);
            if(c[0] == 'C') {
                scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);
                if(x &gt; y)
                    swap(x,y);
                modify(1,x,y,z);
            }
            else if(c[0] == 'P') {
                scanf(&quot;%d %d&quot;,&amp;x,&amp;y);
                if(x &gt; y)
                    swap(x,y);
                int cnt = 0;
                int tot = query(1,x,y);
                while(tot) {
                    if(tot&amp;1) cnt++;
                    tot &gt;&gt;= 1;
                }
                printf(&quot;%d\n&quot;,cnt);
            }
        }
    }

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络流解题报告]]></title>
        <id>https://zzzcd0x.github.io/post/wang-luo-liu-jie-ti-bao-gao/</id>
        <link href="https://zzzcd0x.github.io/post/wang-luo-liu-jie-ti-bao-gao/">
        </link>
        <updated>2020-08-28T08:37:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="洛谷p3386-二分图最大匹配问题多源多汇最大流">洛谷P3386 二分图最大匹配问题（多源多汇最大流）</h3>
<p><a href="https://www.luogu.com.cn/problem/P3386">题目链接</a></p>
<p>对于二分图的最大匹配问题可以使用匈牙利算法，更一般的做法是网络流最大流。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/sdjlm6zz.png" alt="" loading="lazy"></figure>
<p>这是一个二分图。</p>
<p>也可以这样看这张图。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/id4l9jvm.png" alt="" loading="lazy"></figure>
<p>0号结点可以看作最大流的超级源点，6号结点可以看作超级汇点，因为每个结点最多只能匹配一个结点，所以<strong>每一条边的最大流量只能是1</strong>。</p>
<p>以下为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码。</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1005;
const int MAXM = 1e5+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int s, t;
int n, m, e;
int tot = 1;
int d[MAXN];
int head[MAXN];
int to[MAXM&lt;&lt;1];
int val[MAXM&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];
int gap[MAXM&lt;&lt;1];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

void inp() {
    n = read();
    m = read();
    e = read();
    s = n+m+1;
    t = n+m+2;
    for(int i = 1; i &lt;= e; i++) {
        int x = read();
        int y = read();
        add(x,y+n,1);
        add(y+n,x,0);
    }
    for(int i = 1; i &lt;= n; i++) {
        add(s,i,1);
        add(i,s,0);
    }
    for(int i = 1; i &lt;= m; i++) {
        add(i+n,t,1);
        add(t,i+n,0);
    }
}

bool bfs() {
    memset(d,0,sizeof(d));
    queue&lt;int&gt; q;
    q.push(s);
    d[s] = 1;
    gap[s] = head[s];
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == 0 &amp;&amp; val[i] &gt; 0) {
                q.push(y);
                d[y] = d[x] + 1;
                gap[y] = head[y];
                if(y == t) return true;
            }
        }
    }
    return false;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k = 0;
    int res = 0;
    for(int i = gap[now]; i ; i = nxt[i]) {
        int y = to[i];
        if(val[i] &gt; 0 &amp;&amp; d[y] == d[now] + 1) {
            k = dfs(y,min(val[i],flow));
            if(!k) d[y] = 0;
            flow -= k;
            res += k;
            val[i] -= k;
            val[i^1] += k; 
        }
    }
    return res;
}

int main() {
    inp();

    int ans = 0;
    while(bfs())
        ans += dfs(s,INF); 

    printf(&quot;%d\n&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2764-最小路径覆盖问题拆点">洛谷P2764 最小路径覆盖问题（拆点）</h3>
<p><a href="https://www.luogu.com.cn/problem/P2764">题目链接</a></p>
<p><strong>给定一个有向图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mo>(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> ,设 P 是 G 的一个简单路的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。</strong></p>
<p>首先将每个点看做一条路径，我们需要让路径尽可能的少，所以就需要合并某些路径，合并完成后，最小路径覆盖数 = 结点数 - 合并的点的数量。</p>
<p>求解合并的点的个数时可以将点拆成两个，建图时每一条有向边的终点为拆出来的点，此时该问题就转化为了二分图最大匹配问题，建立一个超级源点连接拆点的结点，再建立一个超级汇点连接拆出来的结点，在图上跑最大流即可。</p>
<p>以下为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码。</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 155;
const int MAXM = 6e3+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9') 
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int n, m;
int s, t;
int tot = 1;
int d[MAXN&lt;&lt;1];
int to[MAXM&lt;&lt;1];
int gap[MAXN&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];
int val[MAXM&lt;&lt;1];
int pre[MAXN&lt;&lt;1];
int head[MAXN&lt;&lt;1];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

void inp() {
    n = read();
    m = read();
    s = n*2+1;
    t = n*2+2;
    for(int i = 1; i &lt;= m; i++) {
        int x = read();
        int y = read();
        add(x,y+n,1);
        add(y+n,x,0);
    }
    for(int i = 1; i &lt;= n; i++) {
        add(s,i,1);
        add(i,s,0);
        add(i+n,t,1);
        add(t,i+n,0);
    }
}

bool bfs() {
    memset(d,0,sizeof(d));
    queue&lt;int&gt; q;
    d[s] = 1;
    gap[s] = head[s];
    q.push(s);
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == 0 &amp;&amp; val[i] &gt; 0) {
                q.push(y);
                d[y] = d[x] + 1;
                gap[y] = head[y];
                if(y == t) return true;
            }
        }
    }
    return false;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k = 0;
    int res = 0;
    for(int i = gap[now] ; i &amp;&amp; flow; i = nxt[i]) {
        int y = to[i];
        if(val[i] &gt; 0 &amp;&amp; d[y] == d[now] + 1) {
            k = dfs(y,min(flow,val[i]));
            if(!k) {
                d[y] = 0;
                continue;
            }
            flow -= k;
            res += k;
            val[i] -= k;
            val[i^1] += k;
            pre[now] = y;
        }
    }
    return res;
}

bool vis[MAXN&lt;&lt;1];

void find(int now) {
    printf(&quot;%d &quot;,now);
    vis[now] = true;
    for(int i = head[now]; i ; i = nxt[i]) {
        if(to[i] != t &amp;&amp; to[i] != s)
            if(val[i] == 0 &amp;&amp; val[i^1] == 1)
                if(to[i] &gt; n)
                    find(to[i]-n);
    }
}

int main() {
    inp();

    int ans = 0;
    while(bfs()) {
        ans += dfs(s,INF);
    }
    ans = n-ans;

    for(int i = 1; i &lt;= n; i++)
        if(!vis[i]) {
            find(i);
            puts(&quot;&quot;);
        }

    printf(&quot;%d&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2765-魔术球问题动态加点">洛谷P2765 魔术球问题（动态加点）</h3>
<p><a href="https://www.luogu.com.cn/problem/P2765">题目链接</a></p>
<p>题目要求的是 这 n 个柱子上最多能放多少个球，将每个柱子看成一个路径，这个问题就可以转化为计算最多 n 条路径最多可以覆盖多少个结点。</p>
<p>具体解法是在枚举每个柱子的时候枚举每一个点，<strong>依次将枚举到的点加入到图中然后去跑最大流，如果求出的最大流等于0则认为当前数量的柱子不能放下这么多球，然后增加柱子数量</strong>。</p>
<p>寻找路径时因为要找出每一个柱子上的结点，所以在搜索时记录好每一个结点的前缀结点，对于每个柱子记录放在上面的第一个结点。</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e5+5;

int n;
int s = 1e5+1;
int t = 1e5+2;
int tot = 1;
int d[MAXN];
int to[MAXN];
int pre[MAXN];
int val[MAXN];
int nxt[MAXN];
int top[MAXN];
int gap[MAXN];
bool vis[MAXN];
int head[MAXN];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

bool bfs() {
    memset(d,-1,sizeof(d));
    queue&lt;int&gt; q;
    q.push(s);
    gap[s] = head[s];
    d[s] = 1;
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == -1 &amp;&amp; val[i] &gt; 0) {
                q.push(y);
                d[y] = d[x] + 1;
                gap[y] = head[y];
            }
        }
    }
    return d[t] != -1;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k = 0;
    int res = 0;
    for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) {
        int y = to[i];
        if(d[y] == d[now] + 1 &amp;&amp; val[i]) {
            k = dfs(y,min(flow,val[i]));
            if(k) {
                flow -= k;
                res += k;
                val[i] -= k;
                val[i^1] += k;
                if(y != t)
                    pre[now&gt;&gt;1] = y&gt;&gt;1;
            }
        }
    }
    return res;
}

int main() {
    scanf(&quot;%d&quot;,&amp;n);

    int now = 0;
    int cnt = 0;
    while(cnt &lt;= n) {
        now++;
        add(s,now&lt;&lt;1,1);
        add(now&lt;&lt;1,s,0);
        add(t,(now&lt;&lt;1)|1,0);
        add((now&lt;&lt;1)|1,t,1);
        for(int i = sqrt(now)+1; i*i &lt; (now&lt;&lt;1); i++) {
            add((i*i-now)&lt;&lt;1,(now&lt;&lt;1)|1,1);
            add((now&lt;&lt;1)|1,(i*i-now)&lt;&lt;1,0);
        }
        int flow = 0;
        while(bfs()) {
            flow += dfs(s,0x3f3f3f3f);
        }
        if(!flow) top[++cnt] = now;
    }

    printf(&quot;%d\n&quot;,now-1);

    for(int i = 1; i &lt;= n; i++) {
        if(vis[top[i]]) continue;
        int x = top[i];
        vis[x] = true;
        while(x) {
            printf(&quot;%d &quot;,x);
            x = pre[x];
            vis[x] = true;
        }
        puts(&quot;&quot;);
    }

    return 0;
}
</code></pre>
<h3 id="洛谷p1231-教辅的组成最大流">洛谷P1231 教辅的组成（最大流）</h3>
<p><a href="https://www.luogu.com.cn/problem/P1231">题目链接</a></p>
<p>首先对题面进行解析，题目给出书本、练习册、答案的数量，以及可能配套的书本与练习册、书本与答案，要求最多能配成多少套书。</p>
<p>也就是每本书至少要匹配到一本答案和一本练习册才能完成配套。</p>
<p>考虑将结点按照题目要求分为三部分进行建图，建图思路为<strong>源点-&gt;练习册-&gt;书-&gt;答案-&gt;汇点</strong>，然后统计最大流即可。</p>
<p>然后顺手就把图建成了这样。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.luogu.com.cn/upload/image_hosting/y75t8set.png" alt="" loading="lazy"></figure>
<p>但是这样有一个巨大的问题就是每本书可能会被用到很多次，但他们只能被用一次。</p>
<p>解决这个问题我们可以把每本书拆成两个结点，一个用于连接练习册，另一个用于连接答案，两个结点之间连接一条流量为1的边，这样就可以限制每本书被使用的次数了。</p>
<p>正确的建图方法如下</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.luogu.com.cn/upload/image_hosting/y75t8set.png" alt="" loading="lazy"></figure>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 5e4+5;
const int MAXM = 1e5+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int m1,m2;
int tot = 1;
int s = 0;
int t = 5e4+1;
int n1, n2, n3;
int dis[MAXN];
int gap[MAXN];
int head[MAXN];
int val[MAXM&lt;&lt;1];
int to[MAXM&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

bool bfs() {
    memset(dis,0,sizeof(dis));
    queue&lt;int&gt; q;
    q.push(s);
    dis[s] = 1;
    gap[s] = head[s];
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ;i = nxt[i]) {
            int y = to[i];
            if(dis[y] == 0 &amp;&amp; val[i] &gt; 0) {
                dis[y] = dis[x] + 1;
                gap[y] = head[y];
                q.push(y);
            }
        }
    }
    return dis[t] != 0;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k;
    int res = 0;
    for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) {
        int y = to[i];
        if(dis[y] == dis[now] + 1 &amp;&amp; val[i] &gt; 0) {
            k = dfs(y,min(val[i],flow));
            if(!k) dis[y] = -1;
            flow -= k;
            res += k;
            val[i] -= k;
            val[i^1] += k;
        }
    }
    return res;
}

void build() {
    n1 = read();
    n2 = read();
    n3 = read();
    m1 = read();
    int n = n1+n2+n3;
    for(int i = 1; i &lt;= m1; i++) {
        int x = read();
        int y = read();
        add(y+n1,x,1);
        add(x,y+n1,0);
    }
    m2 = read();
    for(int i = 1; i &lt;= m2; i++) {
        int x = read();
        int y = read();
        add(x+n,y+n1+n2,1);
        add(y+n1+n2,x+n,0);
    }
    for(int i = 1; i &lt;= n1; i++) {
        add(i,i+n,1);
        add(i+n,i,0);
    }
    for(int i = 1; i &lt;= n2; i++) {
        add(s,i+n1,1);
        add(i+n1,s,0);
    }
    for(int i = 1; i &lt;= n3; i++) {
        add(i+n1+n2,t,1);
        add(t,i+n1+n2,0);
    }
}

int main() {
    build();

    int ans = 0;
    while(bfs()) {
        ans += dfs(s,INF);
    }

    printf(&quot;%d&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2598-狼和羊的故事-最小割">洛谷P2598 狼和羊的故事 （最小割）</h3>
<p><a href="https://www.luogu.com.cn/problem/P2598">题目链接</a></p>
<p>这道题刚开始我并没有往最小割的方向考虑，这样充分暴露我对最小割理解的不足。</p>
<p>一开始我以为是最大流，因为每个羊附近最多只能有4只狼，因此从源点开始向每只羊连一条流量为4的边，每只狼向汇点连接一条流量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 的边，每只羊与和他相邻的狼连一条流量为1的边，然后很开心的过了样例，交上去反手爆了个零。<img src="https://cdn.luogu.com.cn/upload/pic/62227.png" alt="/kk" loading="lazy"></p>
<p>回想一下割的性质：</p>
<p><strong>割掉一些边后，源点与汇点不再连通</strong>，最小割就是众多割中割掉的边权值和最小的一个，因此源点和割点分别与羊和狼相连的情况下，求出的最小割就是最小篱笆长度。</p>
<p>正确的建模方式是源点与每一只羊连一条流量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 的边，汇点与每一只狼连一条流量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 的边，所有点与四周的结点连一条边。</p>
<p>对于0的归属问题，已经在最大流算法的考虑范围内，所以不用刻意去区分。</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e2+5;
const int MAXM = 1e5+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int n, m;
int s = 0;
int tot = 1;
int d[MAXM];
int t = 1e5+1;
int gap[MAXM];
int head[MAXM];
int to[MAXM&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];
int val[MAXM&lt;&lt;1];
int Map[MAXN][MAXN];

int kx[4] = {0,0,-1,1};
int ky[4] = {-1,1,0,0};

inline int getnum(int x,int y) {return (x-1)*m+y;}

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

void inp() {
    n = read();
    m = read();
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++)
            Map[i][j] = read();
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++) {
            for(int k = 0; k &lt; 4; k++) {
                int x = i + kx[k];
                int y = j + ky[k];
                if(x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m) continue;
                    add(getnum(i,j),getnum(x,y),1);
                    add(getnum(x,y),getnum(i,j),0);
                }
            if(Map[i][j] == 1) {
                add(getnum(i,j),t,INF);
                add(t,getnum(i,j),0);
            }
            else if(Map[i][j] == 2) {
                add(s,getnum(i,j),INF);
                add(getnum(i,j),s,0);
            }
        }
}

bool bfs() {
    memset(d,0,sizeof(d));
    queue&lt;int&gt; q;
    d[s] = 1;
    gap[s] = head[s];
    q.push(s);
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == 0 &amp;&amp; val[i] &gt; 0) {
                d[y] = d[x] + 1;
                gap[y] = head[y];
                q.push(y);
            }
        }
    }
    return d[t] != 0;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k;
    int res = 0;
    for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) {
        gap[now] = i;
        int y = to[i];
        if(d[y] == d[now] + 1 &amp;&amp; val[i] &gt; 0) {
            k = dfs(y,min(flow,val[i]));
            if(!k) d[y] = 0;
            res += k;
            flow -= k;
            val[i] -= k;
            val[i^1] += k;
        }
    }
    return res;
}

int main() {
    inp();

    int ans = 0;
    while(bfs()) {
        ans += dfs(s,INF);
    }
    
    printf(&quot;%d\n&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2774-方格取数问题二分图带权最大独立集">洛谷P2774 方格取数问题（二分图带权最大独立集）</h3>
<p><a href="https://www.luogu.com.cn/problem/P2774">题目链接</a></p>
<p>给定一个方格图，从方格中取出一些结点，使任意两个结点之间没有公共边，且取出的数的总和最大。</p>
<p>将方格内的数做为权值，取出的点看做一个集合，集合内结点权值和最大时即为带权最大独立集。</p>
<p>对于最大权值的求解，可以将问题转化为取出的数的总和最小，则用所有点的权值和减去取出的数的权值和即为最大独立集的权值和。</p>
<p>现在问题就转化为了怎么讲方格图转化为二分图。</p>
<p>可以将方格图看作棋盘（一半为黑格子一半为白格子），根据结点编号的奇偶性分为两组，一组连源点，一组连汇点，连接源点和汇点的边的权值设为结点放的数字的值。</p>
<p>既然公共边是方格图中一个方格与其四周的方格共有的边，则可以将这些公共边看成结点与其四周的结点所连的边，这些边的权值为正无穷。</p>
<p>方格编码示例：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">∣</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>6</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>10</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>11</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>12</mn></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><annotation encoding="application/x-tex">\begin{vmatrix}
1&amp;2&amp;3&amp;4\\
5&amp;6&amp;7&amp;8\\
9&amp;10&amp;11&amp;12\\
\end{vmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.636em;vertical-align:-1.5500299999999998em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.08597em;"><span style="top:-1.05597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.6619700000000002em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26797em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87397em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-4.08597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500299999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.08597em;"><span style="top:-1.05597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.6619700000000002em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26797em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87397em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-4.08597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500299999999998em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这样建图后，方格之间的边容量为正无穷，所以任何一个割中不可能包含这些点，所以求最小割的时候割掉的边就是与源点或汇点连接的边。</p>
<p>当一个点与源点或汇点连接的边被切断了，则视为这个点已经被取出。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e4+5; //数组又开小了 我弱智...
const int MAXM = 1e5+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int sum;
int s, t;
int n, m;
int tot = 1;
int d[MAXN];
int gap[MAXN];
bool vis[MAXN];
int head[MAXN];
int to[MAXM&lt;&lt;1];
int val[MAXM&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];
int dx[4] = {0,0,-1,1};
int dy[4] = {-1,1,0,0};

inline int Hash(int x,int y) {return m*(x-1)+y;}

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

void inp() {
    n = read();
    m = read();
    s = 0;
    t = m*n+1;
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++) {
            int y = read();
            sum += y;
            int x = Hash(i,j);
            if((i+j)%2 == 0) {
                add(s,x,y);
                add(x,s,0);
                for(int k = 0; k &lt; 4; k++) {
                    int tx = i + dx[k];
                    int ty = j + dy[k];
                    if(tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; m)
                        continue;
                    int T = Hash(tx,ty);
                    add(x,T,INF);
                    add(T,x,0);
                }
            }
            else {
                add(x,t,y);
                add(t,x,0);
            }
        }
}

bool bfs() {
    queue&lt;int&gt; q;
    memset(d,0,sizeof(d));
    d[s] = 1;
    gap[s] = head[s];
    q.push(s);
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == 0 &amp;&amp; val[i] &gt; 0) {
                gap[y] = head[y];
                d[y] = d[x] + 1;
                q.push(y);
                if(y == t) return true;
            }
        }
    }
    return false;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k;
    int res = 0;
    for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) {
        int y = to[i];
        gap[now] = i;
        if(d[y] == d[now] + 1 &amp;&amp; val[i] &gt; 0) {
            k = dfs(y,min(flow,val[i]));
            if(!k) d[y] = 0;
            res += k;
            flow -= k;
            val[i] -= k;
            val[i^1] += k;
        }
    }
    return res;
}

int main() {
    inp();

    int ans = 0;
    while(bfs())
        ans += dfs(s,INF);

    printf(&quot;%d\n&quot;,sum-ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2762-太空飞行计划最大闭合子图">洛谷P2762 太空飞行计划（最大闭合子图）</h3>
<p><a href="https://www.luogu.com.cn/problem/P2762">题目链接</a></p>
<p>通过题面可知，若一个实验被选中，则该实验需要用到的仪器必定至少有一个被选，因此选好的结点在原图中一定是一个闭合子图。</p>
<p>题面中每个实验对应的赞助费为闭合图中的正权，每个器材对应的花费为闭合图中的负权。</p>
<p>每个实验与源点相连，边的容量为对应的赞助费，每个器材与汇点相连，容量为对应的花费。</p>
<p>实验与器材相连的边容量记为无限大。</p>
<p>但是怎么统计答案呢。</p>
<p>已知，闭合子图的权值为所有与源点相连的点的权值减去不和汇点相连的负权点的权值的绝对值。</p>
<p>又已知，割的权值和为所有不和源点相连的点的权值加不和汇点相连的负权点的权值的绝对值</p>
<p>两者相加即为正权值的和。</p>
<p>所以全部正权值的和减去割的权值和即为答案。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码如下</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 105;
const int MAXM = 1e3+5;
const int INF = 0x3f3f3f3f;

int sum;
int s, t;
int n, m;
int tot = 1;
int d[MAXN];
int gap[MAXN];
int head[MAXN];
int to[MAXM&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];
int val[MAXM&lt;&lt;1];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

char tools[10000];

void inp() {
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    s = 0;
    t = 104;
    for(int i = 1; i &lt;= n; i++) {
        int x; 
        scanf(&quot;%d&quot;,&amp;x);
        sum += x;
        add(s,i,x);
        add(i,s,0);
        memset(tools,0,sizeof(tools));
        cin.getline(tools,10000);
        int tool,ulen = 0;
        while(sscanf(tools+ulen,&quot;%d&quot;,&amp;tool) == 1) {
            add(i,tool+n,INF);
            add(tool+n,i,0);
            if(tool == 0)
                ulen++;
            else {
                while(tool) {
                    tool /= 10;
                    ulen++;
                }
            }
            ulen++;
        }
    }
    for(int i = 1; i &lt;= m; i++) {
        int x;
        scanf(&quot;%d&quot;,&amp;x);
        add(i+n,t,x);
        add(t,i+n,0);
    }
}

queue&lt;int&gt; q;
bool bfs() {
    memset(d,0,sizeof(d));
    d[s] = 1;
    gap[s] = head[s];
    q.push(s);
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == 0 &amp;&amp; val[i] &gt; 0) {
                d[y] = d[x] + 1;
                gap[y] = head[y];
                q.push(y);
            }
        }
    }
    return d[t] != 0;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k;
    int res = 0;
    for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) {
        gap[now] = i;
        int y = to[i];
        if(d[y] == d[now] + 1 &amp;&amp; val[i] &gt; 0) {
            k = dfs(y,min(flow,val[i]));
            if(!k) d[y] = 0;
            res += k;
            flow -= k;
            val[i] -= k;
            val[i^1] += k;
        }
    }
    return res;
}

int main() {
    inp();

    int ans = 0;
    while(bfs())
        ans += dfs(s,INF);
    for(int i = 1; i &lt;= n; i++)
        if(d[i])
            printf(&quot;%d &quot;,i);
    puts(&quot;&quot;);
    for(int i = 1; i &lt;= m; i++)
        if(d[i+n])
            printf(&quot;%d &quot;,i);
    puts(&quot;&quot;);
    printf(&quot;%d\n&quot;,sum-ans);

    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tarjan]]></title>
        <id>https://zzzcd0x.github.io/post/tarjan/</id>
        <link href="https://zzzcd0x.github.io/post/tarjan/">
        </link>
        <updated>2020-08-24T09:01:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="相关定义">相关定义</h2>
<p><strong>强联通</strong>：有向图中，两个顶点之前至少存在一条路径。</p>
<p><strong>强连通图</strong>：每两个顶点都强连通的有向图。</p>
<p><strong>强连通分量</strong>：有向图的极大强连通子图。</p>
<p>这里极大的概念和数学中的极大值类似，最大就是众多极大中最大的一个。</p>
<p><strong>dfs树</strong>：dfs过程中访问到的边构成的树。</p>
<p><strong>树枝边</strong>：在dfs的过程中指向未访问过的结点的边。</p>
<p><strong>前向边</strong>：指向dfs树中子树中的结点的边。</p>
<p><strong>后向边</strong>：指向dfs树中父亲结点的边。</p>
<p><strong>横叉边</strong>：指向dfs树中非子树的边。</p>
<p><strong>时间戳</strong>：根据每个结点被访问的顺序对这些结点进行编号，这些结点的编号就是时间戳。</p>
<p><strong>割点</strong>：在无向连通图中，删掉一个结点以及与他相连的边后，图变为不连通，则该点是一个割点。</p>
<p><strong>割边</strong>：在无向连通图中，删掉一条边后图不再连通，则这条边是一个割边</p>
<h2 id="问题模型">问题模型</h2>
<p>对于一些结点之前存在关系的图，如果是一个DAG可以用拓扑排序求出序列，但如果有环，则每一个环都可以构成一个强连通分量，可以将强连通分量缩成一个结点。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span> 可以求出图中结点所属的强连通分量，从而可以达到缩点的目的。</p>
<h2 id="四种边的判定">四种边的判定</h2>
<p>首先要引入一个dfs时间戳，用来记录每一个结点第一次被访问的顺序。</p>
<p>对于树枝边，一条边指向的点没有被访问过，则为一条树枝边。</p>
<p>对于前向边，一条边指向的点被访问过，且这条边的终点比始点后被访问，则为一条前向边。</p>
<p>对于后向边，一条边指向的点已经被访问过且不在子树中，且终点在dfs栈中，则为后向边。</p>
<p>对于横叉边，一条边指向的点被访问过且不在子树中且不在dfs栈中，则为横叉边。</p>
<h2 id="tarjan"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span></h2>
<h3 id="强连通分量问题">强连通分量问题</h3>
<p>对于每一个强连通分量中深度最浅的那个点，称他为分割点，所有的分割点可以将dfs树分割为许多棵子树，每一棵子树都是一个强连通分量。</p>
<p>分割的方法是在dfs时维护一个栈来存放路过的结点，离开分割点时将分割点以及分割点之后入栈的结点全部弹出，这些结点即为这一个强连通分量中的结点。</p>
<p>在判断分割点时我们需要维护一个追溯值代码中常为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">low</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 数组，一个结点的追溯值表示该结点能到达的子树中时间戳最小的结点。</p>
<p>计算 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">low[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 时，先令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">low[x] = dfn[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dfn[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 为结点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 序。</p>
<p>对于一条边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></p>
<p>若为树枝边，结点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 能够到达的结点，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 也一定能到达，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">low[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">low[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 更新，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">low[x] = min(low[x],dfn[y])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> 。</p>
<p>若为后向边，此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 能到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，但 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 一定不能到达 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的父亲结点，所以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">low[x]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span> 用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dfn[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 更新，即为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>y</mi><mo>]</mo><mo separator="true">,</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">low[x] = min(dfn[y],low[x])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span> 。</p>
<p>若为前向边，因为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 的信息已经通过树枝边完成传递，所以无需更新。</p>
<p>若为横叉边，指向另一个强连通分量，也无需更新。</p>
<p>当某一个结点的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi><mo>=</mo><mi>l</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">dfn = low</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 时，则该结点是一个分割点。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span> 部分代码</p>
<pre><code class="language-cpp">void tarjan(int now) {
    dfn[now] = low[now] = ++cnt;
    s[++stop] = now;
    ins[now] = true;
    for(int i = head[now]; i; i = nxt[i]) {
        int y = to[i];
        if(!dfn[y]) {
            tarjan(y);
            low[now] = min(low[y],low[now]);
        }
        else if(ins[y]) {
            low[now] = min(low[now],dfn[y]);
        }
    }
    if(dfn[now] == low[now]) {
        ++num;
        while(s[stop+1] != now) {
            d[s[stop]] = num;
            sum[num] += val[s[stop]];
            ins[s[stop--]] = false;
        }
    }
}
</code></pre>
<h3 id="割点问题">割点问题</h3>
<h4 id="割点判断">割点判断</h4>
<p>若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 不是搜索树的根节点或 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 的起点，则当且仅当搜索树中存在一条边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>n</mi><mo>[</mo><mi>x</mi><mo>]</mo><mo>≤</mo><mi>l</mi><mi>o</mi><mi>w</mi><mo>[</mo><mi>y</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dfn[x] \leq low[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span> 时， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 为割点。</p>
<h4 id="怎么求呢">怎么求呢</h4>
<p>对于根节点，在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span></span></span></span> 的过程中统计子树的个数，如果子树数量大于等于2则为割点。</p>
<p>对于非根节点，根据上面的判断方法进行判断即可</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>a</mi><mi>r</mi><mi>j</mi><mi>a</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Tarjan</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span></span></span></span> 部分代码</p>
<pre><code class="language-cpp">void tarjan(int now,int fa){
    int chi = 0;
    low[now] = dfn[now] = ++dfscnt;
    for(int i = head[now]; i ; i = edge[i].next)
    {
        int to = edge[i].to;
        if(!dfn[to])
        {
            tarjan(to,fa);
            low[now] = min(low[to],low[now]);
            if(low[to] &gt;= dfn[now] &amp;&amp; now != fa &amp;&amp; !cut[now])
            {
                cut[now] = true;
                sum++;
            }
            if(now == fa)
                chi++;
        }
        else low[now] = min(low[now],dfn[to]);
    }

    if(now == fa &amp;&amp; chi &gt;= 2 &amp;&amp; !cut[now])
    {
        sum++;
        cut[now] = true;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>