<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>线段树 | zzzcd0x &#39;s Blog</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://zzzcd0x.github.io/favicon.ico?v=1597828966399">
<link rel="stylesheet" href="https://zzzcd0x.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="组成

1号结点为根结点，存储原数组区间1到6的数的和
左儿子下标为2，求法为1&gt;&gt;1,存储[1,3]的和
右儿子下标为3，求法为1&gt;&gt;1|1,存储[4,6]的和
这里3和4时区间中点和中点+1
用二进制运算比较快，..." />
    <meta name="keywords" content="数据结构" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://zzzcd0x.github.io">
        <img src="https://zzzcd0x.github.io/images/avatar.png?v=1597828966399" class="site-logo">
        <h1 class="site-title">zzzcd0x &#39;s Blog</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            All
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            分类
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      越学越倒退选手
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://zzzcd0x.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">线段树</h2>
            <div class="post-date">2020-07-14</div>
            
            <div class="post-content" v-pre>
              <h1 id="组成">组成</h1>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/pcbn4nsv.png" alt="" loading="lazy"></figure>
<p>1号结点为根结点，存储原数组区间1到6的数的和</p>
<p>左儿子下标为2，求法为1&gt;&gt;1,存储[1,3]的和</p>
<p>右儿子下标为3，求法为1&gt;&gt;1|1,存储[4,6]的和</p>
<p>这里3和4时区间中点和中点+1</p>
<p>用二进制运算比较快，处理大量数据时常数可以低一点</p>
<p>其实线段树能维护的东西远不止和，还可以维护区间最大值、最小值、最大子段和等等</p>
<h1 id="怎么维护呢">怎么维护呢</h1>
<h2 id="先从建树开始">先从建树开始</h2>
<p>从根节点开始递归建树 <strong>开四倍空间</strong></p>
<p>1.数组写法</p>
<pre><code class="language-cpp">int a[1005];  //原数组
int t[4005]; //线段树

void build(int now,int l,int r){

    if(l == r)
    {
        t[now] = a[l];
        return;
    }

    int mid = (l+r)&gt;&gt;1;

    build(now&lt;&lt;1,l,mid);
    build(now&lt;&lt;1|1,mid+1,r);

    pushup(now); //回溯的时候更新父亲节点
}
</code></pre>
<p>2.结构体写法</p>
<pre><code class="language-cpp">struct Node{

    int l,r;
    int sum;
}node[4005];

void build(int now,int l,int r){

    node[now].l = l;
    node[now].r = r;

    if(l == r)
    {
        node[now].sum = a[l];
        return;
    }

    int mid = (l+r)&gt;&gt;1;

    build(now&lt;&lt;1,l,mid);
    build(now&lt;&lt;1|1,mid+1,r);

    pushup(now);
}
</code></pre>
<p>好像结构体写法更容易维护</p>
<h2 id="区间查询">区间查询</h2>
<ol>
<li>当前查找到的区间被包含在需要查找的区间内则直接返回</li>
<li>否则通过中点判断要查找到区间和左右子树哪个有交集</li>
<li>如果都有则将两边的查找结果进行相应的处理后返回</li>
<li>思想类似二分查找</li>
</ol>
<pre><code class="language-cpp">int find(int now,int L,int R){

    int l = node[now].l;
    int r = node[now].r;
    if(L &lt;= l &amp;&amp; R &gt;= r)
        return node[now].sum;
    
    int mid = (l+r)&gt;&gt;1;

    if(mid &gt;= R)
        return find(now&lt;&lt;1,L,R);
    else if(mid &lt; l)
        return find(now&lt;&lt;1|1,L,R);
    else
    {
        int tot = 0;
        tot += find(now&lt;&lt;1,L,R);
        tot += find(now&lt;&lt;1|1,L,R);
        return tot; 
    }
}
</code></pre>
<h2 id="区间修改">区间修改</h2>
<p>大体步骤和区间查询类似</p>
<p><strong>标记下放:</strong> 如果每次修改都去相应的修改涉及到的所有的结点的话会产生较大的复杂度，因此考虑使用标记下放的方法，即当该结点被访问到的时候再将标记下放，使子树得到正确的信息。所以区间修改只更新到需要修改的区间的真子集即可，但在此之前每一个访问到的结点都要进行标记下放，不然需要更新的区间得不到正确的更新信息</p>
<pre><code class="language-cpp">int tag[40005];

void pushdown(int now){

    if(tag[now])
    {
        tag[now&lt;&lt;1] += tag[now];
        tag[now&lt;&lt;1|1] += tag[now];
        node[now&lt;&lt;1].sum += tag[now]*(node[now&lt;&lt;1].r-node[now&lt;&lt;1]+1);
        node[now&lt;&lt;1|1].sum += tag[now]*(node[now&lt;&lt;1|1].r-node[now&lt;&lt;1|1]+1);
        tag[now] = 0;
    }

}

void modify(int now,int L,int R,int k){

    int l = node[now].l;
    int r = node[now].r;

    if(L &lt;= l &amp;&amp; R &gt;= r)
    {
        tag[now] += k;
        node[now].sum += k*(r-l+1);
    }

    pushdown(now);

    int mid = (l+r)&gt;&gt;1;
    if(mid &gt;= L) modify(now&lt;&lt;1,L,R,k);
    if(R &gt; mid) modify(now&lt;&lt;1|1,L,R,k);

    pushup(now);
}
</code></pre>
<ul>
<li>pushup的作用是当某一个结点的子树的值被修改了则去用修改后的子树的信息去更新当前结点的信息</li>
</ul>
<pre><code class="language-cpp">void pushup(int now){
    node[now].sum = node[now&lt;&lt;1].sum + ndoe[now&lt;&lt;1|1].sum;
}
</code></pre>
<h2 id="单点修改">单点修改</h2>
<pre><code class="language-cpp">void modifyP(int now,int to,int k){

    int l = node[now].l;
    int r = node[now].r;

    if(l == r)
    {
        a[now] += k;
        t[now] += k;
        return;
    }

    int mid = (l+r)&gt;&gt;1;

    if(mid &gt;= to) modifyP(now&lt;&lt;1,to,k);
    else modifyP(now&lt;&lt;1|1,to,k);

    pushup(now);
}
</code></pre>
<h1 id="维护最大子段和">维护最大子段和</h1>
<h2 id="什么是最大子段和">什么是最大子段和？</h2>
<p>其实就是当前线段树区间内，一个任意的连续的序列的和的最大值</p>
<p>其他会用到的概念:</p>
<p>最大左子段和:从区间左端点开始的最大子段和</p>
<p>最大右子段和:从区间右端点开始的最大子段和</p>
<h3 id="pushup">pushup</h3>
<p>最大左子段和可能是左子树的最大左子段和也可能是左子树的区间总和加右子树的最大左子段和，最大右子段和同理</p>
<p>最大子段和可能是左子树的最大子段和或右子树的最大子段和或左子树的最大右子段和+右子树的最大左子段和</p>
<pre><code class="language-cpp">void pushup(int now){

    node[now].sum = node[now&lt;&lt;1].sum + node[now&lt;&lt;1|1].sum;
    ndoe[now].Max = max(max(node[now&lt;&lt;1].Max,node[now&lt;&lt;1|1].Max),node[now&lt;&lt;1].rm+node[now&lt;&lt;1|1].lm);
    node[now].lm = max(node[now&lt;&lt;1].lm,node[now&lt;&lt;1].sum+node[now&lt;&lt;1|1].lm);
    node[now].rm = max(node[now&lt;&lt;1|1].rm,node[now&lt;&lt;1].rm+node[now&lt;&lt;1|1].sum);
}
</code></pre>
<h3 id="建树">建树</h3>
<pre><code class="language-cpp">void build(int now,int l,int r){

    node[now].l = l;
    ndoe[now].r = r;

    if(l == r)
    {
        node[now].sum = a[l];
        node[now].lm = a[l];
        node[now].rm = a[l];
        node[now].Max = a[l];
        return;
    }

    int mid = (l+r)&gt;&gt;1;

    builde(now&lt;&lt;1,l,mid);
    build(now&lt;&lt;1|1,mid+1,r);

    pushup(now);
}
</code></pre>
<h3 id="区间修改-2">区间修改</h3>
<p>直接更改线段树上某个点的值</p>
<pre><code class="language-cpp">void modify(int now,int to,int k){

    int l = node[now].l;
    int r = node[now].r;

    if(l == r)
    {
        node[now].sum = k;
        node[now].Max = k;
        node[now].lm = k;
        node[now].rm = k;
        return;
    }

    int mid = (l+r)&gt;&gt;1;

    if(to &lt;= mid) modify(now&lt;&lt;1,to,k);
    else modify(now&lt;&lt;1|1,to,k);

    pushup(now);
}
</code></pre>
<h3 id="区间查找">区间查找</h3>
<pre><code class="language-cpp">Node ask(int now,int L,int R){

    int l = node[now].l;
    int r = ndoe[now].r;

    if(L &lt;= l &amp;&amp; R &gt;= r)
        return node[now];
    
    int mid = (l+r)&gt;&gt;1;

    if(mid &gt;= R) return ask(now&lt;&lt;1,L,R);
    else if(mid&lt;L) return ask(now&lt;&lt;1|1,L,R);
    else{
        Node ans;
        Node left = ask(now&lt;&lt;1,L,R);
        Node right = ask(now&lt;&lt;1|1,L,R);
        ans.sum = left.sum + right.sum;
        ans.lm = max(left.lm,left.sum+right.lm);
        ans.rm = max(right.rm,right.sum+left.rm);
        ans.Max = max(left.rm+right.lm,max(left.Max,right.Max));
        return ans;
    }
}
</code></pre>
<h1 id="例题">例题</h1>
<h2 id="最大子段和">最大子段和</h2>
<p><a href="https://www.luogu.com.cn/problem/P4513">题目链接</a></p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;

int n,m;
int a[500005];

struct Node{

    int l,r;
    int sum;
    int Max;
    int lm,rm;
}node[2000005];

void pushup(int now){

    node[now].sum = node[now&lt;&lt;1].sum+node[now&lt;&lt;1|1].sum;
    node[now].lm = max(node[now&lt;&lt;1].lm,node[now&lt;&lt;1].sum+node[now&lt;&lt;1|1].lm);
    node[now].rm = max(node[now&lt;&lt;1|1].rm,node[now&lt;&lt;1|1].sum+node[now&lt;&lt;1].rm);
    node[now].Max = max(max(node[now&lt;&lt;1].Max,node[now&lt;&lt;1|1].Max),node[now&lt;&lt;1].rm+node[now&lt;&lt;1|1].lm);
}

void build(int now,int l,int r){

    node[now].l = l;
    node[now].r = r;

    if(l == r)
    {
        node[now].sum = a[l];
        node[now].lm = a[l];
        node[now].rm = a[l];
        node[now].Max = a[l];
        return;
    }
    int mid = (l+r)&gt;&gt;1;

    build(now&lt;&lt;1,l,mid);
    build(now&lt;&lt;1|1,mid+1,r);

    pushup(now);
}

void modify(int now,int to,int k){

    int l = node[now].l;
    int r = node[now].r;

    if(l == r)
    {
        // a[now] = k;
        node[now].sum = k;
        node[now].Max = k;        
        node[now].lm = k;
        node[now].rm = k;

        return;
    }
    int mid = (l+r)&gt;&gt;1;

    if(to &lt;= mid) modify(now&lt;&lt;1,to,k);
    else modify(now&lt;&lt;1|1,to,k);

    pushup(now);
}

Node ask(int now,int L,int R){

    int l = node[now].l;
    int r = node[now].r;

    if(L &lt;= l &amp;&amp; R &gt;= r) return node[now];

    int mid = (l+r)&gt;&gt;1;

    if(mid &gt;= R) return ask(now&lt;&lt;1,L,R);
    else if(mid &lt; L) return ask(now&lt;&lt;1|1,L,R);
    else
    {
        Node ans;
        Node left = ask(now&lt;&lt;1,L,R);
        Node right = ask(now&lt;&lt;1|1,L,R);
        ans.sum = left.sum + right.sum;
        ans.lm = max(left.lm,left.sum+right.lm);
        ans.rm = max(right.rm,right.sum+left.rm);
        ans.Max = max(left.rm+right.lm,max(left.Max,right.Max));
        return ans;
    }
}

int main(){

    int k,x,y;

    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);

    for(int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;,&amp;a[i]);

    build(1,1,n);
    
    for(int i = 1; i &lt;= m; i++)
    {
        scanf(&quot;%d %d %d&quot;,&amp;k,&amp;x,&amp;y);
        if(k == 1)
        {
            if(x &gt; y)
            {
                int t = x;
                x = y;
                y = t;
            }
            Node ans = ask(1,x,y);
            printf(&quot;%d\n&quot;,ans.Max);
        }
        if(k == 2)
            modify(1,x,y);
    }

    return 0;
}
</code></pre>
<h2 id="线段树状压">线段树+状压</h2>
<p><a href="http://poj.org/problem?id=2777">题目链接</a></p>
<p>本题是给一个木板的不同区间染色，一共有30种颜色，可以考虑用一个二进制数字来储存该区间内的数被染了哪一种颜色，<strong>线段树中第i个结点存储的数字的二进制第j位为1，则该结点被染成了颜色j，若为0则没有染成颜色j</strong>，区间颜色个数统计使用按位与运算，将最终结果进行二进制拆分统计为1的个数即可。</p>
<pre><code class="language-cpp">#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int MAXN = 1e5+5;

int n,t,o;
int le[MAXN&lt;&lt;2];
int ri[MAXN&lt;&lt;2];
int tag[MAXN&lt;&lt;2];
int color[MAXN&lt;&lt;2];

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int ls(int p) {return p&lt;&lt;1;}
int rs(int p) {return p&lt;&lt;1|1;}
void pushup(int p) {color[p] = color[ls(p)] | color[rs(p)];}

void upd(int p,int v) {
    color[p] = v;
    tag[p] = v;
}

void pushdown(int p) {
    if(tag[p]) {
        upd(ls(p),tag[p]);
        upd(rs(p),tag[p]);
        tag[p] = 0;
    }
}

void build(int now,int l,int r) {
    le[now] = l;
    ri[now] = r;
    color[now] = 0;
    tag[now] = 0;
    if(l == r) {
        color[now] = 1;
        return;
    }
    int mid = (l+r)&gt;&gt;1;
    build(ls(now),l,mid);
    build(rs(now),mid+1,r);
    pushup(now);
}

void modify(int now,int l,int r,int v) {
    int L = le[now];
    int R = ri[now];
    if(r &lt; L || l &gt; R) return;
    if(l &lt;= L &amp;&amp; r &gt;= R) {
        tag[now] = 1&lt;&lt;(v-1);
        color[now] = 1&lt;&lt;(v-1);
        return;
    }
    pushdown(now);
    int mid = (L+R)&gt;&gt;1;
    if(l &lt;= mid) modify(ls(now),l,r,v);
    if(r &gt; mid) modify(rs(now),l,r,v);
    pushup(now);
}

int query(int now,int l,int r) {
    int L = le[now];
    int R = ri[now];
    if(r &lt; L || l &gt; R) return 0;
    if(l &lt;= L &amp;&amp; r &gt;= R) {
        return color[now];
    }
    int ans = 0;
    int mid = (L+R)&gt;&gt;1;
    pushdown(now);
    if(l &lt;= mid) ans |= query(ls(now),l,r);
    if(r &gt; mid) ans |= query(rs(now),l,r);
    return ans;
}

int main() {
    while(~scanf(&quot;%d %d %d&quot;,&amp;n,&amp;t,&amp;o)) {
        int x, y, z;
        char c[2];
        build(1,1,n);
        while(o--) {
            scanf(&quot;%s&quot;,c);
            if(c[0] == 'C') {
                scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);
                if(x &gt; y)
                    swap(x,y);
                modify(1,x,y,z);
            }
            else if(c[0] == 'P') {
                scanf(&quot;%d %d&quot;,&amp;x,&amp;y);
                if(x &gt; y)
                    swap(x,y);
                int cnt = 0;
                int tot = query(1,x,y);
                while(tot) {
                    if(tot&amp;1) cnt++;
                    tot &gt;&gt;= 1;
                }
                printf(&quot;%d\n&quot;,cnt);
            }
        }
    }

    return 0;
}
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://zzzcd0x.github.io/tag/nPXiRYhFe/" class="tag">
                    数据结构
                  </a>
                
              </div>
            
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
