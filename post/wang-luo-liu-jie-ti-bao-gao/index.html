<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>zzzcd0x &#39;s Blog</title>
<meta name="description" content="越学越倒退选手" />
<link rel="shortcut icon" href="https://zzzcd0x.github.io/favicon.ico?v=1598603906261">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://zzzcd0x.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://zzzcd0x.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://zzzcd0x.github.io/images/avatar.png?v=1598603906261" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">zzzcd0x &#39;s Blog</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%B4%9B%E8%B0%B7p3386-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98">洛谷P3386 二分图最大匹配问题</a></li>
<li><a href="#%E6%B4%9B%E8%B0%B7p2764-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98">洛谷P2764 最小路径覆盖问题</a></li>
<li><a href="#%E6%B4%9B%E8%B0%B7p2765-%E9%AD%94%E6%9C%AF%E7%90%83%E9%97%AE%E9%A2%98">洛谷P2765 魔术球问题</a></li>
<li><a href="#%E6%B4%9B%E8%B0%B7p1231-%E6%95%99%E8%BE%85%E7%9A%84%E7%BB%84%E6%88%90">洛谷P1231 教辅的组成</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu" style="animation-delay: 0.2s">
          All
        </a>
      
    
      
        <a href="/tags" class="menu" style="animation-delay: 0.4s">
          分类
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://zzzcd0x.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">网络流解题报告</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-08-28 / 13 min read
        </div>
        
        <div class="post-content yue">
          <h3 id="洛谷p3386-二分图最大匹配问题">洛谷P3386 二分图最大匹配问题</h3>
<p>对于二分图的最大匹配问题可以使用匈牙利算法，更一般的做法是网络流最大流</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/sdjlm6zz.png" alt="" loading="lazy"></figure>
<p>这是一个二分图</p>
<p>也可以这样看这张图</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/id4l9jvm.png" alt="" loading="lazy"></figure>
<p>0号结点可以看作最大流的超级源点，6号结点可以看作超级汇点，因为每个结点最多只能匹配一个结点，所以<strong>每一条边的最大流量只能是1</strong></p>
<p>代码可以这样写</p>
<p><a href="https://www.luogu.com.cn/problem/P3386">题目链接</a></p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1005;
const int MAXM = 1e5+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int s, t;
int n, m, e;
int tot = 1;
int d[MAXN];
int head[MAXN];
int to[MAXM&lt;&lt;1];
int val[MAXM&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];
int gap[MAXM&lt;&lt;1];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

void inp() {
    n = read();
    m = read();
    e = read();
    s = n+m+1;
    t = n+m+2;
    for(int i = 1; i &lt;= e; i++) {
        int x = read();
        int y = read();
        add(x,y+n,1);
        add(y+n,x,0);
    }
    for(int i = 1; i &lt;= n; i++) {
        add(s,i,1);
        add(i,s,0);
    }
    for(int i = 1; i &lt;= m; i++) {
        add(i+n,t,1);
        add(t,i+n,0);
    }
}

bool bfs() {
    memset(d,0,sizeof(d));
    queue&lt;int&gt; q;
    q.push(s);
    d[s] = 1;
    gap[s] = head[s];
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == 0 &amp;&amp; val[i] &gt; 0) {
                q.push(y);
                d[y] = d[x] + 1;
                gap[y] = head[y];
                if(y == t) return true;
            }
        }
    }
    return false;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k = 0;
    int res = 0;
    for(int i = gap[now]; i ; i = nxt[i]) {
        int y = to[i];
        if(val[i] &gt; 0 &amp;&amp; d[y] == d[now] + 1) {
            k = dfs(y,min(val[i],flow));
            if(!k) d[y] = 0;
            flow -= k;
            res += k;
            val[i] -= k;
            val[i^1] += k; 
        }
    }
    return res;
}

int main() {

    inp();

    int ans = 0;
    while(bfs())
        ans += dfs(s,INF); 

    printf(&quot;%d\n&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2764-最小路径覆盖问题">洛谷P2764 最小路径覆盖问题</h3>
<p><a href="https://www.luogu.com.cn/problem/P2764">题目链接</a></p>
<p><strong>给定一个有向图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mo>(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> ,设 P 是 G 的一个简单路的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。</strong></p>
<p>首先将每个点看做一条路径，我们需要让路径尽可能的少，所以就需要合并某些路径，合并完成后，最小路径覆盖数 = 结点数 - 合并的点的数量</p>
<p>求解合并的点的个数时可以将点拆成两个，建图时每一条有向边的终点为拆出来的点，此时该问题就转化为了二分图最大匹配问题，建立一个超级源点连接拆点的结点，再建立一个超级汇点连接拆出来的结点，在图上跑最大流即可。</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 155;
const int MAXM = 6e3+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9') 
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int n, m;
int s, t;
int tot = 1;
int d[MAXN&lt;&lt;1];
int to[MAXM&lt;&lt;1];
int gap[MAXN&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];
int val[MAXM&lt;&lt;1];
int pre[MAXN&lt;&lt;1];
int head[MAXN&lt;&lt;1];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

void inp() {
    n = read();
    m = read();
    s = n*2+1;
    t = n*2+2;
    for(int i = 1; i &lt;= m; i++) {
        int x = read();
        int y = read();
        add(x,y+n,1);
        add(y+n,x,0);
    }
    for(int i = 1; i &lt;= n; i++) {
        add(s,i,1);
        add(i,s,0);
        add(i+n,t,1);
        add(t,i+n,0);
    }
}

bool bfs() {
    memset(d,0,sizeof(d));
    queue&lt;int&gt; q;
    d[s] = 1;
    gap[s] = head[s];
    q.push(s);
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == 0 &amp;&amp; val[i] &gt; 0) {
                q.push(y);
                d[y] = d[x] + 1;
                gap[y] = head[y];
                if(y == t) return true;
            }
        }
    }
    return false;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k = 0;
    int res = 0;
    for(int i = gap[now] ; i &amp;&amp; flow; i = nxt[i]) {
        int y = to[i];
        if(val[i] &gt; 0 &amp;&amp; d[y] == d[now] + 1) {
            k = dfs(y,min(flow,val[i]));
            if(!k) {
                d[y] = 0;
                continue;
            }
            flow -= k;
            res += k;
            val[i] -= k;
            val[i^1] += k;
            pre[now] = y;
        }
    }
    return res;
}

bool vis[MAXN&lt;&lt;1];

void find(int now) {
    printf(&quot;%d &quot;,now);
    vis[now] = true;
    for(int i = head[now]; i ; i = nxt[i]) {
        if(to[i] != t &amp;&amp; to[i] != s)
            if(val[i] == 0 &amp;&amp; val[i^1] == 1)
                if(to[i] &gt; n)
                    find(to[i]-n);
    }
}

int main() {

    inp();

    int ans = 0;
    while(bfs()) {
        ans += dfs(s,INF);
    }
    ans = n-ans;

    for(int i = 1; i &lt;= n; i++)
        if(!vis[i]) {
            find(i);
            puts(&quot;&quot;);
        }

    printf(&quot;%d&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2765-魔术球问题">洛谷P2765 魔术球问题</h3>
<p><a href="https://www.luogu.com.cn/problem/P2765">题目链接</a></p>
<p>题目要求的是 这 n 个柱子上最多能放多少个球，将每个柱子看成一个路径，这个问题就可以转化为计算最多 n 条路径最多可以覆盖多少个结点。</p>
<p>具体解法是在枚举每个柱子的时候枚举每一个点，<strong>依次将枚举到的点加入到图中然后去跑最大流，如果求出的最大流等于0则认为当前数量的柱子不能放下这么多球，然后增加柱子数量</strong>。</p>
<p>寻找路径时因为要找出每一个柱子上的结点，所以在搜索时记录好每一个结点的前缀结点，对于每个柱子记录放在上面的第一个结点。</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e5+5;

int n;
int s = 1e5+1;
int t = 1e5+2;
int tot = 1;
int d[MAXN];
int to[MAXN];
int pre[MAXN];
int val[MAXN];
int nxt[MAXN];
int top[MAXN];
int gap[MAXN];
bool vis[MAXN];
int head[MAXN];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

bool bfs() {
    memset(d,-1,sizeof(d));
    queue&lt;int&gt; q;
    q.push(s);
    gap[s] = head[s];
    d[s] = 1;
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == -1 &amp;&amp; val[i] &gt; 0) {
                q.push(y);
                d[y] = d[x] + 1;
                gap[y] = head[y];
            }
        }
    }
    return d[t] != -1;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k = 0;
    int res = 0;
    for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) {
        int y = to[i];
        if(d[y] == d[now] + 1 &amp;&amp; val[i]) {
            k = dfs(y,min(flow,val[i]));
            if(k) {
                flow -= k;
                res += k;
                val[i] -= k;
                val[i^1] += k;
                if(y != t)
                    pre[now&gt;&gt;1] = y&gt;&gt;1;
            }
        }
    }
    return res;
}

int main() {

    scanf(&quot;%d&quot;,&amp;n);

    int now = 0;
    int cnt = 0;
    while(cnt &lt;= n) {
        now++;
        add(s,now&lt;&lt;1,1);
        add(now&lt;&lt;1,s,0);
        add(t,(now&lt;&lt;1)|1,0);
        add((now&lt;&lt;1)|1,t,1);
        for(int i = sqrt(now)+1; i*i &lt; (now&lt;&lt;1); i++) {
            add((i*i-now)&lt;&lt;1,(now&lt;&lt;1)|1,1);
            add((now&lt;&lt;1)|1,(i*i-now)&lt;&lt;1,0);
        }
        int flow = 0;
        while(bfs()) {
            flow += dfs(s,0x3f3f3f3f);
        }
        if(!flow) top[++cnt] = now;
    }

    printf(&quot;%d\n&quot;,now-1);

    for(int i = 1; i &lt;= n; i++) {
        if(vis[top[i]]) continue;
        int x = top[i];
        vis[x] = true;
        while(x) {
            printf(&quot;%d &quot;,x);
            x = pre[x];
            vis[x] = true;
        }
        puts(&quot;&quot;);
    }

    return 0;
}
</code></pre>
<h3 id="洛谷p1231-教辅的组成">洛谷P1231 教辅的组成</h3>
<p><a href="https://www.luogu.com.cn/problem/P1231">题目链接</a></p>
<p>首先对题面进行解析，题目给出书本、练习册、答案的数量，以及可能配套的书本与练习册、书本与答案，要求最多能配成多少套书。</p>
<p>也就是每本书至少要匹配到一本答案和一本练习册才能完成配套。</p>
<p>考虑将结点按照题目要求分为三部分进行建图，建图思路为<strong>源点-&gt;练习册-&gt;书-&gt;答案-&gt;汇点</strong>，然后统计最大流即可。</p>
<p>然后顺手就把图建成了这样。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.luogu.com.cn/upload/image_hosting/y75t8set.png" alt="" loading="lazy"></figure>
<p>但是这样有一个巨大的问题就是每本书可能会被用到很多次，但他们只能被用一次。</p>
<p>解决这个问题我们可以把每本书拆成两个结点，一个用于连接练习册，另一个用于连接答案，两个结点之间连接一条流量为1的边，这样就可以限制每本书被使用的次数了。</p>
<p>正确的建图方法如下</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.luogu.com.cn/upload/image_hosting/y75t8set.png" alt="" loading="lazy"></figure>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 5e4+5;
const int MAXM = 1e5+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int m1,m2;
int tot = 1;
int s = 0;
int t = 5e4+1;
int n1, n2, n3;
int dis[MAXN];
int gap[MAXN];
int head[MAXN];
int val[MAXM&lt;&lt;1];
int to[MAXM&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

bool bfs() {
    memset(dis,0,sizeof(dis));
    queue&lt;int&gt; q;
    q.push(s);
    dis[s] = 1;
    gap[s] = head[s];
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ;i = nxt[i]) {
            int y = to[i];
            if(dis[y] == 0 &amp;&amp; val[i] &gt; 0) {
                dis[y] = dis[x] + 1;
                gap[y] = head[y];
                q.push(y);
            }
        }
    }
    return dis[t] != 0;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k;
    int res = 0;
    for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) {
        int y = to[i];
        if(dis[y] == dis[now] + 1 &amp;&amp; val[i] &gt; 0) {
            k = dfs(y,min(val[i],flow));
            if(!k) dis[y] = -1;
            flow -= k;
            res += k;
            val[i] -= k;
            val[i^1] += k;
        }
    }
    return res;
}

void build() {
    n1 = read();
    n2 = read();
    n3 = read();
    m1 = read();
    int n = n1+n2+n3;
    for(int i = 1; i &lt;= m1; i++) {
        int x = read();
        int y = read();
        add(y+n1,x,1);
        add(x,y+n1,0);
    }
    m2 = read();
    for(int i = 1; i &lt;= m2; i++) {
        int x = read();
        int y = read();
        add(x+n,y+n1+n2,1);
        add(y+n1+n2,x+n,0);
    }
    for(int i = 1; i &lt;= n1; i++) {
        add(i,i+n,1);
        add(i+n,i,0);
    }
    for(int i = 1; i &lt;= n2; i++) {
        add(s,i+n1,1);
        add(i+n1,s,0);
    }
    for(int i = 1; i &lt;= n3; i++) {
        add(i+n1+n2,t,1);
        add(t,i+n1+n2,0);
    }
}

int main() {
    build();

    int ans = 0;
    while(bfs()) {
        ans += dfs(s,INF);
    }

    printf(&quot;%d&quot;,ans);

    return 0;
}
</code></pre>

        </div>

        
          <a class="animated fadeInUp p-2 items-center text-sm text-gray-700 border hover:bg-gray-300 leading-none rounded-full flex lg:inline-flex m-4 " href="https://zzzcd0x.github.io/tag/OsmaBqn6s/">
            <span class="flex-auto">解题报告</span>
          </a>
        


        <div class="flex justify-between py-8">
          

          
            <div class="next-post">
              <a href="https://zzzcd0x.github.io/post/tarjan/">
                <h3 class="post-title">
                  Tarjan
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        

      </div>
    </div>

    <script src="https://zzzcd0x.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
