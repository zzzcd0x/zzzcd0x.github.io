<!DOCTYPE html>
<html>
        <head>
        <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1,initial-scale=1,user-scalable=no" />
        <meta charset="utf-8">
        <title>网络流解题报告 | zzzcd0x &#39;s Blog</title>
        <link rel="stylesheet" href="https://zzzcd0x.github.io/styles/main.css">
        <link rel="stylesheet" href="https://at.alicdn.com/t/font_1306644_jwtuc2zzbrd.css">
        <link href="https://cdn.bootcss.com/animate.css/3.7.2/animate.min.css" rel="stylesheet">
         <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
        <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
         <script src="https://cdn.bootcss.com/highlight.js/9.15.10/highlight.min.js"></script>
         <script >hljs.initHighlightingOnLoad();</script>

    </head>
    <body>
              <header class="header mdui-m-b-5">      
            <div class="container  ">
                <div class="index-title animated fadeInDown mdui-text-center mdui-text-color-white mdui-m-b-2" style="animation-delay: 0.2s"><a href="https://zzzcd0x.github.io">zzzcd0x &#39;s Blog</a></div>
                <div class="mdui-text-color-white animated fadeInDown mdui-text-center  mdui-m-b-3" style="animation-delay: 0.4s">越学越倒退选手</div>
           
            <nav id="nav" class="mdui-text-center animated fadeInDown" style="animation-delay: 0.6s">
                   
                            <li><a href="/">首页</a>
                                <span class="nav-style top"></span>
                                <span class="nav-style bottom"></span>
                                <span class="nav-style left"></span>
                                <span class="nav-style right"></span>
                                </li>
                    
                            <li><a href="/archives">All</a>
                                <span class="nav-style top"></span>
                                <span class="nav-style bottom"></span>
                                <span class="nav-style left"></span>
                                <span class="nav-style right"></span>
                                </li>
                    
                            <li><a href="/tags">分类</a>
                                <span class="nav-style top"></span>
                                <span class="nav-style bottom"></span>
                                <span class="nav-style left"></span>
                                <span class="nav-style right"></span>
                                </li>
                    
                  </nav>
                </div>
        </header>
        <div class="mdui-container ">
                <div class="mdui-row">
                        <div class="mdui-col-md-8 mdui-col-offset-md-2 ">
                                <article class="mdui-p-a-2 post animated fadeIn" style="animation-delay: 0.8s;animation-duration: 2s">
                                    <div class="post-title  mdui-m-b-1">网络流解题报告</div>
                                    <div class="mdui-typo-body-2 mdui-m-b-2" datetime="2020-08-28 16:37:02">2020-08-28 / 22 min read</div>
                                    <div class="mdui-m-b-2 mdui-typo post-neirong"><h3 id="洛谷p3386-二分图最大匹配问题多源多汇最大流">洛谷P3386 二分图最大匹配问题（多源多汇最大流）</h3>
<p><a href="https://www.luogu.com.cn/problem/P3386">题目链接</a></p>
<p>对于二分图的最大匹配问题可以使用匈牙利算法，更一般的做法是网络流最大流。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.luogu.com.cn/upload/image_hosting/sdjlm6zz.png" alt="" loading="lazy"></figure>
<p>这是一个二分图。</p>
<p>也可以这样看这张图。</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.luogu.com.cn/upload/image_hosting/id4l9jvm.png" alt="" loading="lazy"></figure>
<p>0号结点可以看作最大流的超级源点，6号结点可以看作超级汇点，因为每个结点最多只能匹配一个结点，所以<strong>每一条边的最大流量只能是1</strong>。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码。</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1005;
const int MAXM = 1e5+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int s, t;
int n, m, e;
int tot = 1;
int d[MAXN];
int head[MAXN];
int to[MAXM&lt;&lt;1];
int val[MAXM&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];
int gap[MAXM&lt;&lt;1];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

void inp() {
    n = read();
    m = read();
    e = read();
    s = n+m+1;
    t = n+m+2;
    for(int i = 1; i &lt;= e; i++) {
        int x = read();
        int y = read();
        add(x,y+n,1);
        add(y+n,x,0);
    }
    for(int i = 1; i &lt;= n; i++) {
        add(s,i,1);
        add(i,s,0);
    }
    for(int i = 1; i &lt;= m; i++) {
        add(i+n,t,1);
        add(t,i+n,0);
    }
}

bool bfs() {
    memset(d,0,sizeof(d));
    queue&lt;int&gt; q;
    q.push(s);
    d[s] = 1;
    gap[s] = head[s];
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == 0 &amp;&amp; val[i] &gt; 0) {
                q.push(y);
                d[y] = d[x] + 1;
                gap[y] = head[y];
                if(y == t) return true;
            }
        }
    }
    return false;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k = 0;
    int res = 0;
    for(int i = gap[now]; i ; i = nxt[i]) {
        int y = to[i];
        if(val[i] &gt; 0 &amp;&amp; d[y] == d[now] + 1) {
            k = dfs(y,min(val[i],flow));
            if(!k) d[y] = 0;
            flow -= k;
            res += k;
            val[i] -= k;
            val[i^1] += k; 
        }
    }
    return res;
}

int main() {
    inp();

    int ans = 0;
    while(bfs())
        ans += dfs(s,INF); 

    printf(&quot;%d\n&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2764-最小路径覆盖问题拆点">洛谷P2764 最小路径覆盖问题（拆点）</h3>
<p><a href="https://www.luogu.com.cn/problem/P2764">题目链接</a></p>
<p><strong>给定一个有向图 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo>=</mo><mo>(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">G=(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> ,设 P 是 G 的一个简单路的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。</strong></p>
<p>首先将每个点看做一条路径，我们需要让路径尽可能的少，所以就需要合并某些路径，合并完成后，最小路径覆盖数 = 结点数 - 合并的点的数量。</p>
<p>求解合并的点的个数时可以将点拆成两个，建图时每一条有向边的终点为拆出来的点，此时该问题就转化为了二分图最大匹配问题，建立一个超级源点连接拆点的结点，再建立一个超级汇点连接拆出来的结点，在图上跑最大流即可。</p>
<p>以下为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码。</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 155;
const int MAXM = 6e3+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9') 
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int n, m;
int s, t;
int tot = 1;
int d[MAXN&lt;&lt;1];
int to[MAXM&lt;&lt;1];
int gap[MAXN&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];
int val[MAXM&lt;&lt;1];
int pre[MAXN&lt;&lt;1];
int head[MAXN&lt;&lt;1];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

void inp() {
    n = read();
    m = read();
    s = n*2+1;
    t = n*2+2;
    for(int i = 1; i &lt;= m; i++) {
        int x = read();
        int y = read();
        add(x,y+n,1);
        add(y+n,x,0);
    }
    for(int i = 1; i &lt;= n; i++) {
        add(s,i,1);
        add(i,s,0);
        add(i+n,t,1);
        add(t,i+n,0);
    }
}

bool bfs() {
    memset(d,0,sizeof(d));
    queue&lt;int&gt; q;
    d[s] = 1;
    gap[s] = head[s];
    q.push(s);
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == 0 &amp;&amp; val[i] &gt; 0) {
                q.push(y);
                d[y] = d[x] + 1;
                gap[y] = head[y];
                if(y == t) return true;
            }
        }
    }
    return false;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k = 0;
    int res = 0;
    for(int i = gap[now] ; i &amp;&amp; flow; i = nxt[i]) {
        int y = to[i];
        if(val[i] &gt; 0 &amp;&amp; d[y] == d[now] + 1) {
            k = dfs(y,min(flow,val[i]));
            if(!k) {
                d[y] = 0;
                continue;
            }
            flow -= k;
            res += k;
            val[i] -= k;
            val[i^1] += k;
            pre[now] = y;
        }
    }
    return res;
}

bool vis[MAXN&lt;&lt;1];

void find(int now) {
    printf(&quot;%d &quot;,now);
    vis[now] = true;
    for(int i = head[now]; i ; i = nxt[i]) {
        if(to[i] != t &amp;&amp; to[i] != s)
            if(val[i] == 0 &amp;&amp; val[i^1] == 1)
                if(to[i] &gt; n)
                    find(to[i]-n);
    }
}

int main() {
    inp();

    int ans = 0;
    while(bfs()) {
        ans += dfs(s,INF);
    }
    ans = n-ans;

    for(int i = 1; i &lt;= n; i++)
        if(!vis[i]) {
            find(i);
            puts(&quot;&quot;);
        }

    printf(&quot;%d&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2765-魔术球问题动态加点">洛谷P2765 魔术球问题（动态加点）</h3>
<p><a href="https://www.luogu.com.cn/problem/P2765">题目链接</a></p>
<p>题目要求的是 这 n 个柱子上最多能放多少个球，将每个柱子看成一个路径，这个问题就可以转化为计算最多 n 条路径最多可以覆盖多少个结点。</p>
<p>具体解法是在枚举每个柱子的时候枚举每一个点，<strong>依次将枚举到的点加入到图中然后去跑最大流，如果求出的最大流等于0则认为当前数量的柱子不能放下这么多球，然后增加柱子数量</strong>。</p>
<p>寻找路径时因为要找出每一个柱子上的结点，所以在搜索时记录好每一个结点的前缀结点，对于每个柱子记录放在上面的第一个结点。</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e5+5;

int n;
int s = 1e5+1;
int t = 1e5+2;
int tot = 1;
int d[MAXN];
int to[MAXN];
int pre[MAXN];
int val[MAXN];
int nxt[MAXN];
int top[MAXN];
int gap[MAXN];
bool vis[MAXN];
int head[MAXN];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

bool bfs() {
    memset(d,-1,sizeof(d));
    queue&lt;int&gt; q;
    q.push(s);
    gap[s] = head[s];
    d[s] = 1;
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == -1 &amp;&amp; val[i] &gt; 0) {
                q.push(y);
                d[y] = d[x] + 1;
                gap[y] = head[y];
            }
        }
    }
    return d[t] != -1;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k = 0;
    int res = 0;
    for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) {
        int y = to[i];
        if(d[y] == d[now] + 1 &amp;&amp; val[i]) {
            k = dfs(y,min(flow,val[i]));
            if(k) {
                flow -= k;
                res += k;
                val[i] -= k;
                val[i^1] += k;
                if(y != t)
                    pre[now&gt;&gt;1] = y&gt;&gt;1;
            }
        }
    }
    return res;
}

int main() {
    scanf(&quot;%d&quot;,&amp;n);

    int now = 0;
    int cnt = 0;
    while(cnt &lt;= n) {
        now++;
        add(s,now&lt;&lt;1,1);
        add(now&lt;&lt;1,s,0);
        add(t,(now&lt;&lt;1)|1,0);
        add((now&lt;&lt;1)|1,t,1);
        for(int i = sqrt(now)+1; i*i &lt; (now&lt;&lt;1); i++) {
            add((i*i-now)&lt;&lt;1,(now&lt;&lt;1)|1,1);
            add((now&lt;&lt;1)|1,(i*i-now)&lt;&lt;1,0);
        }
        int flow = 0;
        while(bfs()) {
            flow += dfs(s,0x3f3f3f3f);
        }
        if(!flow) top[++cnt] = now;
    }

    printf(&quot;%d\n&quot;,now-1);

    for(int i = 1; i &lt;= n; i++) {
        if(vis[top[i]]) continue;
        int x = top[i];
        vis[x] = true;
        while(x) {
            printf(&quot;%d &quot;,x);
            x = pre[x];
            vis[x] = true;
        }
        puts(&quot;&quot;);
    }

    return 0;
}
</code></pre>
<h3 id="洛谷p1231-教辅的组成最大流">洛谷P1231 教辅的组成（最大流）</h3>
<p><a href="https://www.luogu.com.cn/problem/P1231">题目链接</a></p>
<p>首先对题面进行解析，题目给出书本、练习册、答案的数量，以及可能配套的书本与练习册、书本与答案，要求最多能配成多少套书。</p>
<p>也就是每本书至少要匹配到一本答案和一本练习册才能完成配套。</p>
<p>考虑将结点按照题目要求分为三部分进行建图，建图思路为<strong>源点-&gt;练习册-&gt;书-&gt;答案-&gt;汇点</strong>，然后统计最大流即可。</p>
<p>然后顺手就把图建成了这样。</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.luogu.com.cn/upload/image_hosting/y75t8set.png" alt="" loading="lazy"></figure>
<p>但是这样有一个巨大的问题就是每本书可能会被用到很多次，但他们只能被用一次。</p>
<p>解决这个问题我们可以把每本书拆成两个结点，一个用于连接练习册，另一个用于连接答案，两个结点之间连接一条流量为1的边，这样就可以限制每本书被使用的次数了。</p>
<p>正确的建图方法如下</p>
<figure data-type="image" tabindex="4"><img src="https://cdn.luogu.com.cn/upload/image_hosting/y75t8set.png" alt="" loading="lazy"></figure>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 5e4+5;
const int MAXM = 1e5+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int m1,m2;
int tot = 1;
int s = 0;
int t = 5e4+1;
int n1, n2, n3;
int dis[MAXN];
int gap[MAXN];
int head[MAXN];
int val[MAXM&lt;&lt;1];
int to[MAXM&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

bool bfs() {
    memset(dis,0,sizeof(dis));
    queue&lt;int&gt; q;
    q.push(s);
    dis[s] = 1;
    gap[s] = head[s];
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ;i = nxt[i]) {
            int y = to[i];
            if(dis[y] == 0 &amp;&amp; val[i] &gt; 0) {
                dis[y] = dis[x] + 1;
                gap[y] = head[y];
                q.push(y);
            }
        }
    }
    return dis[t] != 0;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k;
    int res = 0;
    for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) {
        int y = to[i];
        if(dis[y] == dis[now] + 1 &amp;&amp; val[i] &gt; 0) {
            k = dfs(y,min(val[i],flow));
            if(!k) dis[y] = -1;
            flow -= k;
            res += k;
            val[i] -= k;
            val[i^1] += k;
        }
    }
    return res;
}

void build() {
    n1 = read();
    n2 = read();
    n3 = read();
    m1 = read();
    int n = n1+n2+n3;
    for(int i = 1; i &lt;= m1; i++) {
        int x = read();
        int y = read();
        add(y+n1,x,1);
        add(x,y+n1,0);
    }
    m2 = read();
    for(int i = 1; i &lt;= m2; i++) {
        int x = read();
        int y = read();
        add(x+n,y+n1+n2,1);
        add(y+n1+n2,x+n,0);
    }
    for(int i = 1; i &lt;= n1; i++) {
        add(i,i+n,1);
        add(i+n,i,0);
    }
    for(int i = 1; i &lt;= n2; i++) {
        add(s,i+n1,1);
        add(i+n1,s,0);
    }
    for(int i = 1; i &lt;= n3; i++) {
        add(i+n1+n2,t,1);
        add(t,i+n1+n2,0);
    }
}

int main() {
    build();

    int ans = 0;
    while(bfs()) {
        ans += dfs(s,INF);
    }

    printf(&quot;%d&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2598-狼和羊的故事-最小割">洛谷P2598 狼和羊的故事 （最小割）</h3>
<p><a href="https://www.luogu.com.cn/problem/P2598">题目链接</a></p>
<p>这道题刚开始我并没有往最小割的方向考虑，这样充分暴露我对最小割理解的不足。</p>
<p>一开始我以为是最大流，因为每个羊附近最多只能有4只狼，因此从源点开始向每只羊连一条流量为4的边，每只狼向汇点连接一条流量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 的边，每只羊与和他相邻的狼连一条流量为1的边，然后很开心的过了样例，交上去反手爆了个零。<img src="https://cdn.luogu.com.cn/upload/pic/62227.png" alt="/kk" loading="lazy"></p>
<p>回想一下割的性质：</p>
<p><strong>割掉一些边后，源点与汇点不再连通</strong>，最小割就是众多割中割掉的边权值和最小的一个，因此源点和割点分别与羊和狼相连的情况下，求出的最小割就是最小篱笆长度。</p>
<p>正确的建模方式是源点与每一只羊连一条流量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 的边，汇点与每一只狼连一条流量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span> 的边，所有点与四周的结点连一条边。</p>
<p>对于0的归属问题，已经在最大流算法的考虑范围内，所以不用刻意去区分。</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e2+5;
const int MAXM = 1e5+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int n, m;
int s = 0;
int tot = 1;
int d[MAXM];
int t = 1e5+1;
int gap[MAXM];
int head[MAXM];
int to[MAXM&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];
int val[MAXM&lt;&lt;1];
int Map[MAXN][MAXN];

int kx[4] = {0,0,-1,1};
int ky[4] = {-1,1,0,0};

inline int getnum(int x,int y) {return (x-1)*m+y;}

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

void inp() {
    n = read();
    m = read();
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++)
            Map[i][j] = read();
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++) {
            for(int k = 0; k &lt; 4; k++) {
                int x = i + kx[k];
                int y = j + ky[k];
                if(x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m) continue;
                    add(getnum(i,j),getnum(x,y),1);
                    add(getnum(x,y),getnum(i,j),0);
                }
            if(Map[i][j] == 1) {
                add(getnum(i,j),t,INF);
                add(t,getnum(i,j),0);
            }
            else if(Map[i][j] == 2) {
                add(s,getnum(i,j),INF);
                add(getnum(i,j),s,0);
            }
        }
}

bool bfs() {
    memset(d,0,sizeof(d));
    queue&lt;int&gt; q;
    d[s] = 1;
    gap[s] = head[s];
    q.push(s);
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == 0 &amp;&amp; val[i] &gt; 0) {
                d[y] = d[x] + 1;
                gap[y] = head[y];
                q.push(y);
            }
        }
    }
    return d[t] != 0;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k;
    int res = 0;
    for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) {
        gap[now] = i;
        int y = to[i];
        if(d[y] == d[now] + 1 &amp;&amp; val[i] &gt; 0) {
            k = dfs(y,min(flow,val[i]));
            if(!k) d[y] = 0;
            res += k;
            flow -= k;
            val[i] -= k;
            val[i^1] += k;
        }
    }
    return res;
}

int main() {
    inp();

    int ans = 0;
    while(bfs()) {
        ans += dfs(s,INF);
    }
    
    printf(&quot;%d\n&quot;,ans);

    return 0;
}
</code></pre>
<h3 id="洛谷p2774-方格取数问题二分图带权最大独立集">洛谷P2774 方格取数问题（二分图带权最大独立集）</h3>
<p><a href="https://www.luogu.com.cn/problem/P2774">题目链接</a></p>
<p>给定一个方格图，从方格中取出一些结点，使任意两个结点之间没有公共边，且取出的数的总和最大。</p>
<p>将方格内的数做为权值，取出的点看做一个集合，集合内结点权值和最大时即为带权最大独立集。</p>
<p>对于最大权值的求解，可以将问题转化为取出的数的总和最小，则用所有点的权值和减去取出的数的权值和即为最大独立集的权值和。</p>
<p>现在问题就转化为了怎么讲方格图转化为二分图。</p>
<p>可以将方格图看作棋盘（一半为黑格子一半为白格子），根据结点编号的奇偶性分为两组，一组连源点，一组连汇点，连接源点和汇点的边的权值设为结点放的数字的值。</p>
<p>既然公共边是方格图中一个方格与其四周的方格共有的边，则可以将这些公共边看成结点与其四周的结点所连的边，这些边的权值为正无穷。</p>
<p>方格编码示例：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">∣</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>6</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>10</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>11</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>12</mn></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><annotation encoding="application/x-tex">\begin{vmatrix}
1&amp;2&amp;3&amp;4\\
5&amp;6&amp;7&amp;8\\
9&amp;10&amp;11&amp;12\\
\end{vmatrix}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.636em;vertical-align:-1.5500299999999998em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.08597em;"><span style="top:-1.05597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.6619700000000002em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26797em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87397em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-4.08597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500299999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">5</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">9</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">7</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">8</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.08597em;"><span style="top:-1.05597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-1.6619700000000002em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26797em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.87397em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47997em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-4.08597em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500299999999998em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>这样建图后，方格之间的边容量为正无穷，所以任何一个割中不可能包含这些点，所以求最小割的时候割掉的边就是与源点或汇点连接的边。</p>
<p>当一个点与源点或汇点连接的边被切断了，则视为这个点已经被取出。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">AC</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 代码</p>
<pre><code class="language-cpp">#include&lt;queue&gt;
#include&lt;cstdio&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1e4+5; //数组又开小了 我弱智...
const int MAXM = 1e5+5;
const int INF = 0x3f3f3f3f;

inline int read() {
    int x = 0;
    char c = getchar();
    while(c &lt; '0' || c &gt; '9')
        c = getchar();
    while(c &gt;= '0' &amp;&amp; c &lt;= '9') {
        x = x*10 + c-'0';
        c = getchar();
    }
    return x;
}

int sum;
int s, t;
int n, m;
int tot = 1;
int d[MAXN];
int gap[MAXN];
bool vis[MAXN];
int head[MAXN];
int to[MAXM&lt;&lt;1];
int val[MAXM&lt;&lt;1];
int nxt[MAXM&lt;&lt;1];
int dx[4] = {0,0,-1,1};
int dy[4] = {-1,1,0,0};

inline int Hash(int x,int y) {return m*(x-1)+y;}

void add(int x,int y,int z) {
    nxt[++tot] = head[x];
    head[x] = tot;
    to[tot] = y;
    val[tot] = z;
}

void inp() {
    n = read();
    m = read();
    s = 0;
    t = m*n+1;
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= m; j++) {
            int y = read();
            sum += y;
            int x = Hash(i,j);
            if((i+j)%2 == 0) {
                add(s,x,y);
                add(x,s,0);
                for(int k = 0; k &lt; 4; k++) {
                    int tx = i + dx[k];
                    int ty = j + dy[k];
                    if(tx &lt; 1 || ty &lt; 1 || tx &gt; n || ty &gt; m)
                        continue;
                    int T = Hash(tx,ty);
                    add(x,T,INF);
                    add(T,x,0);
                }
            }
            else {
                add(x,t,y);
                add(t,x,0);
            }
        }
}

bool bfs() {
    queue&lt;int&gt; q;
    memset(d,0,sizeof(d));
    d[s] = 1;
    gap[s] = head[s];
    q.push(s);
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        for(int i = head[x]; i ; i = nxt[i]) {
            int y = to[i];
            if(d[y] == 0 &amp;&amp; val[i] &gt; 0) {
                gap[y] = head[y];
                d[y] = d[x] + 1;
                q.push(y);
                if(y == t) return true;
            }
        }
    }
    return false;
}

int dfs(int now,int flow) {
    if(now == t) return flow;
    int k;
    int res = 0;
    for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) {
        int y = to[i];
        gap[now] = i;
        if(d[y] == d[now] + 1 &amp;&amp; val[i] &gt; 0) {
            k = dfs(y,min(flow,val[i]));
            if(!k) d[y] = 0;
            res += k;
            flow -= k;
            val[i] -= k;
            val[i^1] += k;
        }
    }
    return res;
}

int main() {
    inp();

    int ans = 0;
    while(bfs())
        ans += dfs(s,INF);

    printf(&quot;%d\n&quot;,sum-ans);

    return 0;
}
</code></pre>
</div>
                                    <div class="mdui-divider mdui-m-b-2"></div>
                                    <div class="mdui-row-xs-2 post-fenye">
                                       
                                        <div class="mdui-col"> </div>
                                        

                                        
                                        <div class="mdui-col"><div class="mdui-text-right "><a href="https://zzzcd0x.github.io/post/tarjan/">Tarjan</a></div> </div>
                                       
                                      </div>
                                   
                                    <div class="mdui-divider mdui-m-t-2 mdui-m-b-2"></div>
                                    
                                     <script src="https://zzzcd0x.github.io/media/scripts/Valine.min.js"></script>
 <div class="comment"></div>

<script>
      new Valine({
            el: '.comment',



            path: window.location.pathname,
            pageSize: 30,
            avatar:'mm', 
       })
    </script> 
<script>
    if(window.location.hash){
        var checkExist = setInterval(function() {
           if ($(window.location.hash).length) {
              $('html, body').animate({scrollTop: $(window.location.hash).offset().top-90}, 1000);
              clearInterval(checkExist);
           }
        }, 100);
    }
</script>
                                </article>

                                    
                        </div>
                      </div>
    
                

              </div>
                    <footer class="footer mdui-m-t-5 mdui-text-center">
               <nav class="social-links">
                      <ul>
                      
                      
                           
                      
                           
                      	
                        <li class="social-link"><a href="https://github.com/zzzcd0x" target="_blank"><i class="iconfont icon-github"></i></a></li>
                          
                           
                      
                           
                      
                           
                      
                           
                      
                           
                      
                           
                      
                           
                      
                           
                      
                           
                      
                           
                      </ul>
                    </nav>
                    <div class="copyright">
                      <p>Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> <br/> Theme <a href="https://github.com/alterfang/gridea-theme-song/" target="_blank"  title="宋"  >Song</a> by <a href="https://shanbu.fun/" target="_blank"  title="山卜方" >shanbufun</a> </p>
                  </div>
                  
              </footer>
    </body>
</html>