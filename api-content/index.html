{"posts":[{"title":"网络流初步","content":"相关定义 网络流图 是一个满足以下条件的 DAG 只有一个入度为0的点，称为源点。 只有一个出度为0的点，称为汇点。 每条边都有一个非负权值，称为这条边的容量。 容许流 网络流图中，对于每条边e=(i,j)e=(i,j)e=(i,j)，给定实数fef_efe​,如果满足fe≤Cef_e \\leq C_efe​≤Ce​，则有以下性质 对于任意 x≠S,Tx \\neq S,Tx​=S,T,∑e=(x,i)fe=∑e=(i,x)fe\\sum{_{e=(x,i)}f_e} = \\sum{_{e=(i,x)}f_e}∑e=(x,i)​fe​=∑e=(i,x)​fe​ W=∑e=(S,i)fe=∑e=(i,x)feW = \\sum{{e=(S,i)}f_e} = \\sum{{e=(i,x)}f_e}W=∑e=(S,i)fe​=∑e=(i,x)fe​ 则这一组fff称为该网络的一个流量为WWW的容许流。 增广路 从源点开始到达汇点的一条路径中，每一段都满足流量小于容量，设这条路上每一段的容量减流量的值的最小值为Δ\\DeltaΔ 。 将这条路上的每一段的流量加上 Δ\\DeltaΔ 后保证这条路依然可行，则该路径称为这个网络的一条增广路。 简而言之，就是一条从源点到汇点的路径上的各边的剩余容量都大于0的路径。 残量网络 任意时刻，网络流图中所有节点及其剩余容量大于0的边构成的子图。 割 一张图中，去掉图中的几条边后，可以将该图分割为两个不相交的点集，则去掉的这些边称为这张图的一个割。 对于一条有向边 VVV ，通常称他的反向边为 Vˉ\\bar{V}Vˉ 。 最大流 对于一个给定的网络，合法的流函数中使得整个网络的流量最大的一个称为该网络的最大流，此时的流量是该网络的最大流量。 EK算法 EK算法的思想是在网络流图中不断bfs搜索增广路，直到图中不存在增广路。 也可以理解为在网络流图中寻找从S到V边数最短的增广路进行增广，直到无法继续增广。 搜索的过程中只考虑图中流量小于容量的边，bfs找到任意一条增广路，同时计算出路径上各边剩余容量的最小值 minfminfminf ，整个网络的流量可以增加 minfminfminf。 引理1 令fif_ifi​为增广iii次后得到的一个容许流，λk(u,v){\\lambda}^{k}(u,v)λk(u,v)表示fkf_kfk​中uuu到vvv的一条最短路长度，则 λk(S,v)≤λk+1(S,v)，λk(v,T)≤λk+1(v,T){\\lambda}^{k}(S,v) \\leq {\\lambda}^{k+1}(S,v)，{\\lambda}^{k}(v,T) \\leq {\\lambda}^{k+1}(v,T) λk(S,v)≤λk+1(S,v)，λk(v,T)≤λk+1(v,T) 假设fk+1f_{k+1}fk+1​中从S到v的最短路为S到 u0,u1...up−1,up=vu_0,u_1...u_{p-1},u_p = vu0​,u1​...up−1​,up​=v。 设 ei=(ui−1,ui)e_i = (u_{i-1},u_i)ei​=(ui−1​,ui​) 。 若 eie_iei​ 在 fkf_kfk​ 中可用，则 λk(S,v)≤λk+1(S,v){\\lambda}^{k}(S,v) \\leq {\\lambda}^{k+1}(S,v)λk(S,v)≤λk+1(S,v) 。 若 eie_iei​ 在 fkf_kfk​ 中不可用，则他的相反路径一定可用，且在 S 到 ui−1u_{i-1}ui−1​ 的最短路上，且 λk(S,ui−1)=λk(S,ui)+1{\\lambda}^{k}(S,u_{i-1}) = {\\lambda}^k(S,u_i)+1λk(S,ui−1​)=λk(S,ui​)+1 。因为当 eie_iei​ 不可用情况下，eie_iei​ 必然在之前的增广中被增广过了，即 eie_iei​ 在从 S 到 uiu_iui​ 的最短路上，所以此时 S 到 ui−1u_{i-1}ui−1​ 的最短路上一定有 eie_iei​ 的反向边，否则 eie_iei​ 不会不可用。 引理2 设边 eie_iei​ 在 fkf_kfk​ 到 fk+1f_{k+1}fk+1​ 的增广路中，则 eie_iei​ 的反向路径在 fif_ifi​ 到 fi+1f_{i+1}fi+1​ 的增广路中 (k&lt;i)(k&lt;i)(k&lt;i) ，则 λi(S,T)≥λk(S,T)+2{\\lambda}^i(S,T) \\geq {\\lambda}^k(S,T)+2 λi(S,T)≥λk(S,T)+2 假设 e=(u,v)e = (u,v)e=(u,v)，则 λk(S,v)=λk(S,u)+1{\\lambda}^k(S,v) = {\\lambda}^k(S,u)+1 λk(S,v)=λk(S,u)+1 λi(S,T)=λi(S,v)+1+λi(u,T){\\lambda}^i(S,T) = {\\lambda}^i(S,v)+1+{\\lambda}^i(u,T) λi(S,T)=λi(S,v)+1+λi(u,T) 由引理1得 λi(S,T)≥λk(S,v)+1+λk(u,T)=λk(S,u)+2+λk(u,T)=λk(S,T)+2{\\lambda}^i(S,T) \\geq {\\lambda}^k(S,v)+1+{\\lambda}^k(u,T) = {\\lambda}^k(S,u)+2+{\\lambda}^k(u,T) = {\\lambda}^k(S,T)+2 λi(S,T)≥λk(S,v)+1+λk(u,T)=λk(S,u)+2+λk(u,T)=λk(S,T)+2 每条边最多称为 n+22\\frac{n+2}{2}2n+2​ 次瓶颈，所以最多有 m(n+2)2\\frac{m(n+2)}{2}2m(n+2)​ 条增广路。 EK算法的时间复杂度为 O(nm2)O(nm^2)O(nm2)。 模板 const int INF = 1&lt;&lt;29; const int MAXN = 1e5+5; int Max; int tot = 1; int n, m, s, t; bool v[MAXN]; int head[MAXN]; int incf[MAXN]; int to[MAXN&lt;&lt;1]; int pre[MAXN&lt;&lt;1]; int val[MAXN&lt;&lt;1]; int nxt[MAXN&lt;&lt;1]; void add(int x,int y,int z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } bool bfs() { memset(v,0,sizeof(v)); queue&lt;int&gt; q; q.push(s); v[s] = true; incf[s] = INF; while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i; i = nxt[i]) { if(val[i]) { int y = to[i]; if(v[y]) continue; incf[y] = min(incf[x],val[i]); pre[y] = i; q.push(y); v[y] = true; if(y == t) return true; } } } return false; } void upd() { int x = t; while(x != s) { int i = pre[x]; val[i] -= incf[t]; val[i^1] += incf[t]; //反向边 x = to[i^1]; } Max += incf[t]; } void inp() { Max = 0; tot = 1; scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); for(int i = 1; i &lt;= m; i++) { int x,y,z; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,0); } } Dinic算法 EK算法每次搜索可能会遍历整个残量网络但只求出一条增广路，实际上可以一次求出多条满足条件的增广路进行增广。 Dinic算法不断重复一下步骤，直到残量网络中S不能到达T。 在每次增广时，在残量网络上bfs求出每个节点的层次，构造分层图。 在分层图中dfs寻找增广路，在回溯时实时更新剩余容量。 当前弧优化 dfs的过程中，维护每一个点可能用于增广的第一条边，每次搜索时舍弃掉不能继续增广的边。 Dinic算法的时间复杂度为 O(n2m)O(n^2m)O(n2m)。 模板 typedef long long ll; const int MAXN = 205; const int MAXM = 5e3+5; const ll INF = 0x7f7f7f7f; int tot = 1; int n, m, s, t; ll dis[MAXN]; int gap[MAXN]; int head[MAXN]; int to[MAXM&lt;&lt;1]; ll val[MAXM&lt;&lt;1]; int nxt[MAXM&lt;&lt;1]; void add(int x,int y,ll z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } bool bfs() { for(int i = 1; i &lt;= n; i++) dis[i] = INF; queue&lt;int&gt; q; q.push(s); dis[s] = 0; gap[s] = head[s]; while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i ; i = nxt[i]) { if(val[i] &gt; 0 &amp;&amp; dis[to[i]] == INF) { q.push(to[i]); gap[to[i]] = head[to[i]]; dis[to[i]] = dis[x] + 1; if(to[i] == t) return true; } } } return false; } ll dinic(int now,ll flow) { if(now == t) return flow; ll k, res = 0; for(int i = gap[now] ; i &amp;&amp; flow ; i = nxt[i]) { gap[now] = i; if(val[i] &gt; 0 &amp;&amp; dis[to[i]] == dis[now] + 1) { k = dinic(to[i],min(flow,val[i])); if(!k) dis[to[i]] = INF; val[i] -= k; val[i^1] += k; res += k; flow -= k; } } return res; } void inp() { scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); for(int i = 1; i &lt;= m; i++) { int x, y; ll z; scanf(&quot;%d %d %lld&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,0); } } 最大流最小割定理 设 V 是网络流图的一个结点集，满足 S∈V,T∈VS\\in V,T\\in VS∈V,T∈V，则全部有向边 (i，j),i∈S,j∈Sˉ(i，j),i\\in S,j\\in\\bar{S}(i，j),i∈S,j∈Sˉ 的集合称为原网络流图的一个割，记为 (V,Vˉ)(V,\\bar{V})(V,Vˉ)，集合中所有边的容量之和称为该割的容量。 容量最小的割称为原网络流图的最小割。 一个网络流图的最大流容量 = 最小割容量。 费用流 给定一个网络，对于每条边除了有容量限制，还有一个给定的单位费用，即假设一条边的单位费用为 xxx ，则这条边流量为 yyy 时，需要花费 x∗yx*yx∗y 的费用。 费用流问题的前提是最大流，大多数费用流问题都可以抽象为最小费用最大流或最大费用最小流问题。 EK算法 对于EK算法，将每次寻找路径最少的最短路改为寻找费用和最小的最短路即可。 这时要用到单源最短路算法，由于可能出现负权边，因此选择使用SPFA而不是Dijkstra~~（诈尸啦！）~~ 模板 #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int MAXN = 5e5+5; const int MAXM = 5e4+5; const int INF = 0x3f3f3f3f; int tot = 1; ll Max_cost; ll Max_flow; int n, m, s, t; bool v[MAXN]; ll dis[MAXN]; ll incf[MAXN]; int head[MAXN]; int to[MAXM&lt;&lt;1]; ll val[MAXM&lt;&lt;1]; int nxt[MAXM&lt;&lt;1]; ll cost[MAXM&lt;&lt;1]; int pre[MAXM&lt;&lt;1]; void add(int x,int y,ll z,ll h) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; cost[tot] = h; } bool bfs() { for(int i = 1; i &lt;= n; i++) { v[i] = false; dis[i] = INF; } queue&lt;int&gt; q; q.push(s); v[s] = true; dis[s] = 0; incf[s] = INF; bool jud = false; while(!q.empty()) { int x = q.front(); q.pop(); v[x] = false; for(int i = head[x]; i; i = nxt[i]) { int y = to[i]; if(val[i] &amp;&amp; dis[y] &gt; dis[x] + cost[i]) { pre[y] = i; dis[y] = dis[x] + cost[i]; incf[y] = min(incf[x],val[i]); if(!v[y]) { q.push(y); v[y] = true; } if(y == t) jud = true; } } } return jud; } void upd() { int x = t; while(x != s) { int i = pre[x]; val[i] -= incf[t]; val[i^1] += incf[t]; x = to[i^1]; } Max_flow += incf[t]; Max_cost += incf[t]*dis[t]; } void inp() { Max_flow = 0; tot = 1; scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); for(int i = 1; i &lt;= m; i++) { int x,y; ll z,h; scanf(&quot;%d %d %lld %lld&quot;,&amp;x,&amp;y,&amp;z,&amp;h); add(x,y,z,h); add(y,x,0,-h); } } int main() { inp(); while(bfs()) upd(); printf(&quot;%lld %lld\\n&quot;,Max_flow,Max_cost); return 0; } 例题 二分图最大匹配问题 解决二分图匹配问题可以使用匈牙利算法，也可以用网络流最大流的模型来解决 这是一个二分图 也可以这样看这张图 0号结点可以看作最大流的超级源点，6号结点可以看作超级汇点，因为每个结点最多只能匹配一个结点，所以每一条边的最大流量只能是1 代码可以这样写 题目链接 #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN = 1005; const int MAXM = 1e5+5; const int INF = 0x3f3f3f3f; inline int read() { int x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int s, t; int n, m, e; int tot = 1; int d[MAXN]; int head[MAXN]; int to[MAXM&lt;&lt;1]; int val[MAXM&lt;&lt;1]; int nxt[MAXM&lt;&lt;1]; int gap[MAXM&lt;&lt;1]; void add(int x,int y,int z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } void inp() { n = read(); m = read(); e = read(); s = n+m+1; t = n+m+2; for(int i = 1; i &lt;= e; i++) { int x = read(); int y = read(); add(x,y+n,1); add(y+n,x,0); } for(int i = 1; i &lt;= n; i++) { add(s,i,1); add(i,s,0); } for(int i = 1; i &lt;= m; i++) { add(i+n,t,1); add(t,i+n,0); } } bool bfs() { memset(d,0,sizeof(d)); queue&lt;int&gt; q; q.push(s); d[s] = 1; gap[s] = head[s]; while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i ; i = nxt[i]) { int y = to[i]; if(d[y] == 0 &amp;&amp; val[i] &gt; 0) { q.push(y); d[y] = d[x] + 1; gap[y] = head[y]; if(y == t) return true; } } } return false; } int dfs(int now,int flow) { if(now == t) return flow; int k = 0; int res = 0; for(int i = gap[now]; i ; i = nxt[i]) { int y = to[i]; if(val[i] &gt; 0 &amp;&amp; d[y] == d[now] + 1) { k = dfs(y,min(val[i],flow)); if(!k) d[y] = 0; flow -= k; res += k; val[i] -= k; val[i^1] += k; } } return res; } int main() { inp(); int ans = 0; while(bfs()) ans += dfs(s,INF); printf(&quot;%d\\n&quot;,ans); return 0; } 最小路径覆盖问题 题目链接 给定一个有向图 G=(V,E)G=(V,E)G=(V,E) ,设 P 是 G 的一个简单路的集合。如果 V 中每个顶点恰好在 P 的一条路上，则称 P 是 G 的一个路径覆盖。 首先将每个点看做一条路径，我们需要让路径尽可能的少，所以就需要合并某些路径，合并完成后，最小路径覆盖数 = 结点数 - 合并的点的数量 求解合并的点的个数时可以将点拆成两个，建图时每一条有向边的终点为拆出来的点，此时该问题就转化为了二分图最大匹配问题，建立一个超级源点连接拆点的结点，再建立一个超级汇点连接拆出来的结点，在图上跑最大流即可。 #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN = 155; const int MAXM = 6e3+5; const int INF = 0x3f3f3f3f; inline int read() { int x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int n, m; int s, t; int tot = 1; int d[MAXN&lt;&lt;1]; int to[MAXM&lt;&lt;1]; int gap[MAXN&lt;&lt;1]; int nxt[MAXM&lt;&lt;1]; int val[MAXM&lt;&lt;1]; int pre[MAXN&lt;&lt;1]; int head[MAXN&lt;&lt;1]; void add(int x,int y,int z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } void inp() { n = read(); m = read(); s = n*2+1; t = n*2+2; for(int i = 1; i &lt;= m; i++) { int x = read(); int y = read(); add(x,y+n,1); add(y+n,x,0); } for(int i = 1; i &lt;= n; i++) { add(s,i,1); add(i,s,0); add(i+n,t,1); add(t,i+n,0); } } bool bfs() { memset(d,0,sizeof(d)); queue&lt;int&gt; q; d[s] = 1; gap[s] = head[s]; q.push(s); while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i ; i = nxt[i]) { int y = to[i]; if(d[y] == 0 &amp;&amp; val[i] &gt; 0) { q.push(y); d[y] = d[x] + 1; gap[y] = head[y]; if(y == t) return true; } } } return false; } int dfs(int now,int flow) { if(now == t) return flow; int k = 0; int res = 0; for(int i = gap[now] ; i &amp;&amp; flow; i = nxt[i]) { int y = to[i]; if(val[i] &gt; 0 &amp;&amp; d[y] == d[now] + 1) { k = dfs(y,min(flow,val[i])); if(!k) { d[y] = 0; continue; } flow -= k; res += k; val[i] -= k; val[i^1] += k; pre[now] = y; } } return res; } bool vis[MAXN&lt;&lt;1]; void find(int now) { printf(&quot;%d &quot;,now); vis[now] = true; for(int i = head[now]; i ; i = nxt[i]) { if(to[i] != t &amp;&amp; to[i] != s) if(val[i] == 0 &amp;&amp; val[i^1] == 1) if(to[i] &gt; n) find(to[i]-n); } } int main() { inp(); int ans = 0; while(bfs()) { ans += dfs(s,INF); } ans = n-ans; for(int i = 1; i &lt;= n; i++) if(!vis[i]) { find(i); puts(&quot;&quot;); } printf(&quot;%d&quot;,ans); return 0; } 魔术球问题 题目链接 题目要求的是 这 n 个柱子上最多能放多少个球，将每个柱子看成一个路径，这个问题就可以转化为计算最多 n 条路径最多可以覆盖多少个结点。 具体解法是在枚举每个柱子的时候枚举每一个点，依次将枚举到的点加入到图中然后去跑最大流，如果求出的最大流等于0则认为当前数量的柱子不能放下这么多球，然后增加柱子数量。 寻找路径时因为要找出每一个柱子上的结点，所以在搜索时记录好每一个结点的前缀结点，对于每个柱子记录放在上面的第一个结点。 #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN = 1e5+5; int n; int s = 1e5+1; int t = 1e5+2; int tot = 1; int d[MAXN]; int to[MAXN]; int pre[MAXN]; int val[MAXN]; int nxt[MAXN]; int top[MAXN]; int gap[MAXN]; bool vis[MAXN]; int head[MAXN]; void add(int x,int y,int z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } bool bfs() { memset(d,-1,sizeof(d)); queue&lt;int&gt; q; q.push(s); gap[s] = head[s]; d[s] = 1; while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i ; i = nxt[i]) { int y = to[i]; if(d[y] == -1 &amp;&amp; val[i] &gt; 0) { q.push(y); d[y] = d[x] + 1; gap[y] = head[y]; } } } return d[t] != -1; } int dfs(int now,int flow) { if(now == t) return flow; int k = 0; int res = 0; for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) { int y = to[i]; if(d[y] == d[now] + 1 &amp;&amp; val[i]) { k = dfs(y,min(flow,val[i])); if(k) { flow -= k; res += k; val[i] -= k; val[i^1] += k; if(y != t) pre[now&gt;&gt;1] = y&gt;&gt;1; } } } return res; } int main() { scanf(&quot;%d&quot;,&amp;n); int now = 0; int cnt = 0; while(cnt &lt;= n) { now++; add(s,now&lt;&lt;1,1); add(now&lt;&lt;1,s,0); add(t,(now&lt;&lt;1)|1,0); add((now&lt;&lt;1)|1,t,1); for(int i = sqrt(now)+1; i*i &lt; (now&lt;&lt;1); i++) { add((i*i-now)&lt;&lt;1,(now&lt;&lt;1)|1,1); add((now&lt;&lt;1)|1,(i*i-now)&lt;&lt;1,0); } int flow = 0; while(bfs()) { flow += dfs(s,0x3f3f3f3f); } if(!flow) top[++cnt] = now; } printf(&quot;%d\\n&quot;,now-1); for(int i = 1; i &lt;= n; i++) { if(vis[top[i]]) continue; int x = top[i]; vis[x] = true; while(x) { printf(&quot;%d &quot;,x); x = pre[x]; vis[x] = true; } puts(&quot;&quot;); } return 0; } ","link":"https://zzzcd0x.github.io/post/wang-luo-liu-chu-bu/"},{"title":"最近公共祖先","content":"树上倍增法 怎么计算的？ 假设要计算树上x和y结点的最近公共祖先，d[x]表示结点x的深度，F[x,k]表示结点x向上跳2 设d[x] &gt;= d[y]否则交换x和y 将x结点尝试向上走2^{log(n)}...2^{log(0)}步，检查每次到达的结点是否比y深，若是，则令x=F[x,k]，跳出循环 如果此时x=y则两个结点的LCA就是y 如果不是，则将x和y同时向上调整，保持两者深度相同但不相等，即将两节点同时向上跳2^{log(n)}...2^{log(0)}步，若此时F[x,k]!=F[y,k](即深度不相等)，则令x=F[x,k],y=F[y,k] 循环结束后x和y一定差一步到达同一结点，即他们的最近公共祖先为F[x,0]或F[y,0] 单次查询时间复杂度为log(n) 例题 模板题 #include&lt;cstdio&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN = 4e4+5; const int MAXM = 2e2+5; int tot; int n, m; int dis[MAXN]; int dep[MAXN]; int head[MAXN]; bool vis[MAXN]; int to[MAXN&lt;&lt;1]; int fa[MAXN][25]; int nxt[MAXN&lt;&lt;1]; int val[MAXN&lt;&lt;1]; void add(int x,int y,int z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } void dfs(int now,int dad) { if(vis[now]) return; vis[now] = true; fa[now][0] = dad; for(int i = head[now]; i ;i = nxt[i]) { if(to[i] == dad) continue; dis[to[i]] = dis[now] + val[i]; dep[to[i]] = dep[now] + 1; dfs(to[i],now); } } int lca(int x,int y) { if(dep[x] &gt; dep[y]) swap(x,y); for(int i = 20; i &gt;= 0; i--) if((dep[y] - (1&lt;&lt;i) ) &gt;= dep[x]) y = fa[y][i]; if(x == y) return x; for(int i = 20; i &gt;= 0; i--) if(fa[x][i] != fa[y][i]) { x = fa[x][i]; y = fa[y][i]; } return fa[x][0]; } int t; void inp() { for(int i = 1; i &lt; n; i++) { int x, y, z; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z); } } void init() { memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); memset(dep,0,sizeof(dep)); memset(head,0,sizeof(head)); tot = 0; } int main() { scanf(&quot;%d&quot;,&amp;t); while(t) { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); init(); inp(); dfs(1,1); for(int i = 1; i &lt;= 20; i++) for(int j = 1; j &lt;= n; j++) fa[j][i] = fa[fa[j][i-1]][i-1]; for(int i = 1; i &lt;= m; i++) { int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,dis[x] + dis[y] - 2*dis[lca(x,y)]); } t--; } return 0; } ","link":"https://zzzcd0x.github.io/post/zui-jin-gong-gong-zu-xian/"},{"title":"SPFA","content":"虽然spfa算法赛场上会各种被卡，但还是蛮不错的。 大致思想 首先将源点加入队列 然后更新源点能够到达的点的最短路 如果被更新的点不在队列中，则加入队列 重复上述2~3步直到队列为空 其实思想与dijkstra比较相似，不同的是dijkstra判断点是否进队的依据是该点的最短路有没有被更新过 而spfa的依据是该点在不在队列中 实现 链式前向星部分已省略 int d[MAXN]; bool b[MAXN]; void spfa(int s){ memset(d,0x3f,sizeof(d)); d[s] = 0; b[s] = true; q.push(s); while(!q.empty()) { int x = q.front(); q.pop(); b[x] = false; for(int i = head[x]; i ;i = edge[i].next) { int to = edge[i].to; int val = edge[i].val; if(d[to] &gt; d[x] + val) { d[to] = d[x] + val; if(!b[to]) { q.push(to); b[to] = true; } } } } } 例题 判断负环 题目链接 如果图中出现了负环那么在spfa中负环上的结点会不断的入队，因此只要对入队次数进行计数，如果有一个结点入队次数大于等于总结点数，则图中一定存在负环 #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;utility&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int MAXN = 505; const int MAXM = 3005; inline int read() { int x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int tot; int n, m, w; int head[MAXN]; int to[MAXM&lt;&lt;1]; ll val[MAXM&lt;&lt;1]; int nxt[MAXM&lt;&lt;1]; int from[MAXM&lt;&lt;1]; void add(int x,int y,ll z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; from[tot] = x; } void inp() { n = read(); m = read(); w = read(); tot = 0; memset(head,0,sizeof(head)); memset(nxt,0,sizeof(0)); for(int i = 1; i &lt;= m; i++) { int x = read(); int y = read(); ll z = read(); add(x,y,z); add(y,x,z); } for(int i = 1; i &lt;= w; i++) { int x = read(); int y = read(); ll z = read(); add(x,y,-z); } } ll d[MAXN]; int temp[MAXN]; bool vis[MAXN]; bool spfa() { queue&lt;int&gt; q; memset(d,0x3f,sizeof(d)); memset(temp,0,sizeof(temp)); memset(vis,false,sizeof(vis)); q.push(1); temp[1]++; d[1] = 0; vis[1] = true; while(!q.empty()) { int x = q.front(); vis[x] = false; q.pop(); for(int i = head[x]; i ; i = nxt[i]) { if(d[to[i]] &gt; d[x] + val[i]) { d[to[i]] = d[x] + val[i]; temp[to[i]]++; if(temp[to[i]] &gt;= n) return true; if(!vis[to[i]]) { q.push(to[i]); vis[to[i]] = true; } } } } return false; } int main() { int t = read(); while(t) { inp(); if(spfa()) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); t--; } return 0; } ","link":"https://zzzcd0x.github.io/post/spfa/"},{"title":"并查集DSU","content":" 引入 假设现在有n个仅知道自己的父亲是谁的人，现在要存储他们每个人之间的关系，并查询其中几个人是否属于同一家族 思路 首先可以想到每一个家族可以组成一个树，但如果每一个结点都只储存自己的父亲是谁，那这几棵树就会 进化 变成一个森林 所以在存储两个结点的父子关系时，我们应该认定两个结点的最远古的父结点之间有亲缘关系，从而防止森林的诞生 对于查询两个结点的是否属于同一家族，我们仅需要查询他们的最远古祖先是否相同，但当某一个结点没有父结点时，这个结点就一定是当前家族的最远古祖先 思路就是这样了 那么我们用代码来实现一下 朴素写法 int dad[10005]; //存储每个结点的父结点 int anc(int x){ //查询每个结点的远古祖先 if(dad[x]) return anc(dad[x]); else return x; //当该结点没有父结点时当前结点即为最远古祖先 } bool ask(int x, int y){ //查询两个结点是否在同一家族 return anc(x) == anc(y); } void uni(int x, int y){ //设定亲属关系 x = anc(x); y = anc(y); if(x != y) dad[x] = y; } 以上就是并查集的一种朴素写法 路径压缩优化 分析一下这种写法的复杂度我们就可以发现，ask()和uni()函数都是通过anc()来实现的，但如果碰到了子子孙孙无穷匮也的情况，整棵树就会被退化为一条链，所以每次查找需要消耗O(n)的复杂度 既然我们只关心某一个结点的最远古祖先，那么我们仅需要存储每个结点的最远古祖先即可，优化写法可以使用一下记忆化搜索的技巧 int anc(int x){ if(dad[x] != x) return dad[x] = anc(dad[x]); else return x; } 所以我们可以对anc()函数进行这样的修改，此时每次操作的平均复杂度可以接近O(1) 并查集 这个数据结构就叫是并查集，并查集可以用来维护不相交集合 支持两种操作： 查询x和y是否在同一个集合 将x、y所在集合合并 ","link":"https://zzzcd0x.github.io/post/bing-cha-ji-dsu/"},{"title":"gcd lcm","content":"最大公因数(gcd) 性质： gcd(1,n) = 1 设d = gcd(a,b) 则 gcd(a/d,b/d) = 1 gcd(a,b) = gcd(a+-b,b) = gcd(a,b+-a) 辗转相除法求解： 由gcd(a,b) = gcd(a-b,b) 得 gcd(a,b) = gcd(a%b,b) 因此求解过程可写为： 如果a&lt;b,则交换a,b 如果b = 0，则返回a 令a = a%b 重复上述过程 int gcd(int a, int b) { if (a &lt; b) { int t = b; b = a; a = t; } if (b == 0) return a; return gcd(a % b, b); } 最小公倍数(lcm) lcm(a,b) = {ab\\over gcd(a,b)} 怎么求就不用说了吧 ","link":"https://zzzcd0x.github.io/post/gcd-lcm/"},{"title":"素数筛","content":"埃氏筛 主要过程 从2到n枚举，如果该数字没有标记(是素数) 枚举范围内的该数字的倍数，将枚举到的数字标记为素数 这样枚举结束后所有的合数就被打了标记，没打标记的就是素数 实现 以找100以内的素数为例 int n = 100; bool flag[105]; void sieve(){ for(int i = 2; i &lt;= n; i++) if(!flag[i]) { printf(&quot;%d &quot;,i); for(int j = 2; i*j &lt;= n; j++) flag[i*j] = true; } } 时间复杂度：O(n\\log(\\log(n))) 欧拉筛 埃氏筛中有一部分数被筛了不止一次，例如6被2筛完又被3筛 然而一个合数被标记只需要被其最小素因子筛就好了 这样的筛法就是欧拉筛，也叫线性筛 过程 i从2开始枚举，在枚举的过程中，记录当前已知的素数 枚举的每一步都去筛当前已知的所有的素数的i倍 当i能被枚举到的素数整除即已经筛到了当前情况下将要被筛的数的最小素因子则跳出循环应该被筛却没有被筛的数会在i更大的情况下被筛掉 实现 以找100以内的素数为例 int cnt; int n = 100; int prime[100]; bool flag[100]; void sieve(){ for(int i = 2; i &lt;= n; i++) { if(!flag[i]) { prime[++cnt] = i; printf(&quot;%d &quot;,i); } for(int j = 1; prime[j] * i &lt;= n &amp;&amp; j &lt;= cnt; j++) { flag[prime[j]*i] = true; if(i % prime[j] == 0) break; } } } 时间复杂度：O(n) 适合处理数据范围巨大的情况 ","link":"https://zzzcd0x.github.io/post/su-shu-shai/"},{"title":"链式前向星","content":"原理 链式前向星与邻接表类似，用一个数组存储了一个点可以到达的所有的点，区别是链式前向星使用链表将从每一个点出发的每一条边用链表的形式链在了一起，对边的存储方式是存储指向的顶点，边权，以及一下一条边的编号 怎么写呢 结构体写法 struct Edge{ int to; int val; int nxt; int from; }edge[10005]; int head[10005]; //每一个点的链表的头结点编号 int tot = 0; //用于存储每一个点的头结点 void add(int x,int y,int z){ edge[++tot].nxt = head[x]; head[x] = tot; edge[tot].to = y; edge[tot].from = x; edge[tot].val = z; } 数组写法 int tot; int to[MAXN]; int from[MAXN]; int head[MAXN]; int val[MAXN]; void add(int x,int y) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; from[tot] = x; } 遍历 与每一个点相连的边已经以链表的形式存储，头结点存储在head数组中，因此我们可以使用类似遍历链表的方式遍历与每一个点相连的每一条边 void search(){ for(int i = 1; i &lt;= n; i++) for(int j = head[i]; j ; j = edge[j].next) printf(&quot;%d %d %d\\n&quot;,edge[j].to,edge[j].val,edge[j].next); } ","link":"https://zzzcd0x.github.io/post/lian-shi-qian-xiang-xing/"},{"title":"拓扑排序","content":"什么是DAG 通俗来说DAG就是有向无环图的简称，通过名字就可以看出，DAG的基本特点是边为有向边，且图内无环 这个图虽然看似有环，但因为边都是有向边，所以并没有构成环。 观察一下上面那个图，不难发现以每一个结点为起点都可以找到对应的一条链，因此许多图论问题都可以抽象为找DAG中的最短链或者最长链。 然而在一些图论问题中结点之间存在先后关系，这样就不能直接用平常的遍历方式来对图进行遍历，而是需要先对结点按照先后顺序进行排序，转化为一个序列后再进行遍历 拓扑排序 上述过程应用的排序算法就是拓扑排序，排序后整张图就被转化成了一个序列，然后通过这个序列来解决问题 过程 在存图是记录每个结点的入度和出度 存图结束后将入度为0的点加入序列 那处序列头部的点x，遍历该点可以到达的所有点y 删掉x到y的边，即y点的入度减一 如果y点入度为0则加入序列 重复2~5直至序列为空 struct edge{ int to; int val; int next; }e[10005]; int n, m; int ind[10005]; //入度 int head[100005]; queue&lt;int&gt;q; void topsort(){ for(int i = 1; i &lt;= n; i++) //将入度为0的结点放入序列 if(!ind[i]) q.push(i); while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i; i = e[i].next) //遍历x能到达的点 { int y = e[i].to; ind[y]--; //删边 if(!ind[y]) //如果y点入度为0则放入序列 q.push(y); } } } ","link":"https://zzzcd0x.github.io/post/tuo-bu-pai-xu/"},{"title":"kruskal","content":"kruskal 是什么呢 是一种求一个图的最小生成树的算法，核心思想是贪心，其实就是个贪心，与prime相比更加适合求边比较稀疏的图的最小生成树 时间复杂度是O(mlogm) 运行过程 kruskal里面的边的作用可以理解为只是为了表达两个点的具有长度的连接关系 首先将所有的边按照边权从小到大排序 然后枚举每一条边，如果正在枚举的边的两个结点无联通关系，则将该边边权计入答案中、并用并查集标记两点的联通关系 当生成树联通后即可跳出循环 注意建边只要建单向即可 模板 struct Edge { int to; int val; int nxt; int from; }edge[MAXM]; int dad[MAXN]; bool judge(Edge x,Edge y) {return x.val &lt; y.val;} void kruskal() { for(int i = 1; i &lt;= n; i++) dad[i] = i; sort(edge+1,edge+n+1,judge); for(int i = 1; i &lt;= tot; i++) { int x = anc(edge[i].from); int y = anc(edge[i].to); if(x != y) { ans += edge[i].val; dad[x] = y; } } } 注意事项 真正的边权可能并不是输入的边权 ","link":"https://zzzcd0x.github.io/post/kruskal/"},{"title":"Floyd","content":"干什么的呢 大多用于求多源图中两点间的最短路，也可以用于传递闭包 写法 for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]); 时间复杂度 O(n3n^3n3) 正确性证明 Floyd算法核心思想是动态规划 原dp数组为 dp[k][i][j] 表示经过1~k号节点的情况下i到j的最短路 状态转移可以写成 dp[k][i][j] = dp[k-1][i][j] + dp[k-1][i][j] 但是k可以用滚动数组优化掉，来节约一大部分空间复杂度 最终的dp数组为 dp[i][j] 表示i~j的最短路 因为i到j经过1到k号节点的最短路是基于i到j经过1到k-1号节点的最短路计算的，所以k的枚举要放在最外层 细节 dp[0][i][j]表示初始权值，未连接的节点用INF表示 一般用Floyd时还要考虑边的权值 例题 传递闭包 题目链接 其实就是利用连通性可传递性来判断图中两个点之间是否连接 注意边为单向，但两个点之间连通是双向的 #include&lt;cstdio&gt; #include&lt;string.h&gt; using namespace std; const int MAXN = 105; const int MAXM = 4505; int ans; int n, m; bool dis[MAXN][MAXN]; void inp() { for(int i = 1; i &lt;= m; i++) { int x, y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); dis[x][y] = true; } } void floyd() { for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) dis[i][j] |= dis[i][k] &amp; dis[k][j]; } void judge() { int d[MAXN] = {0}; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if(dis[i][j] || dis[j][i]) d[i]++; for(int i = 1; i &lt;= n; i++) if(d[i] == n-1) ans++; } void init() { ans = 0; memset(dis,0,sizeof(dis)); } int main() { while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) { init(); inp(); floyd(); judge(); printf(&quot;%d\\n&quot;,ans); } return 0; } ","link":"https://zzzcd0x.github.io/post/floyd/"},{"title":"Dijkstra","content":"Dijkstra算法是一种用于解决无负权边的有向图的单源最短路问题的算法 大致思想 初始时将图的源点的最短路设为0 其他点最短路长度设为INF 将图中的点分为两类 一类是已经更新过最短路的点称为红点，另一类是未找到确定的最短路的点，称为蓝点 从源点开始更新能达到的点的最短路，将已经求出最短路的点放入队列 找出当前最短路最小的蓝点，将该点改为红点，再去更新这个点能达到的点的最短路 重复上述过程直到队列中没有点 正确性证明 首先源点能够到达的点的最短路一定是与源点相连的边的权值 可是为什么当前最短路最小的蓝点可以改为红点呢？ 用反证法证明 假设取出的蓝点为u 如果取出的蓝点还可以更新最短路，即还不能改为红点，那么能更新该点的最短路的点一定在队列后面，设该点为x 然而队是按最短路大小从小到大排序的 因此 d[u] &lt; d[x] ,d[x]+val_{x-&gt;u} &gt; d[u] 得证 朴素写法 链式前向星部分已省略 int d[1005]; bool b[1005]; void dijkstra(){ memset(d,0x3f,sizeof(d)); int inf = d[s]; d[s] = 0; for(int i = 1; i &lt;= n; i++) { int Min = inf; for(int j = 1; j &lt;= n; j++) if(!b[j]) if(Min == inf || d[j]&lt;d[Min]) Min = j; if(Min == inf) return ; b[Min] = true; for(int i = head[Min]; i ;i = edge[i].next) { int to = edge[i].to; int val = edge[i].val; if(!b[to]) d[to] = d[Min]+val; } } } 时间复杂度O(n2)O(n^2)O(n2) 堆优化 朴素写法最大的瓶颈是寻找当前路径最短的蓝点，这个过程可以用优先队列和堆优化 int d[1005]; bool b[1005]; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, greater&lt;pair&lt;int ,int&gt; &gt; &gt; q; void dijkstra(){ d[s] = 0; q.push(make_pair(0,s)); while(!q.empty()) { int x = q.top().second; q.pop(); if(b[x]) continue; b[x] = true; for(int i = head[x]; i ; i = edge[i].next) { int to = edge[i].to; int val = edge[i].val; if(d[to]&gt;d[x]+val) { d[to] = d[x]+val; if(!b[x]) q.push(make_pair(d[to],to)); } } } } 优化后时间复杂度可以降为 O(nlogn+m) 其实还有线段树优化 然后我不会😭 例题 二分+最短路 题目链接 题面中可以抽象出模型：二分枚举答案，在答案合法的情况下找出第K+1大的边 **为什么呢？**对于一个合法答案，可以将建设电话线的免费名额花费在前k大的边上，剩下的边中边权最大的一定是第k+1大的边。要求的是第k+1大值最小的情况所以不难想到二分(最大值最小)，跑最短路前我们可以将前k大的边标记为0，其他的边标记为1，这样最终从1到n的最短路长度即为需要连接的电话杆数量。 #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;utility&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int MAXN = 1e3+5; const int MAXP = 1e4+5; inline int read() { int x = 0; int k = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') { if(c == '-') k = -1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int tot; int n, p, k; int dis[MAXN]; bool vis[MAXN]; int head[MAXN]; ll val[MAXP&lt;&lt;1]; int to[MAXP&lt;&lt;1]; int nxt[MAXP&lt;&lt;1]; int flag[MAXP&lt;&lt;1]; void add(int x,int y, ll z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } bool dijkstra(ll mid) { memset(dis,0x3f,sizeof(dis)); memset(vis,false,sizeof(vis)); priority_queue&lt;pair&lt;int,int&gt; &gt; q; dis[1] = 0; q.push(make_pair(0,1)); while(!q.empty()) { int x = q.top().second; q.pop(); if(vis[x]) continue; vis[x] = true; for(int i = head[x]; i ; i = nxt[i]) { if(dis[to[i]] &gt; dis[x] + flag[i]) { dis[to[i]] = dis[x] + flag[i]; if(!vis[to[i]]) q.push(make_pair(-dis[to[i]],to[i])); } } } if(dis[n] &gt; k) return false; return true; } void inp() { n = read(); p = read(); k = read(); for(int i = 1; i &lt;= p; i++) { int x = read(); int y = read(); ll z = read(); add(x,y,z); add(y,x,z); } } int main() { inp(); int l = 0; int r = 1e6; ll ans = -1; while(l &lt;= r) { ll mid = (l+r)&gt;&gt;1; for(int i = 1; i &lt;= tot; i++) { if(val[i] &lt;= mid) flag[i] = 0; else flag[i] = 1; } if(dijkstra(mid)) { ans = mid; r = mid-1; } else l = mid+1; } printf(&quot;%lld\\n&quot;,ans); return 0; } 最短路径 题目链接 dijkstra求最短路时保存每一个结点最后一次被更新最短路的结点即可，最后倒序找出最短路径，然后用栈改为顺序。 #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;utility&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int MAX = 1e5+5; typedef long long ll; int n, m, s, t; inline int read() { int x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int tot; int path[MAX]; int head[MAX]; int to[MAX&lt;&lt;1]; int nxt[MAX&lt;&lt;1]; int val[MAX&lt;&lt;1]; int from[MAX&lt;&lt;1]; void add(int x,int y, ll z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; from[tot] = x; } void inp() { t = n; s = 1; for(int i = 1; i &lt;= m; i++) { int x = read(); int y = read(); ll z = (ll) read(); add(x,y,z); add(y,x,z); } } ll d[MAX]; bool vis[MAX]; void dijkstra() { priority_queue&lt;pair&lt;int,int&gt; &gt; q; memset(d,0x3f,sizeof(d)); memset(path,0,sizeof(path)); memset(vis,false,sizeof(vis)); d[s] = 0; q.push(make_pair(0,s)); while(!q.empty()) { int x = q.top().second; q.pop(); if(vis[x]) continue; vis[x] = true; for(int i = head[x]; i ; i = nxt[i]) { if(d[to[i]] &gt; d[x] + val[i]) { d[to[i]] = d[x] + val[i]; if(!vis[to[i]]) q.push(make_pair(-d[to[i]],to[i])); path[to[i]] = x; } } } } void oup() { int t = n; stack&lt;int&gt; temp; bool flag = false; while(t) { temp.push(t); t = path[t]; if(t == 1) flag = true; } if(flag) while(!temp.empty()) { printf(&quot;%d &quot;,temp.top()); temp.pop(); } else printf(&quot;-1&quot;); puts(&quot;&quot;); } int main() { while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) { inp(); dijkstra(); oup(); } return 0; } ","link":"https://zzzcd0x.github.io/post/dijkstra/"},{"title":"树状数组","content":" 树状数组是什么 设树状数组为C，x的二进制表达形式末尾有k个0，则C[x]表示区间A[x−2k+1x-2^k+1x−2k+1,xxx]的和 使位运算lowbit(x) = x&amp;-x可求出2k2^k2k的值 大致原理 假设x=6 6用二进制表示位110 -6是求6的补码，即反码+1，位010 110&amp;010即为最低位1的位置 概念想不明白可以看一下这张图 信息可减的情况下，可以差分: 单点加，区间查询 查询区间[l,r]可差分为前r个数的和减去前l-1个数的和 区间加，单点查询 把区间[l,r]加差分为前缀r加，前缀l-1减，查询单点只需要查询包含这个点的所有前缀修改 区间加，区间查询 查询[l,r]只要用前r个数减去前l-1个数的和即可 基本写法 构建 构建方法因题而异 查询x的前缀和 根据定义可得，C[x]存的是A[x-2^k+1,x]的和，因此只需要x-lowbit(x)并且加上C[x]的值就可以得到x的前缀和，直到减到0 int aks(int x){ int ans = 0; for(int i = x; i ; i-=lowbit(i)) ans+=c[i]; } 修改 再根据定义，更改A[x]的值，需要改变C中x+lowbit(x)直到大于n的值，迭代解决即可 第x位的数加k的写法 void modify(int x,int k){ for(int i = x; i &lt;= n; i+=lowbit(i)) c[i]+=k; } ","link":"https://zzzcd0x.github.io/post/shu-zhuang-shu-zu/"},{"title":"线段树","content":"组成 1号结点为根结点，存储原数组区间1到6的数的和 左儿子下标为2，求法为1&gt;&gt;1,存储[1,3]的和 右儿子下标为3，求法为1&gt;&gt;1|1,存储[4,6]的和 这里3和4时区间中点和中点+1 用二进制运算比较快，处理大量数据时常数可以低一点 其实线段树能维护的东西远不止和，还可以维护区间最大值、最小值、最大子段和等等 怎么维护呢 先从建树开始 从根节点开始递归建树 开四倍空间 1.数组写法 int a[1005]; //原数组 int t[4005]; //线段树 void build(int now,int l,int r){ if(l == r) { t[now] = a[l]; return; } int mid = (l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); pushup(now); //回溯的时候更新父亲节点 } 2.结构体写法 struct Node{ int l,r; int sum; }node[4005]; void build(int now,int l,int r){ node[now].l = l; node[now].r = r; if(l == r) { node[now].sum = a[l]; return; } int mid = (l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); pushup(now); } 好像结构体写法更容易维护 区间查询 当前查找到的区间被包含在需要查找的区间内则直接返回 否则通过中点判断要查找到区间和左右子树哪个有交集 如果都有则将两边的查找结果进行相应的处理后返回 思想类似二分查找 int find(int now,int L,int R){ int l = node[now].l; int r = node[now].r; if(L &lt;= l &amp;&amp; R &gt;= r) return node[now].sum; int mid = (l+r)&gt;&gt;1; if(mid &gt;= R) return find(now&lt;&lt;1,L,R); else if(mid &lt; l) return find(now&lt;&lt;1|1,L,R); else { int tot = 0; tot += find(now&lt;&lt;1,L,R); tot += find(now&lt;&lt;1|1,L,R); return tot; } } 区间修改 大体步骤和区间查询类似 标记下放: 如果每次修改都去相应的修改涉及到的所有的结点的话会产生较大的复杂度，因此考虑使用标记下放的方法，即当该结点被访问到的时候再将标记下放，使子树得到正确的信息。所以区间修改只更新到需要修改的区间的真子集即可，但在此之前每一个访问到的结点都要进行标记下放，不然需要更新的区间得不到正确的更新信息 int tag[40005]; void pushdown(int now){ if(tag[now]) { tag[now&lt;&lt;1] += tag[now]; tag[now&lt;&lt;1|1] += tag[now]; node[now&lt;&lt;1].sum += tag[now]*(node[now&lt;&lt;1].r-node[now&lt;&lt;1]+1); node[now&lt;&lt;1|1].sum += tag[now]*(node[now&lt;&lt;1|1].r-node[now&lt;&lt;1|1]+1); tag[now] = 0; } } void modify(int now,int L,int R,int k){ int l = node[now].l; int r = node[now].r; if(L &lt;= l &amp;&amp; R &gt;= r) { tag[now] += k; node[now].sum += k*(r-l+1); } pushdown(now); int mid = (l+r)&gt;&gt;1; if(mid &gt;= L) modify(now&lt;&lt;1,L,R,k); if(R &gt; mid) modify(now&lt;&lt;1|1,L,R,k); pushup(now); } pushup的作用是当某一个结点的子树的值被修改了则去用修改后的子树的信息去更新当前结点的信息 void pushup(int now){ node[now].sum = node[now&lt;&lt;1].sum + ndoe[now&lt;&lt;1|1].sum; } 单点修改 void modifyP(int now,int to,int k){ int l = node[now].l; int r = node[now].r; if(l == r) { a[now] += k; t[now] += k; return; } int mid = (l+r)&gt;&gt;1; if(mid &gt;= to) modifyP(now&lt;&lt;1,to,k); else modifyP(now&lt;&lt;1|1,to,k); pushup(now); } 维护最大子段和 什么是最大子段和？ 其实就是当前线段树区间内，一个任意的连续的序列的和的最大值 其他会用到的概念: 最大左子段和:从区间左端点开始的最大子段和 最大右子段和:从区间右端点开始的最大子段和 pushup 最大左子段和可能是左子树的最大左子段和也可能是左子树的区间总和加右子树的最大左子段和，最大右子段和同理 最大子段和可能是左子树的最大子段和或右子树的最大子段和或左子树的最大右子段和+右子树的最大左子段和 void pushup(int now){ node[now].sum = node[now&lt;&lt;1].sum + node[now&lt;&lt;1|1].sum; ndoe[now].Max = max(max(node[now&lt;&lt;1].Max,node[now&lt;&lt;1|1].Max),node[now&lt;&lt;1].rm+node[now&lt;&lt;1|1].lm); node[now].lm = max(node[now&lt;&lt;1].lm,node[now&lt;&lt;1].sum+node[now&lt;&lt;1|1].lm); node[now].rm = max(node[now&lt;&lt;1|1].rm,node[now&lt;&lt;1].rm+node[now&lt;&lt;1|1].sum); } 建树 void build(int now,int l,int r){ node[now].l = l; ndoe[now].r = r; if(l == r) { node[now].sum = a[l]; node[now].lm = a[l]; node[now].rm = a[l]; node[now].Max = a[l]; return; } int mid = (l+r)&gt;&gt;1; builde(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); pushup(now); } 区间修改 直接更改线段树上某个点的值 void modify(int now,int to,int k){ int l = node[now].l; int r = node[now].r; if(l == r) { node[now].sum = k; node[now].Max = k; node[now].lm = k; node[now].rm = k; return; } int mid = (l+r)&gt;&gt;1; if(to &lt;= mid) modify(now&lt;&lt;1,to,k); else modify(now&lt;&lt;1|1,to,k); pushup(now); } 区间查找 Node ask(int now,int L,int R){ int l = node[now].l; int r = ndoe[now].r; if(L &lt;= l &amp;&amp; R &gt;= r) return node[now]; int mid = (l+r)&gt;&gt;1; if(mid &gt;= R) return ask(now&lt;&lt;1,L,R); else if(mid&lt;L) return ask(now&lt;&lt;1|1,L,R); else{ Node ans; Node left = ask(now&lt;&lt;1,L,R); Node right = ask(now&lt;&lt;1|1,L,R); ans.sum = left.sum + right.sum; ans.lm = max(left.lm,left.sum+right.lm); ans.rm = max(right.rm,right.sum+left.rm); ans.Max = max(left.rm+right.lm,max(left.Max,right.Max)); return ans; } } 例题 最大子段和 题目链接 #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,m; int a[500005]; struct Node{ int l,r; int sum; int Max; int lm,rm; }node[2000005]; void pushup(int now){ node[now].sum = node[now&lt;&lt;1].sum+node[now&lt;&lt;1|1].sum; node[now].lm = max(node[now&lt;&lt;1].lm,node[now&lt;&lt;1].sum+node[now&lt;&lt;1|1].lm); node[now].rm = max(node[now&lt;&lt;1|1].rm,node[now&lt;&lt;1|1].sum+node[now&lt;&lt;1].rm); node[now].Max = max(max(node[now&lt;&lt;1].Max,node[now&lt;&lt;1|1].Max),node[now&lt;&lt;1].rm+node[now&lt;&lt;1|1].lm); } void build(int now,int l,int r){ node[now].l = l; node[now].r = r; if(l == r) { node[now].sum = a[l]; node[now].lm = a[l]; node[now].rm = a[l]; node[now].Max = a[l]; return; } int mid = (l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); pushup(now); } void modify(int now,int to,int k){ int l = node[now].l; int r = node[now].r; if(l == r) { // a[now] = k; node[now].sum = k; node[now].Max = k; node[now].lm = k; node[now].rm = k; return; } int mid = (l+r)&gt;&gt;1; if(to &lt;= mid) modify(now&lt;&lt;1,to,k); else modify(now&lt;&lt;1|1,to,k); pushup(now); } Node ask(int now,int L,int R){ int l = node[now].l; int r = node[now].r; if(L &lt;= l &amp;&amp; R &gt;= r) return node[now]; int mid = (l+r)&gt;&gt;1; if(mid &gt;= R) return ask(now&lt;&lt;1,L,R); else if(mid &lt; L) return ask(now&lt;&lt;1|1,L,R); else { Node ans; Node left = ask(now&lt;&lt;1,L,R); Node right = ask(now&lt;&lt;1|1,L,R); ans.sum = left.sum + right.sum; ans.lm = max(left.lm,left.sum+right.lm); ans.rm = max(right.rm,right.sum+left.rm); ans.Max = max(left.rm+right.lm,max(left.Max,right.Max)); return ans; } } int main(){ int k,x,y; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;,&amp;a[i]); build(1,1,n); for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d %d %d&quot;,&amp;k,&amp;x,&amp;y); if(k == 1) { if(x &gt; y) { int t = x; x = y; y = t; } Node ans = ask(1,x,y); printf(&quot;%d\\n&quot;,ans.Max); } if(k == 2) modify(1,x,y); } return 0; } 线段树+状压 题目链接 本题是给一个木板的不同区间染色，一共有30种颜色，可以考虑用一个二进制数字来储存该区间内的数被染了哪一种颜色，线段树中第i个结点存储的数字的二进制第j位为1，则该结点被染成了颜色j，若为0则没有染成颜色j，区间颜色个数统计使用按位与运算，将最终结果进行二进制拆分统计为1的个数即可。 #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int MAXN = 1e5+5; int n,t,o; int le[MAXN&lt;&lt;2]; int ri[MAXN&lt;&lt;2]; int tag[MAXN&lt;&lt;2]; int color[MAXN&lt;&lt;2]; inline int read() { int x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int ls(int p) {return p&lt;&lt;1;} int rs(int p) {return p&lt;&lt;1|1;} void pushup(int p) {color[p] = color[ls(p)] | color[rs(p)];} void upd(int p,int v) { color[p] = v; tag[p] = v; } void pushdown(int p) { if(tag[p]) { upd(ls(p),tag[p]); upd(rs(p),tag[p]); tag[p] = 0; } } void build(int now,int l,int r) { le[now] = l; ri[now] = r; color[now] = 0; tag[now] = 0; if(l == r) { color[now] = 1; return; } int mid = (l+r)&gt;&gt;1; build(ls(now),l,mid); build(rs(now),mid+1,r); pushup(now); } void modify(int now,int l,int r,int v) { int L = le[now]; int R = ri[now]; if(r &lt; L || l &gt; R) return; if(l &lt;= L &amp;&amp; r &gt;= R) { tag[now] = 1&lt;&lt;(v-1); color[now] = 1&lt;&lt;(v-1); return; } pushdown(now); int mid = (L+R)&gt;&gt;1; if(l &lt;= mid) modify(ls(now),l,r,v); if(r &gt; mid) modify(rs(now),l,r,v); pushup(now); } int query(int now,int l,int r) { int L = le[now]; int R = ri[now]; if(r &lt; L || l &gt; R) return 0; if(l &lt;= L &amp;&amp; r &gt;= R) { return color[now]; } int ans = 0; int mid = (L+R)&gt;&gt;1; pushdown(now); if(l &lt;= mid) ans |= query(ls(now),l,r); if(r &gt; mid) ans |= query(rs(now),l,r); return ans; } int main() { while(~scanf(&quot;%d %d %d&quot;,&amp;n,&amp;t,&amp;o)) { int x, y, z; char c[2]; build(1,1,n); while(o--) { scanf(&quot;%s&quot;,c); if(c[0] == 'C') { scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); if(x &gt; y) swap(x,y); modify(1,x,y,z); } else if(c[0] == 'P') { scanf(&quot;%d %d&quot;,&amp;x,&amp;y); if(x &gt; y) swap(x,y); int cnt = 0; int tot = query(1,x,y); while(tot) { if(tot&amp;1) cnt++; tot &gt;&gt;= 1; } printf(&quot;%d\\n&quot;,cnt); } } } return 0; } ","link":"https://zzzcd0x.github.io/post/SegmentTree/"}]}