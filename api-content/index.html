{"posts":[{"title":"ç½‘ç»œæµåˆæ­¥","content":"ç›¸å…³å®šä¹‰ ç½‘ç»œæµå›¾ æ˜¯ä¸€ä¸ªæ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„ DAG åªæœ‰ä¸€ä¸ªå…¥åº¦ä¸º0çš„ç‚¹ï¼Œç§°ä¸ºæºç‚¹ã€‚ åªæœ‰ä¸€ä¸ªå‡ºåº¦ä¸º0çš„ç‚¹ï¼Œç§°ä¸ºæ±‡ç‚¹ã€‚ æ¯æ¡è¾¹éƒ½æœ‰ä¸€ä¸ªéè´Ÿæƒå€¼ï¼Œç§°ä¸ºè¿™æ¡è¾¹çš„å®¹é‡ã€‚ å®¹è®¸æµ ç½‘ç»œæµå›¾ä¸­ï¼Œå¯¹äºæ¯æ¡è¾¹e=(i,j)e=(i,j)e=(i,j)ï¼Œç»™å®šå®æ•°fef_efeâ€‹,å¦‚æœæ»¡è¶³feâ‰¤Cef_e \\leq C_efeâ€‹â‰¤Ceâ€‹ï¼Œåˆ™æœ‰ä»¥ä¸‹æ€§è´¨ å¯¹äºä»»æ„ xâ‰ S,Tx \\neq S,Txî€ â€‹=S,T,âˆ‘e=(x,i)fe=âˆ‘e=(i,x)fe\\sum{_{e=(x,i)}f_e} = \\sum{_{e=(i,x)}f_e}âˆ‘e=(x,i)â€‹feâ€‹=âˆ‘e=(i,x)â€‹feâ€‹ W=âˆ‘e=(S,i)fe=âˆ‘e=(i,x)feW = \\sum{{e=(S,i)}f_e} = \\sum{{e=(i,x)}f_e}W=âˆ‘e=(S,i)feâ€‹=âˆ‘e=(i,x)feâ€‹ åˆ™è¿™ä¸€ç»„fffç§°ä¸ºè¯¥ç½‘ç»œçš„ä¸€ä¸ªæµé‡ä¸ºWWWçš„å®¹è®¸æµã€‚ å¢å¹¿è·¯ ä»æºç‚¹å¼€å§‹åˆ°è¾¾æ±‡ç‚¹çš„ä¸€æ¡è·¯å¾„ä¸­ï¼Œæ¯ä¸€æ®µéƒ½æ»¡è¶³æµé‡å°äºå®¹é‡ï¼Œè®¾è¿™æ¡è·¯ä¸Šæ¯ä¸€æ®µçš„å®¹é‡å‡æµé‡çš„å€¼çš„æœ€å°å€¼ä¸ºÎ”\\DeltaÎ” ã€‚ å°†è¿™æ¡è·¯ä¸Šçš„æ¯ä¸€æ®µçš„æµé‡åŠ ä¸Š Î”\\DeltaÎ” åä¿è¯è¿™æ¡è·¯ä¾ç„¶å¯è¡Œï¼Œåˆ™è¯¥è·¯å¾„ç§°ä¸ºè¿™ä¸ªç½‘ç»œçš„ä¸€æ¡å¢å¹¿è·¯ã€‚ ç®€è€Œè¨€ä¹‹ï¼Œå°±æ˜¯ä¸€æ¡ä»æºç‚¹åˆ°æ±‡ç‚¹çš„è·¯å¾„ä¸Šçš„å„è¾¹çš„å‰©ä½™å®¹é‡éƒ½å¤§äº0çš„è·¯å¾„ã€‚ æ®‹é‡ç½‘ç»œ ä»»æ„æ—¶åˆ»ï¼Œç½‘ç»œæµå›¾ä¸­æ‰€æœ‰èŠ‚ç‚¹åŠå…¶å‰©ä½™å®¹é‡å¤§äº0çš„è¾¹æ„æˆçš„å­å›¾ã€‚ å‰² ä¸€å¼ å›¾ä¸­ï¼Œå»æ‰å›¾ä¸­çš„å‡ æ¡è¾¹åï¼Œå¯ä»¥å°†è¯¥å›¾åˆ†å‰²ä¸ºä¸¤ä¸ªä¸ç›¸äº¤çš„ç‚¹é›†ï¼Œåˆ™å»æ‰çš„è¿™äº›è¾¹ç§°ä¸ºè¿™å¼ å›¾çš„ä¸€ä¸ªå‰²ã€‚ å¯¹äºä¸€æ¡æœ‰å‘è¾¹ VVV ï¼Œé€šå¸¸ç§°ä»–çš„åå‘è¾¹ä¸º VË‰\\bar{V}VË‰ ã€‚ æœ€å¤§æµ å¯¹äºä¸€ä¸ªç»™å®šçš„ç½‘ç»œï¼Œåˆæ³•çš„æµå‡½æ•°ä¸­ä½¿å¾—æ•´ä¸ªç½‘ç»œçš„æµé‡æœ€å¤§çš„ä¸€ä¸ªç§°ä¸ºè¯¥ç½‘ç»œçš„æœ€å¤§æµï¼Œæ­¤æ—¶çš„æµé‡æ˜¯è¯¥ç½‘ç»œçš„æœ€å¤§æµé‡ã€‚ EKç®—æ³• EKç®—æ³•çš„æ€æƒ³æ˜¯åœ¨ç½‘ç»œæµå›¾ä¸­ä¸æ–­bfsæœç´¢å¢å¹¿è·¯ï¼Œç›´åˆ°å›¾ä¸­ä¸å­˜åœ¨å¢å¹¿è·¯ã€‚ ä¹Ÿå¯ä»¥ç†è§£ä¸ºåœ¨ç½‘ç»œæµå›¾ä¸­å¯»æ‰¾ä»Såˆ°Vè¾¹æ•°æœ€çŸ­çš„å¢å¹¿è·¯è¿›è¡Œå¢å¹¿ï¼Œç›´åˆ°æ— æ³•ç»§ç»­å¢å¹¿ã€‚ æœç´¢çš„è¿‡ç¨‹ä¸­åªè€ƒè™‘å›¾ä¸­æµé‡å°äºå®¹é‡çš„è¾¹ï¼Œbfsæ‰¾åˆ°ä»»æ„ä¸€æ¡å¢å¹¿è·¯ï¼ŒåŒæ—¶è®¡ç®—å‡ºè·¯å¾„ä¸Šå„è¾¹å‰©ä½™å®¹é‡çš„æœ€å°å€¼ minfminfminf ï¼Œæ•´ä¸ªç½‘ç»œçš„æµé‡å¯ä»¥å¢åŠ  minfminfminfã€‚ å¼•ç†1 ä»¤fif_ifiâ€‹ä¸ºå¢å¹¿iiiæ¬¡åå¾—åˆ°çš„ä¸€ä¸ªå®¹è®¸æµï¼ŒÎ»k(u,v){\\lambda}^{k}(u,v)Î»k(u,v)è¡¨ç¤ºfkf_kfkâ€‹ä¸­uuuåˆ°vvvçš„ä¸€æ¡æœ€çŸ­è·¯é•¿åº¦ï¼Œåˆ™ Î»k(S,v)â‰¤Î»k+1(S,v)ï¼ŒÎ»k(v,T)â‰¤Î»k+1(v,T){\\lambda}^{k}(S,v) \\leq {\\lambda}^{k+1}(S,v)ï¼Œ{\\lambda}^{k}(v,T) \\leq {\\lambda}^{k+1}(v,T) Î»k(S,v)â‰¤Î»k+1(S,v)ï¼ŒÎ»k(v,T)â‰¤Î»k+1(v,T) å‡è®¾fk+1f_{k+1}fk+1â€‹ä¸­ä»Såˆ°vçš„æœ€çŸ­è·¯ä¸ºSåˆ° u0,u1...upâˆ’1,up=vu_0,u_1...u_{p-1},u_p = vu0â€‹,u1â€‹...upâˆ’1â€‹,upâ€‹=vã€‚ è®¾ ei=(uiâˆ’1,ui)e_i = (u_{i-1},u_i)eiâ€‹=(uiâˆ’1â€‹,uiâ€‹) ã€‚ è‹¥ eie_ieiâ€‹ åœ¨ fkf_kfkâ€‹ ä¸­å¯ç”¨ï¼Œåˆ™ Î»k(S,v)â‰¤Î»k+1(S,v){\\lambda}^{k}(S,v) \\leq {\\lambda}^{k+1}(S,v)Î»k(S,v)â‰¤Î»k+1(S,v) ã€‚ è‹¥ eie_ieiâ€‹ åœ¨ fkf_kfkâ€‹ ä¸­ä¸å¯ç”¨ï¼Œåˆ™ä»–çš„ç›¸åè·¯å¾„ä¸€å®šå¯ç”¨ï¼Œä¸”åœ¨ S åˆ° uiâˆ’1u_{i-1}uiâˆ’1â€‹ çš„æœ€çŸ­è·¯ä¸Šï¼Œä¸” Î»k(S,uiâˆ’1)=Î»k(S,ui)+1{\\lambda}^{k}(S,u_{i-1}) = {\\lambda}^k(S,u_i)+1Î»k(S,uiâˆ’1â€‹)=Î»k(S,uiâ€‹)+1 ã€‚å› ä¸ºå½“ eie_ieiâ€‹ ä¸å¯ç”¨æƒ…å†µä¸‹ï¼Œeie_ieiâ€‹ å¿…ç„¶åœ¨ä¹‹å‰çš„å¢å¹¿ä¸­è¢«å¢å¹¿è¿‡äº†ï¼Œå³ eie_ieiâ€‹ åœ¨ä» S åˆ° uiu_iuiâ€‹ çš„æœ€çŸ­è·¯ä¸Šï¼Œæ‰€ä»¥æ­¤æ—¶ S åˆ° uiâˆ’1u_{i-1}uiâˆ’1â€‹ çš„æœ€çŸ­è·¯ä¸Šä¸€å®šæœ‰ eie_ieiâ€‹ çš„åå‘è¾¹ï¼Œå¦åˆ™ eie_ieiâ€‹ ä¸ä¼šä¸å¯ç”¨ã€‚ å¼•ç†2 è®¾è¾¹ eie_ieiâ€‹ åœ¨ fkf_kfkâ€‹ åˆ° fk+1f_{k+1}fk+1â€‹ çš„å¢å¹¿è·¯ä¸­ï¼Œåˆ™ eie_ieiâ€‹ çš„åå‘è·¯å¾„åœ¨ fif_ifiâ€‹ åˆ° fi+1f_{i+1}fi+1â€‹ çš„å¢å¹¿è·¯ä¸­ (k&lt;i)(k&lt;i)(k&lt;i) ï¼Œåˆ™ Î»i(S,T)â‰¥Î»k(S,T)+2{\\lambda}^i(S,T) \\geq {\\lambda}^k(S,T)+2 Î»i(S,T)â‰¥Î»k(S,T)+2 å‡è®¾ e=(u,v)e = (u,v)e=(u,v)ï¼Œåˆ™ Î»k(S,v)=Î»k(S,u)+1{\\lambda}^k(S,v) = {\\lambda}^k(S,u)+1 Î»k(S,v)=Î»k(S,u)+1 Î»i(S,T)=Î»i(S,v)+1+Î»i(u,T){\\lambda}^i(S,T) = {\\lambda}^i(S,v)+1+{\\lambda}^i(u,T) Î»i(S,T)=Î»i(S,v)+1+Î»i(u,T) ç”±å¼•ç†1å¾— Î»i(S,T)â‰¥Î»k(S,v)+1+Î»k(u,T)=Î»k(S,u)+2+Î»k(u,T)=Î»k(S,T)+2{\\lambda}^i(S,T) \\geq {\\lambda}^k(S,v)+1+{\\lambda}^k(u,T) = {\\lambda}^k(S,u)+2+{\\lambda}^k(u,T) = {\\lambda}^k(S,T)+2 Î»i(S,T)â‰¥Î»k(S,v)+1+Î»k(u,T)=Î»k(S,u)+2+Î»k(u,T)=Î»k(S,T)+2 æ¯æ¡è¾¹æœ€å¤šç§°ä¸º n+22\\frac{n+2}{2}2n+2â€‹ æ¬¡ç“¶é¢ˆï¼Œæ‰€ä»¥æœ€å¤šæœ‰ m(n+2)2\\frac{m(n+2)}{2}2m(n+2)â€‹ æ¡å¢å¹¿è·¯ã€‚ EKç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(nm2)O(nm^2)O(nm2)ã€‚ æ¨¡æ¿ const int INF = 1&lt;&lt;29; const int MAXN = 1e5+5; int Max; int tot = 1; int n, m, s, t; bool v[MAXN]; int head[MAXN]; int incf[MAXN]; int to[MAXN&lt;&lt;1]; int pre[MAXN&lt;&lt;1]; int val[MAXN&lt;&lt;1]; int nxt[MAXN&lt;&lt;1]; void add(int x,int y,int z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } bool bfs() { memset(v,0,sizeof(v)); queue&lt;int&gt; q; q.push(s); v[s] = true; incf[s] = INF; while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i; i = nxt[i]) { if(val[i]) { int y = to[i]; if(v[y]) continue; incf[y] = min(incf[x],val[i]); pre[y] = i; q.push(y); v[y] = true; if(y == t) return true; } } } return false; } void upd() { int x = t; while(x != s) { int i = pre[x]; val[i] -= incf[t]; val[i^1] += incf[t]; //åå‘è¾¹ x = to[i^1]; } Max += incf[t]; } void inp() { Max = 0; tot = 1; scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); for(int i = 1; i &lt;= m; i++) { int x,y,z; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,0); } } Dinicç®—æ³• EKç®—æ³•æ¯æ¬¡æœç´¢å¯èƒ½ä¼šéå†æ•´ä¸ªæ®‹é‡ç½‘ç»œä½†åªæ±‚å‡ºä¸€æ¡å¢å¹¿è·¯ï¼Œå®é™…ä¸Šå¯ä»¥ä¸€æ¬¡æ±‚å‡ºå¤šæ¡æ»¡è¶³æ¡ä»¶çš„å¢å¹¿è·¯è¿›è¡Œå¢å¹¿ã€‚ Dinicç®—æ³•ä¸æ–­é‡å¤ä¸€ä¸‹æ­¥éª¤ï¼Œç›´åˆ°æ®‹é‡ç½‘ç»œä¸­Sä¸èƒ½åˆ°è¾¾Tã€‚ åœ¨æ¯æ¬¡å¢å¹¿æ—¶ï¼Œåœ¨æ®‹é‡ç½‘ç»œä¸Šbfsæ±‚å‡ºæ¯ä¸ªèŠ‚ç‚¹çš„å±‚æ¬¡ï¼Œæ„é€ åˆ†å±‚å›¾ã€‚ åœ¨åˆ†å±‚å›¾ä¸­dfså¯»æ‰¾å¢å¹¿è·¯ï¼Œåœ¨å›æº¯æ—¶å®æ—¶æ›´æ–°å‰©ä½™å®¹é‡ã€‚ å½“å‰å¼§ä¼˜åŒ– dfsçš„è¿‡ç¨‹ä¸­ï¼Œç»´æŠ¤æ¯ä¸€ä¸ªç‚¹å¯èƒ½ç”¨äºå¢å¹¿çš„ç¬¬ä¸€æ¡è¾¹ï¼Œæ¯æ¬¡æœç´¢æ—¶èˆå¼ƒæ‰ä¸èƒ½ç»§ç»­å¢å¹¿çš„è¾¹ã€‚ Dinicç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º O(n2m)O(n^2m)O(n2m)ã€‚ æ¨¡æ¿ typedef long long ll; const int MAXN = 205; const int MAXM = 5e3+5; const ll INF = 0x7f7f7f7f; int tot = 1; int n, m, s, t; ll dis[MAXN]; int gap[MAXN]; int head[MAXN]; int to[MAXM&lt;&lt;1]; ll val[MAXM&lt;&lt;1]; int nxt[MAXM&lt;&lt;1]; void add(int x,int y,ll z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } bool bfs() { for(int i = 1; i &lt;= n; i++) dis[i] = INF; queue&lt;int&gt; q; q.push(s); dis[s] = 0; gap[s] = head[s]; while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i ; i = nxt[i]) { if(val[i] &gt; 0 &amp;&amp; dis[to[i]] == INF) { q.push(to[i]); gap[to[i]] = head[to[i]]; dis[to[i]] = dis[x] + 1; if(to[i] == t) return true; } } } return false; } ll dinic(int now,ll flow) { if(now == t) return flow; ll k, res = 0; for(int i = gap[now] ; i &amp;&amp; flow ; i = nxt[i]) { gap[now] = i; if(val[i] &gt; 0 &amp;&amp; dis[to[i]] == dis[now] + 1) { k = dinic(to[i],min(flow,val[i])); if(!k) dis[to[i]] = INF; val[i] -= k; val[i^1] += k; res += k; flow -= k; } } return res; } void inp() { scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); for(int i = 1; i &lt;= m; i++) { int x, y; ll z; scanf(&quot;%d %d %lld&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,0); } } æœ€å¤§æµæœ€å°å‰²å®šç† è®¾ V æ˜¯ç½‘ç»œæµå›¾çš„ä¸€ä¸ªç»“ç‚¹é›†ï¼Œæ»¡è¶³ SâˆˆV,TâˆˆVS\\in V,T\\in VSâˆˆV,TâˆˆVï¼Œåˆ™å…¨éƒ¨æœ‰å‘è¾¹ (iï¼Œj),iâˆˆS,jâˆˆSË‰(iï¼Œj),i\\in S,j\\in\\bar{S}(iï¼Œj),iâˆˆS,jâˆˆSË‰ çš„é›†åˆç§°ä¸ºåŸç½‘ç»œæµå›¾çš„ä¸€ä¸ªå‰²ï¼Œè®°ä¸º (V,VË‰)(V,\\bar{V})(V,VË‰)ï¼Œé›†åˆä¸­æ‰€æœ‰è¾¹çš„å®¹é‡ä¹‹å’Œç§°ä¸ºè¯¥å‰²çš„å®¹é‡ã€‚ å®¹é‡æœ€å°çš„å‰²ç§°ä¸ºåŸç½‘ç»œæµå›¾çš„æœ€å°å‰²ã€‚ ä¸€ä¸ªç½‘ç»œæµå›¾çš„æœ€å¤§æµå®¹é‡ = æœ€å°å‰²å®¹é‡ã€‚ è´¹ç”¨æµ ç»™å®šä¸€ä¸ªç½‘ç»œï¼Œå¯¹äºæ¯æ¡è¾¹é™¤äº†æœ‰å®¹é‡é™åˆ¶ï¼Œè¿˜æœ‰ä¸€ä¸ªç»™å®šçš„å•ä½è´¹ç”¨ï¼Œå³å‡è®¾ä¸€æ¡è¾¹çš„å•ä½è´¹ç”¨ä¸º xxx ï¼Œåˆ™è¿™æ¡è¾¹æµé‡ä¸º yyy æ—¶ï¼Œéœ€è¦èŠ±è´¹ xâˆ—yx*yxâˆ—y çš„è´¹ç”¨ã€‚ è´¹ç”¨æµé—®é¢˜çš„å‰ææ˜¯æœ€å¤§æµï¼Œå¤§å¤šæ•°è´¹ç”¨æµé—®é¢˜éƒ½å¯ä»¥æŠ½è±¡ä¸ºæœ€å°è´¹ç”¨æœ€å¤§æµæˆ–æœ€å¤§è´¹ç”¨æœ€å°æµé—®é¢˜ã€‚ EKç®—æ³• å¯¹äºEKç®—æ³•ï¼Œå°†æ¯æ¬¡å¯»æ‰¾è·¯å¾„æœ€å°‘çš„æœ€çŸ­è·¯æ”¹ä¸ºå¯»æ‰¾è´¹ç”¨å’Œæœ€å°çš„æœ€çŸ­è·¯å³å¯ã€‚ è¿™æ—¶è¦ç”¨åˆ°å•æºæœ€çŸ­è·¯ç®—æ³•ï¼Œç”±äºå¯èƒ½å‡ºç°è´Ÿæƒè¾¹ï¼Œå› æ­¤é€‰æ‹©ä½¿ç”¨SPFAè€Œä¸æ˜¯Dijkstra~~ï¼ˆè¯ˆå°¸å•¦ï¼ï¼‰~~ æ¨¡æ¿ #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int MAXN = 5e5+5; const int MAXM = 5e4+5; const int INF = 0x3f3f3f3f; int tot = 1; ll Max_cost; ll Max_flow; int n, m, s, t; bool v[MAXN]; ll dis[MAXN]; ll incf[MAXN]; int head[MAXN]; int to[MAXM&lt;&lt;1]; ll val[MAXM&lt;&lt;1]; int nxt[MAXM&lt;&lt;1]; ll cost[MAXM&lt;&lt;1]; int pre[MAXM&lt;&lt;1]; void add(int x,int y,ll z,ll h) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; cost[tot] = h; } bool bfs() { for(int i = 1; i &lt;= n; i++) { v[i] = false; dis[i] = INF; } queue&lt;int&gt; q; q.push(s); v[s] = true; dis[s] = 0; incf[s] = INF; bool jud = false; while(!q.empty()) { int x = q.front(); q.pop(); v[x] = false; for(int i = head[x]; i; i = nxt[i]) { int y = to[i]; if(val[i] &amp;&amp; dis[y] &gt; dis[x] + cost[i]) { pre[y] = i; dis[y] = dis[x] + cost[i]; incf[y] = min(incf[x],val[i]); if(!v[y]) { q.push(y); v[y] = true; } if(y == t) jud = true; } } } return jud; } void upd() { int x = t; while(x != s) { int i = pre[x]; val[i] -= incf[t]; val[i^1] += incf[t]; x = to[i^1]; } Max_flow += incf[t]; Max_cost += incf[t]*dis[t]; } void inp() { Max_flow = 0; tot = 1; scanf(&quot;%d %d %d %d&quot;,&amp;n,&amp;m,&amp;s,&amp;t); for(int i = 1; i &lt;= m; i++) { int x,y; ll z,h; scanf(&quot;%d %d %lld %lld&quot;,&amp;x,&amp;y,&amp;z,&amp;h); add(x,y,z,h); add(y,x,0,-h); } } int main() { inp(); while(bfs()) upd(); printf(&quot;%lld %lld\\n&quot;,Max_flow,Max_cost); return 0; } ä¾‹é¢˜ äºŒåˆ†å›¾æœ€å¤§åŒ¹é…é—®é¢˜ è§£å†³äºŒåˆ†å›¾åŒ¹é…é—®é¢˜å¯ä»¥ä½¿ç”¨åŒˆç‰™åˆ©ç®—æ³•ï¼Œä¹Ÿå¯ä»¥ç”¨ç½‘ç»œæµæœ€å¤§æµçš„æ¨¡å‹æ¥è§£å†³ è¿™æ˜¯ä¸€ä¸ªäºŒåˆ†å›¾ ä¹Ÿå¯ä»¥è¿™æ ·çœ‹è¿™å¼ å›¾ 0å·ç»“ç‚¹å¯ä»¥çœ‹ä½œæœ€å¤§æµçš„è¶…çº§æºç‚¹ï¼Œ6å·ç»“ç‚¹å¯ä»¥çœ‹ä½œè¶…çº§æ±‡ç‚¹ï¼Œå› ä¸ºæ¯ä¸ªç»“ç‚¹æœ€å¤šåªèƒ½åŒ¹é…ä¸€ä¸ªç»“ç‚¹ï¼Œæ‰€ä»¥æ¯ä¸€æ¡è¾¹çš„æœ€å¤§æµé‡åªèƒ½æ˜¯1 ä»£ç å¯ä»¥è¿™æ ·å†™ é¢˜ç›®é“¾æ¥ #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN = 1005; const int MAXM = 1e5+5; const int INF = 0x3f3f3f3f; inline int read() { int x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int s, t; int n, m, e; int tot = 1; int d[MAXN]; int head[MAXN]; int to[MAXM&lt;&lt;1]; int val[MAXM&lt;&lt;1]; int nxt[MAXM&lt;&lt;1]; int gap[MAXM&lt;&lt;1]; void add(int x,int y,int z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } void inp() { n = read(); m = read(); e = read(); s = n+m+1; t = n+m+2; for(int i = 1; i &lt;= e; i++) { int x = read(); int y = read(); add(x,y+n,1); add(y+n,x,0); } for(int i = 1; i &lt;= n; i++) { add(s,i,1); add(i,s,0); } for(int i = 1; i &lt;= m; i++) { add(i+n,t,1); add(t,i+n,0); } } bool bfs() { memset(d,0,sizeof(d)); queue&lt;int&gt; q; q.push(s); d[s] = 1; gap[s] = head[s]; while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i ; i = nxt[i]) { int y = to[i]; if(d[y] == 0 &amp;&amp; val[i] &gt; 0) { q.push(y); d[y] = d[x] + 1; gap[y] = head[y]; if(y == t) return true; } } } return false; } int dfs(int now,int flow) { if(now == t) return flow; int k = 0; int res = 0; for(int i = gap[now]; i ; i = nxt[i]) { int y = to[i]; if(val[i] &gt; 0 &amp;&amp; d[y] == d[now] + 1) { k = dfs(y,min(val[i],flow)); if(!k) d[y] = 0; flow -= k; res += k; val[i] -= k; val[i^1] += k; } } return res; } int main() { inp(); int ans = 0; while(bfs()) ans += dfs(s,INF); printf(&quot;%d\\n&quot;,ans); return 0; } æœ€å°è·¯å¾„è¦†ç›–é—®é¢˜ é¢˜ç›®é“¾æ¥ ç»™å®šä¸€ä¸ªæœ‰å‘å›¾ G=(V,E)G=(V,E)G=(V,E) ,è®¾ P æ˜¯ G çš„ä¸€ä¸ªç®€å•è·¯çš„é›†åˆã€‚å¦‚æœ V ä¸­æ¯ä¸ªé¡¶ç‚¹æ°å¥½åœ¨ P çš„ä¸€æ¡è·¯ä¸Šï¼Œåˆ™ç§° P æ˜¯ G çš„ä¸€ä¸ªè·¯å¾„è¦†ç›–ã€‚ é¦–å…ˆå°†æ¯ä¸ªç‚¹çœ‹åšä¸€æ¡è·¯å¾„ï¼Œæˆ‘ä»¬éœ€è¦è®©è·¯å¾„å°½å¯èƒ½çš„å°‘ï¼Œæ‰€ä»¥å°±éœ€è¦åˆå¹¶æŸäº›è·¯å¾„ï¼Œåˆå¹¶å®Œæˆåï¼Œæœ€å°è·¯å¾„è¦†ç›–æ•° = ç»“ç‚¹æ•° - åˆå¹¶çš„ç‚¹çš„æ•°é‡ æ±‚è§£åˆå¹¶çš„ç‚¹çš„ä¸ªæ•°æ—¶å¯ä»¥å°†ç‚¹æ‹†æˆä¸¤ä¸ªï¼Œå»ºå›¾æ—¶æ¯ä¸€æ¡æœ‰å‘è¾¹çš„ç»ˆç‚¹ä¸ºæ‹†å‡ºæ¥çš„ç‚¹ï¼Œæ­¤æ—¶è¯¥é—®é¢˜å°±è½¬åŒ–ä¸ºäº†äºŒåˆ†å›¾æœ€å¤§åŒ¹é…é—®é¢˜ï¼Œå»ºç«‹ä¸€ä¸ªè¶…çº§æºç‚¹è¿æ¥æ‹†ç‚¹çš„ç»“ç‚¹ï¼Œå†å»ºç«‹ä¸€ä¸ªè¶…çº§æ±‡ç‚¹è¿æ¥æ‹†å‡ºæ¥çš„ç»“ç‚¹ï¼Œåœ¨å›¾ä¸Šè·‘æœ€å¤§æµå³å¯ã€‚ #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN = 155; const int MAXM = 6e3+5; const int INF = 0x3f3f3f3f; inline int read() { int x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int n, m; int s, t; int tot = 1; int d[MAXN&lt;&lt;1]; int to[MAXM&lt;&lt;1]; int gap[MAXN&lt;&lt;1]; int nxt[MAXM&lt;&lt;1]; int val[MAXM&lt;&lt;1]; int pre[MAXN&lt;&lt;1]; int head[MAXN&lt;&lt;1]; void add(int x,int y,int z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } void inp() { n = read(); m = read(); s = n*2+1; t = n*2+2; for(int i = 1; i &lt;= m; i++) { int x = read(); int y = read(); add(x,y+n,1); add(y+n,x,0); } for(int i = 1; i &lt;= n; i++) { add(s,i,1); add(i,s,0); add(i+n,t,1); add(t,i+n,0); } } bool bfs() { memset(d,0,sizeof(d)); queue&lt;int&gt; q; d[s] = 1; gap[s] = head[s]; q.push(s); while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i ; i = nxt[i]) { int y = to[i]; if(d[y] == 0 &amp;&amp; val[i] &gt; 0) { q.push(y); d[y] = d[x] + 1; gap[y] = head[y]; if(y == t) return true; } } } return false; } int dfs(int now,int flow) { if(now == t) return flow; int k = 0; int res = 0; for(int i = gap[now] ; i &amp;&amp; flow; i = nxt[i]) { int y = to[i]; if(val[i] &gt; 0 &amp;&amp; d[y] == d[now] + 1) { k = dfs(y,min(flow,val[i])); if(!k) { d[y] = 0; continue; } flow -= k; res += k; val[i] -= k; val[i^1] += k; pre[now] = y; } } return res; } bool vis[MAXN&lt;&lt;1]; void find(int now) { printf(&quot;%d &quot;,now); vis[now] = true; for(int i = head[now]; i ; i = nxt[i]) { if(to[i] != t &amp;&amp; to[i] != s) if(val[i] == 0 &amp;&amp; val[i^1] == 1) if(to[i] &gt; n) find(to[i]-n); } } int main() { inp(); int ans = 0; while(bfs()) { ans += dfs(s,INF); } ans = n-ans; for(int i = 1; i &lt;= n; i++) if(!vis[i]) { find(i); puts(&quot;&quot;); } printf(&quot;%d&quot;,ans); return 0; } é­”æœ¯çƒé—®é¢˜ é¢˜ç›®é“¾æ¥ é¢˜ç›®è¦æ±‚çš„æ˜¯ è¿™ n ä¸ªæŸ±å­ä¸Šæœ€å¤šèƒ½æ”¾å¤šå°‘ä¸ªçƒï¼Œå°†æ¯ä¸ªæŸ±å­çœ‹æˆä¸€ä¸ªè·¯å¾„ï¼Œè¿™ä¸ªé—®é¢˜å°±å¯ä»¥è½¬åŒ–ä¸ºè®¡ç®—æœ€å¤š n æ¡è·¯å¾„æœ€å¤šå¯ä»¥è¦†ç›–å¤šå°‘ä¸ªç»“ç‚¹ã€‚ å…·ä½“è§£æ³•æ˜¯åœ¨æšä¸¾æ¯ä¸ªæŸ±å­çš„æ—¶å€™æšä¸¾æ¯ä¸€ä¸ªç‚¹ï¼Œä¾æ¬¡å°†æšä¸¾åˆ°çš„ç‚¹åŠ å…¥åˆ°å›¾ä¸­ç„¶åå»è·‘æœ€å¤§æµï¼Œå¦‚æœæ±‚å‡ºçš„æœ€å¤§æµç­‰äº0åˆ™è®¤ä¸ºå½“å‰æ•°é‡çš„æŸ±å­ä¸èƒ½æ”¾ä¸‹è¿™ä¹ˆå¤šçƒï¼Œç„¶åå¢åŠ æŸ±å­æ•°é‡ã€‚ å¯»æ‰¾è·¯å¾„æ—¶å› ä¸ºè¦æ‰¾å‡ºæ¯ä¸€ä¸ªæŸ±å­ä¸Šçš„ç»“ç‚¹ï¼Œæ‰€ä»¥åœ¨æœç´¢æ—¶è®°å½•å¥½æ¯ä¸€ä¸ªç»“ç‚¹çš„å‰ç¼€ç»“ç‚¹ï¼Œå¯¹äºæ¯ä¸ªæŸ±å­è®°å½•æ”¾åœ¨ä¸Šé¢çš„ç¬¬ä¸€ä¸ªç»“ç‚¹ã€‚ #include&lt;queue&gt; #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN = 1e5+5; int n; int s = 1e5+1; int t = 1e5+2; int tot = 1; int d[MAXN]; int to[MAXN]; int pre[MAXN]; int val[MAXN]; int nxt[MAXN]; int top[MAXN]; int gap[MAXN]; bool vis[MAXN]; int head[MAXN]; void add(int x,int y,int z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } bool bfs() { memset(d,-1,sizeof(d)); queue&lt;int&gt; q; q.push(s); gap[s] = head[s]; d[s] = 1; while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i ; i = nxt[i]) { int y = to[i]; if(d[y] == -1 &amp;&amp; val[i] &gt; 0) { q.push(y); d[y] = d[x] + 1; gap[y] = head[y]; } } } return d[t] != -1; } int dfs(int now,int flow) { if(now == t) return flow; int k = 0; int res = 0; for(int i = gap[now]; i &amp;&amp; flow; i = nxt[i]) { int y = to[i]; if(d[y] == d[now] + 1 &amp;&amp; val[i]) { k = dfs(y,min(flow,val[i])); if(k) { flow -= k; res += k; val[i] -= k; val[i^1] += k; if(y != t) pre[now&gt;&gt;1] = y&gt;&gt;1; } } } return res; } int main() { scanf(&quot;%d&quot;,&amp;n); int now = 0; int cnt = 0; while(cnt &lt;= n) { now++; add(s,now&lt;&lt;1,1); add(now&lt;&lt;1,s,0); add(t,(now&lt;&lt;1)|1,0); add((now&lt;&lt;1)|1,t,1); for(int i = sqrt(now)+1; i*i &lt; (now&lt;&lt;1); i++) { add((i*i-now)&lt;&lt;1,(now&lt;&lt;1)|1,1); add((now&lt;&lt;1)|1,(i*i-now)&lt;&lt;1,0); } int flow = 0; while(bfs()) { flow += dfs(s,0x3f3f3f3f); } if(!flow) top[++cnt] = now; } printf(&quot;%d\\n&quot;,now-1); for(int i = 1; i &lt;= n; i++) { if(vis[top[i]]) continue; int x = top[i]; vis[x] = true; while(x) { printf(&quot;%d &quot;,x); x = pre[x]; vis[x] = true; } puts(&quot;&quot;); } return 0; } ","link":"https://zzzcd0x.github.io/post/wang-luo-liu-chu-bu/"},{"title":"æœ€è¿‘å…¬å…±ç¥–å…ˆ","content":"æ ‘ä¸Šå€å¢æ³• æ€ä¹ˆè®¡ç®—çš„ï¼Ÿ å‡è®¾è¦è®¡ç®—æ ‘ä¸Šxå’Œyç»“ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œd[x]è¡¨ç¤ºç»“ç‚¹xçš„æ·±åº¦ï¼ŒF[x,k]è¡¨ç¤ºç»“ç‚¹xå‘ä¸Šè·³2 è®¾d[x] &gt;= d[y]å¦åˆ™äº¤æ¢xå’Œy å°†xç»“ç‚¹å°è¯•å‘ä¸Šèµ°2^{log(n)}...2^{log(0)}æ­¥ï¼Œæ£€æŸ¥æ¯æ¬¡åˆ°è¾¾çš„ç»“ç‚¹æ˜¯å¦æ¯”yæ·±ï¼Œè‹¥æ˜¯ï¼Œåˆ™ä»¤x=F[x,k]ï¼Œè·³å‡ºå¾ªç¯ å¦‚æœæ­¤æ—¶x=yåˆ™ä¸¤ä¸ªç»“ç‚¹çš„LCAå°±æ˜¯y å¦‚æœä¸æ˜¯ï¼Œåˆ™å°†xå’ŒyåŒæ—¶å‘ä¸Šè°ƒæ•´ï¼Œä¿æŒä¸¤è€…æ·±åº¦ç›¸åŒä½†ä¸ç›¸ç­‰ï¼Œå³å°†ä¸¤èŠ‚ç‚¹åŒæ—¶å‘ä¸Šè·³2^{log(n)}...2^{log(0)}æ­¥ï¼Œè‹¥æ­¤æ—¶F[x,k]!=F[y,k](å³æ·±åº¦ä¸ç›¸ç­‰)ï¼Œåˆ™ä»¤x=F[x,k],y=F[y,k] å¾ªç¯ç»“æŸåxå’Œyä¸€å®šå·®ä¸€æ­¥åˆ°è¾¾åŒä¸€ç»“ç‚¹ï¼Œå³ä»–ä»¬çš„æœ€è¿‘å…¬å…±ç¥–å…ˆä¸ºF[x,0]æˆ–F[y,0] å•æ¬¡æŸ¥è¯¢æ—¶é—´å¤æ‚åº¦ä¸ºlog(n) ä¾‹é¢˜ æ¨¡æ¿é¢˜ #include&lt;cstdio&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int MAXN = 4e4+5; const int MAXM = 2e2+5; int tot; int n, m; int dis[MAXN]; int dep[MAXN]; int head[MAXN]; bool vis[MAXN]; int to[MAXN&lt;&lt;1]; int fa[MAXN][25]; int nxt[MAXN&lt;&lt;1]; int val[MAXN&lt;&lt;1]; void add(int x,int y,int z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } void dfs(int now,int dad) { if(vis[now]) return; vis[now] = true; fa[now][0] = dad; for(int i = head[now]; i ;i = nxt[i]) { if(to[i] == dad) continue; dis[to[i]] = dis[now] + val[i]; dep[to[i]] = dep[now] + 1; dfs(to[i],now); } } int lca(int x,int y) { if(dep[x] &gt; dep[y]) swap(x,y); for(int i = 20; i &gt;= 0; i--) if((dep[y] - (1&lt;&lt;i) ) &gt;= dep[x]) y = fa[y][i]; if(x == y) return x; for(int i = 20; i &gt;= 0; i--) if(fa[x][i] != fa[y][i]) { x = fa[x][i]; y = fa[y][i]; } return fa[x][0]; } int t; void inp() { for(int i = 1; i &lt; n; i++) { int x, y, z; scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); add(x,y,z); add(y,x,z); } } void init() { memset(dis,0,sizeof(dis)); memset(vis,0,sizeof(vis)); memset(dep,0,sizeof(dep)); memset(head,0,sizeof(head)); tot = 0; } int main() { scanf(&quot;%d&quot;,&amp;t); while(t) { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); init(); inp(); dfs(1,1); for(int i = 1; i &lt;= 20; i++) for(int j = 1; j &lt;= n; j++) fa[j][i] = fa[fa[j][i-1]][i-1]; for(int i = 1; i &lt;= m; i++) { int x,y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); printf(&quot;%d\\n&quot;,dis[x] + dis[y] - 2*dis[lca(x,y)]); } t--; } return 0; } ","link":"https://zzzcd0x.github.io/post/zui-jin-gong-gong-zu-xian/"},{"title":"SPFA","content":"è™½ç„¶spfaç®—æ³•èµ›åœºä¸Šä¼šå„ç§è¢«å¡ï¼Œä½†è¿˜æ˜¯è›®ä¸é”™çš„ã€‚ å¤§è‡´æ€æƒ³ é¦–å…ˆå°†æºç‚¹åŠ å…¥é˜Ÿåˆ— ç„¶åæ›´æ–°æºç‚¹èƒ½å¤Ÿåˆ°è¾¾çš„ç‚¹çš„æœ€çŸ­è·¯ å¦‚æœè¢«æ›´æ–°çš„ç‚¹ä¸åœ¨é˜Ÿåˆ—ä¸­ï¼Œåˆ™åŠ å…¥é˜Ÿåˆ— é‡å¤ä¸Šè¿°2~3æ­¥ç›´åˆ°é˜Ÿåˆ—ä¸ºç©º å…¶å®æ€æƒ³ä¸dijkstraæ¯”è¾ƒç›¸ä¼¼ï¼Œä¸åŒçš„æ˜¯dijkstraåˆ¤æ–­ç‚¹æ˜¯å¦è¿›é˜Ÿçš„ä¾æ®æ˜¯è¯¥ç‚¹çš„æœ€çŸ­è·¯æœ‰æ²¡æœ‰è¢«æ›´æ–°è¿‡ è€Œspfaçš„ä¾æ®æ˜¯è¯¥ç‚¹åœ¨ä¸åœ¨é˜Ÿåˆ—ä¸­ å®ç° é“¾å¼å‰å‘æ˜Ÿéƒ¨åˆ†å·²çœç•¥ int d[MAXN]; bool b[MAXN]; void spfa(int s){ memset(d,0x3f,sizeof(d)); d[s] = 0; b[s] = true; q.push(s); while(!q.empty()) { int x = q.front(); q.pop(); b[x] = false; for(int i = head[x]; i ;i = edge[i].next) { int to = edge[i].to; int val = edge[i].val; if(d[to] &gt; d[x] + val) { d[to] = d[x] + val; if(!b[to]) { q.push(to); b[to] = true; } } } } } ä¾‹é¢˜ åˆ¤æ–­è´Ÿç¯ é¢˜ç›®é“¾æ¥ å¦‚æœå›¾ä¸­å‡ºç°äº†è´Ÿç¯é‚£ä¹ˆåœ¨spfaä¸­è´Ÿç¯ä¸Šçš„ç»“ç‚¹ä¼šä¸æ–­çš„å…¥é˜Ÿï¼Œå› æ­¤åªè¦å¯¹å…¥é˜Ÿæ¬¡æ•°è¿›è¡Œè®¡æ•°ï¼Œå¦‚æœæœ‰ä¸€ä¸ªç»“ç‚¹å…¥é˜Ÿæ¬¡æ•°å¤§äºç­‰äºæ€»ç»“ç‚¹æ•°ï¼Œåˆ™å›¾ä¸­ä¸€å®šå­˜åœ¨è´Ÿç¯ #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;utility&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int MAXN = 505; const int MAXM = 3005; inline int read() { int x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int tot; int n, m, w; int head[MAXN]; int to[MAXM&lt;&lt;1]; ll val[MAXM&lt;&lt;1]; int nxt[MAXM&lt;&lt;1]; int from[MAXM&lt;&lt;1]; void add(int x,int y,ll z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; from[tot] = x; } void inp() { n = read(); m = read(); w = read(); tot = 0; memset(head,0,sizeof(head)); memset(nxt,0,sizeof(0)); for(int i = 1; i &lt;= m; i++) { int x = read(); int y = read(); ll z = read(); add(x,y,z); add(y,x,z); } for(int i = 1; i &lt;= w; i++) { int x = read(); int y = read(); ll z = read(); add(x,y,-z); } } ll d[MAXN]; int temp[MAXN]; bool vis[MAXN]; bool spfa() { queue&lt;int&gt; q; memset(d,0x3f,sizeof(d)); memset(temp,0,sizeof(temp)); memset(vis,false,sizeof(vis)); q.push(1); temp[1]++; d[1] = 0; vis[1] = true; while(!q.empty()) { int x = q.front(); vis[x] = false; q.pop(); for(int i = head[x]; i ; i = nxt[i]) { if(d[to[i]] &gt; d[x] + val[i]) { d[to[i]] = d[x] + val[i]; temp[to[i]]++; if(temp[to[i]] &gt;= n) return true; if(!vis[to[i]]) { q.push(to[i]); vis[to[i]] = true; } } } } return false; } int main() { int t = read(); while(t) { inp(); if(spfa()) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); t--; } return 0; } ","link":"https://zzzcd0x.github.io/post/spfa/"},{"title":"å¹¶æŸ¥é›†DSU","content":" å¼•å…¥ å‡è®¾ç°åœ¨æœ‰nä¸ªä»…çŸ¥é“è‡ªå·±çš„çˆ¶äº²æ˜¯è°çš„äººï¼Œç°åœ¨è¦å­˜å‚¨ä»–ä»¬æ¯ä¸ªäººä¹‹é—´çš„å…³ç³»ï¼Œå¹¶æŸ¥è¯¢å…¶ä¸­å‡ ä¸ªäººæ˜¯å¦å±äºåŒä¸€å®¶æ— æ€è·¯ é¦–å…ˆå¯ä»¥æƒ³åˆ°æ¯ä¸€ä¸ªå®¶æ—å¯ä»¥ç»„æˆä¸€ä¸ªæ ‘ï¼Œä½†å¦‚æœæ¯ä¸€ä¸ªç»“ç‚¹éƒ½åªå‚¨å­˜è‡ªå·±çš„çˆ¶äº²æ˜¯è°ï¼Œé‚£è¿™å‡ æ£µæ ‘å°±ä¼š è¿›åŒ– å˜æˆä¸€ä¸ªæ£®æ— æ‰€ä»¥åœ¨å­˜å‚¨ä¸¤ä¸ªç»“ç‚¹çš„çˆ¶å­å…³ç³»æ—¶ï¼Œæˆ‘ä»¬åº”è¯¥è®¤å®šä¸¤ä¸ªç»“ç‚¹çš„æœ€è¿œå¤çš„çˆ¶ç»“ç‚¹ä¹‹é—´æœ‰äº²ç¼˜å…³ç³»ï¼Œä»è€Œé˜²æ­¢æ£®æ—çš„è¯ç”Ÿ å¯¹äºæŸ¥è¯¢ä¸¤ä¸ªç»“ç‚¹çš„æ˜¯å¦å±äºåŒä¸€å®¶æ—ï¼Œæˆ‘ä»¬ä»…éœ€è¦æŸ¥è¯¢ä»–ä»¬çš„æœ€è¿œå¤ç¥–å…ˆæ˜¯å¦ç›¸åŒï¼Œä½†å½“æŸä¸€ä¸ªç»“ç‚¹æ²¡æœ‰çˆ¶ç»“ç‚¹æ—¶ï¼Œè¿™ä¸ªç»“ç‚¹å°±ä¸€å®šæ˜¯å½“å‰å®¶æ—çš„æœ€è¿œå¤ç¥–å…ˆ æ€è·¯å°±æ˜¯è¿™æ ·äº† é‚£ä¹ˆæˆ‘ä»¬ç”¨ä»£ç æ¥å®ç°ä¸€ä¸‹ æœ´ç´ å†™æ³• int dad[10005]; //å­˜å‚¨æ¯ä¸ªç»“ç‚¹çš„çˆ¶ç»“ç‚¹ int anc(int x){ //æŸ¥è¯¢æ¯ä¸ªç»“ç‚¹çš„è¿œå¤ç¥–å…ˆ if(dad[x]) return anc(dad[x]); else return x; //å½“è¯¥ç»“ç‚¹æ²¡æœ‰çˆ¶ç»“ç‚¹æ—¶å½“å‰ç»“ç‚¹å³ä¸ºæœ€è¿œå¤ç¥–å…ˆ } bool ask(int x, int y){ //æŸ¥è¯¢ä¸¤ä¸ªç»“ç‚¹æ˜¯å¦åœ¨åŒä¸€å®¶æ— return anc(x) == anc(y); } void uni(int x, int y){ //è®¾å®šäº²å±å…³ç³» x = anc(x); y = anc(y); if(x != y) dad[x] = y; } ä»¥ä¸Šå°±æ˜¯å¹¶æŸ¥é›†çš„ä¸€ç§æœ´ç´ å†™æ³• è·¯å¾„å‹ç¼©ä¼˜åŒ– åˆ†æä¸€ä¸‹è¿™ç§å†™æ³•çš„å¤æ‚åº¦æˆ‘ä»¬å°±å¯ä»¥å‘ç°ï¼Œask()å’Œuni()å‡½æ•°éƒ½æ˜¯é€šè¿‡anc()æ¥å®ç°çš„ï¼Œä½†å¦‚æœç¢°åˆ°äº†å­å­å­™å­™æ— ç©·åŒ®ä¹Ÿçš„æƒ…å†µï¼Œæ•´æ£µæ ‘å°±ä¼šè¢«é€€åŒ–ä¸ºä¸€æ¡é“¾ï¼Œæ‰€ä»¥æ¯æ¬¡æŸ¥æ‰¾éœ€è¦æ¶ˆè€—O(n)çš„å¤æ‚åº¦ æ—¢ç„¶æˆ‘ä»¬åªå…³å¿ƒæŸä¸€ä¸ªç»“ç‚¹çš„æœ€è¿œå¤ç¥–å…ˆï¼Œé‚£ä¹ˆæˆ‘ä»¬ä»…éœ€è¦å­˜å‚¨æ¯ä¸ªç»“ç‚¹çš„æœ€è¿œå¤ç¥–å…ˆå³å¯ï¼Œä¼˜åŒ–å†™æ³•å¯ä»¥ä½¿ç”¨ä¸€ä¸‹è®°å¿†åŒ–æœç´¢çš„æŠ€å·§ int anc(int x){ if(dad[x] != x) return dad[x] = anc(dad[x]); else return x; } æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¯¹anc()å‡½æ•°è¿›è¡Œè¿™æ ·çš„ä¿®æ”¹ï¼Œæ­¤æ—¶æ¯æ¬¡æ“ä½œçš„å¹³å‡å¤æ‚åº¦å¯ä»¥æ¥è¿‘O(1) å¹¶æŸ¥é›† è¿™ä¸ªæ•°æ®ç»“æ„å°±å«æ˜¯å¹¶æŸ¥é›†ï¼Œå¹¶æŸ¥é›†å¯ä»¥ç”¨æ¥ç»´æŠ¤ä¸ç›¸äº¤é›†åˆ æ”¯æŒä¸¤ç§æ“ä½œï¼š æŸ¥è¯¢xå’Œyæ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆ å°†xã€yæ‰€åœ¨é›†åˆåˆå¹¶ ","link":"https://zzzcd0x.github.io/post/bing-cha-ji-dsu/"},{"title":"gcd lcm","content":"æœ€å¤§å…¬å› æ•°(gcd) æ€§è´¨ï¼š gcd(1,n) = 1 è®¾d = gcd(a,b) åˆ™ gcd(a/d,b/d) = 1 gcd(a,b) = gcd(a+-b,b) = gcd(a,b+-a) è¾—è½¬ç›¸é™¤æ³•æ±‚è§£ï¼š ç”±gcd(a,b) = gcd(a-b,b) å¾— gcd(a,b) = gcd(a%b,b) å› æ­¤æ±‚è§£è¿‡ç¨‹å¯å†™ä¸ºï¼š å¦‚æœa&lt;b,åˆ™äº¤æ¢a,b å¦‚æœb = 0ï¼Œåˆ™è¿”å›a ä»¤a = a%b é‡å¤ä¸Šè¿°è¿‡ç¨‹ int gcd(int a, int b) { if (a &lt; b) { int t = b; b = a; a = t; } if (b == 0) return a; return gcd(a % b, b); } æœ€å°å…¬å€æ•°(lcm) lcm(a,b) = {ab\\over gcd(a,b)} æ€ä¹ˆæ±‚å°±ä¸ç”¨è¯´äº†å§ ","link":"https://zzzcd0x.github.io/post/gcd-lcm/"},{"title":"ç´ æ•°ç­›","content":"åŸƒæ°ç­› ä¸»è¦è¿‡ç¨‹ ä»2åˆ°næšä¸¾ï¼Œå¦‚æœè¯¥æ•°å­—æ²¡æœ‰æ ‡è®°(æ˜¯ç´ æ•°) æšä¸¾èŒƒå›´å†…çš„è¯¥æ•°å­—çš„å€æ•°ï¼Œå°†æšä¸¾åˆ°çš„æ•°å­—æ ‡è®°ä¸ºç´ æ•° è¿™æ ·æšä¸¾ç»“æŸåæ‰€æœ‰çš„åˆæ•°å°±è¢«æ‰“äº†æ ‡è®°ï¼Œæ²¡æ‰“æ ‡è®°çš„å°±æ˜¯ç´ æ•° å®ç° ä»¥æ‰¾100ä»¥å†…çš„ç´ æ•°ä¸ºä¾‹ int n = 100; bool flag[105]; void sieve(){ for(int i = 2; i &lt;= n; i++) if(!flag[i]) { printf(&quot;%d &quot;,i); for(int j = 2; i*j &lt;= n; j++) flag[i*j] = true; } } æ—¶é—´å¤æ‚åº¦ï¼šO(n\\log(\\log(n))) æ¬§æ‹‰ç­› åŸƒæ°ç­›ä¸­æœ‰ä¸€éƒ¨åˆ†æ•°è¢«ç­›äº†ä¸æ­¢ä¸€æ¬¡ï¼Œä¾‹å¦‚6è¢«2ç­›å®Œåˆè¢«3ç­› ç„¶è€Œä¸€ä¸ªåˆæ•°è¢«æ ‡è®°åªéœ€è¦è¢«å…¶æœ€å°ç´ å› å­ç­›å°±å¥½äº† è¿™æ ·çš„ç­›æ³•å°±æ˜¯æ¬§æ‹‰ç­›ï¼Œä¹Ÿå«çº¿æ€§ç­› è¿‡ç¨‹ iä»2å¼€å§‹æšä¸¾ï¼Œåœ¨æšä¸¾çš„è¿‡ç¨‹ä¸­ï¼Œè®°å½•å½“å‰å·²çŸ¥çš„ç´ æ•° æšä¸¾çš„æ¯ä¸€æ­¥éƒ½å»ç­›å½“å‰å·²çŸ¥çš„æ‰€æœ‰çš„ç´ æ•°çš„iå€ å½“ièƒ½è¢«æšä¸¾åˆ°çš„ç´ æ•°æ•´é™¤å³å·²ç»ç­›åˆ°äº†å½“å‰æƒ…å†µä¸‹å°†è¦è¢«ç­›çš„æ•°çš„æœ€å°ç´ å› å­åˆ™è·³å‡ºå¾ªç¯åº”è¯¥è¢«ç­›å´æ²¡æœ‰è¢«ç­›çš„æ•°ä¼šåœ¨iæ›´å¤§çš„æƒ…å†µä¸‹è¢«ç­›æ‰ å®ç° ä»¥æ‰¾100ä»¥å†…çš„ç´ æ•°ä¸ºä¾‹ int cnt; int n = 100; int prime[100]; bool flag[100]; void sieve(){ for(int i = 2; i &lt;= n; i++) { if(!flag[i]) { prime[++cnt] = i; printf(&quot;%d &quot;,i); } for(int j = 1; prime[j] * i &lt;= n &amp;&amp; j &lt;= cnt; j++) { flag[prime[j]*i] = true; if(i % prime[j] == 0) break; } } } æ—¶é—´å¤æ‚åº¦ï¼šO(n) é€‚åˆå¤„ç†æ•°æ®èŒƒå›´å·¨å¤§çš„æƒ…å†µ ","link":"https://zzzcd0x.github.io/post/su-shu-shai/"},{"title":"é“¾å¼å‰å‘æ˜Ÿ","content":"åŸç† é“¾å¼å‰å‘æ˜Ÿä¸é‚»æ¥è¡¨ç±»ä¼¼ï¼Œç”¨ä¸€ä¸ªæ•°ç»„å­˜å‚¨äº†ä¸€ä¸ªç‚¹å¯ä»¥åˆ°è¾¾çš„æ‰€æœ‰çš„ç‚¹ï¼ŒåŒºåˆ«æ˜¯é“¾å¼å‰å‘æ˜Ÿä½¿ç”¨é“¾è¡¨å°†ä»æ¯ä¸€ä¸ªç‚¹å‡ºå‘çš„æ¯ä¸€æ¡è¾¹ç”¨é“¾è¡¨çš„å½¢å¼é“¾åœ¨äº†ä¸€èµ·ï¼Œå¯¹è¾¹çš„å­˜å‚¨æ–¹å¼æ˜¯å­˜å‚¨æŒ‡å‘çš„é¡¶ç‚¹ï¼Œè¾¹æƒï¼Œä»¥åŠä¸€ä¸‹ä¸€æ¡è¾¹çš„ç¼–å· æ€ä¹ˆå†™å‘¢ ç»“æ„ä½“å†™æ³• struct Edge{ int to; int val; int nxt; int from; }edge[10005]; int head[10005]; //æ¯ä¸€ä¸ªç‚¹çš„é“¾è¡¨çš„å¤´ç»“ç‚¹ç¼–å· int tot = 0; //ç”¨äºå­˜å‚¨æ¯ä¸€ä¸ªç‚¹çš„å¤´ç»“ç‚¹ void add(int x,int y,int z){ edge[++tot].nxt = head[x]; head[x] = tot; edge[tot].to = y; edge[tot].from = x; edge[tot].val = z; } æ•°ç»„å†™æ³• int tot; int to[MAXN]; int from[MAXN]; int head[MAXN]; int val[MAXN]; void add(int x,int y) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; from[tot] = x; } éå† ä¸æ¯ä¸€ä¸ªç‚¹ç›¸è¿çš„è¾¹å·²ç»ä»¥é“¾è¡¨çš„å½¢å¼å­˜å‚¨ï¼Œå¤´ç»“ç‚¹å­˜å‚¨åœ¨headæ•°ç»„ä¸­ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ç±»ä¼¼éå†é“¾è¡¨çš„æ–¹å¼éå†ä¸æ¯ä¸€ä¸ªç‚¹ç›¸è¿çš„æ¯ä¸€æ¡è¾¹ void search(){ for(int i = 1; i &lt;= n; i++) for(int j = head[i]; j ; j = edge[j].next) printf(&quot;%d %d %d\\n&quot;,edge[j].to,edge[j].val,edge[j].next); } ","link":"https://zzzcd0x.github.io/post/lian-shi-qian-xiang-xing/"},{"title":"æ‹“æ‰‘æ’åº","content":"ä»€ä¹ˆæ˜¯DAG é€šä¿—æ¥è¯´DAGå°±æ˜¯æœ‰å‘æ— ç¯å›¾çš„ç®€ç§°ï¼Œé€šè¿‡åå­—å°±å¯ä»¥çœ‹å‡ºï¼ŒDAGçš„åŸºæœ¬ç‰¹ç‚¹æ˜¯è¾¹ä¸ºæœ‰å‘è¾¹ï¼Œä¸”å›¾å†…æ— ç¯ è¿™ä¸ªå›¾è™½ç„¶çœ‹ä¼¼æœ‰ç¯ï¼Œä½†å› ä¸ºè¾¹éƒ½æ˜¯æœ‰å‘è¾¹ï¼Œæ‰€ä»¥å¹¶æ²¡æœ‰æ„æˆç¯ã€‚ è§‚å¯Ÿä¸€ä¸‹ä¸Šé¢é‚£ä¸ªå›¾ï¼Œä¸éš¾å‘ç°ä»¥æ¯ä¸€ä¸ªç»“ç‚¹ä¸ºèµ·ç‚¹éƒ½å¯ä»¥æ‰¾åˆ°å¯¹åº”çš„ä¸€æ¡é“¾ï¼Œå› æ­¤è®¸å¤šå›¾è®ºé—®é¢˜éƒ½å¯ä»¥æŠ½è±¡ä¸ºæ‰¾DAGä¸­çš„æœ€çŸ­é“¾æˆ–è€…æœ€é•¿é“¾ã€‚ ç„¶è€Œåœ¨ä¸€äº›å›¾è®ºé—®é¢˜ä¸­ç»“ç‚¹ä¹‹é—´å­˜åœ¨å…ˆåå…³ç³»ï¼Œè¿™æ ·å°±ä¸èƒ½ç›´æ¥ç”¨å¹³å¸¸çš„éå†æ–¹å¼æ¥å¯¹å›¾è¿›è¡Œéå†ï¼Œè€Œæ˜¯éœ€è¦å…ˆå¯¹ç»“ç‚¹æŒ‰ç…§å…ˆåé¡ºåºè¿›è¡Œæ’åºï¼Œè½¬åŒ–ä¸ºä¸€ä¸ªåºåˆ—åå†è¿›è¡Œéå† æ‹“æ‰‘æ’åº ä¸Šè¿°è¿‡ç¨‹åº”ç”¨çš„æ’åºç®—æ³•å°±æ˜¯æ‹“æ‰‘æ’åºï¼Œæ’åºåæ•´å¼ å›¾å°±è¢«è½¬åŒ–æˆäº†ä¸€ä¸ªåºåˆ—ï¼Œç„¶åé€šè¿‡è¿™ä¸ªåºåˆ—æ¥è§£å†³é—®é¢˜ è¿‡ç¨‹ åœ¨å­˜å›¾æ˜¯è®°å½•æ¯ä¸ªç»“ç‚¹çš„å…¥åº¦å’Œå‡ºåº¦ å­˜å›¾ç»“æŸåå°†å…¥åº¦ä¸º0çš„ç‚¹åŠ å…¥åºåˆ— é‚£å¤„åºåˆ—å¤´éƒ¨çš„ç‚¹xï¼Œéå†è¯¥ç‚¹å¯ä»¥åˆ°è¾¾çš„æ‰€æœ‰ç‚¹y åˆ æ‰xåˆ°yçš„è¾¹ï¼Œå³yç‚¹çš„å…¥åº¦å‡ä¸€ å¦‚æœyç‚¹å…¥åº¦ä¸º0åˆ™åŠ å…¥åºåˆ— é‡å¤2~5ç›´è‡³åºåˆ—ä¸ºç©º struct edge{ int to; int val; int next; }e[10005]; int n, m; int ind[10005]; //å…¥åº¦ int head[100005]; queue&lt;int&gt;q; void topsort(){ for(int i = 1; i &lt;= n; i++) //å°†å…¥åº¦ä¸º0çš„ç»“ç‚¹æ”¾å…¥åºåˆ— if(!ind[i]) q.push(i); while(!q.empty()) { int x = q.front(); q.pop(); for(int i = head[x]; i; i = e[i].next) //éå†xèƒ½åˆ°è¾¾çš„ç‚¹ { int y = e[i].to; ind[y]--; //åˆ è¾¹ if(!ind[y]) //å¦‚æœyç‚¹å…¥åº¦ä¸º0åˆ™æ”¾å…¥åºåˆ— q.push(y); } } } ","link":"https://zzzcd0x.github.io/post/tuo-bu-pai-xu/"},{"title":"kruskal","content":"kruskal æ˜¯ä»€ä¹ˆå‘¢ æ˜¯ä¸€ç§æ±‚ä¸€ä¸ªå›¾çš„æœ€å°ç”Ÿæˆæ ‘çš„ç®—æ³•ï¼Œæ ¸å¿ƒæ€æƒ³æ˜¯è´ªå¿ƒï¼Œå…¶å®å°±æ˜¯ä¸ªè´ªå¿ƒï¼Œä¸primeç›¸æ¯”æ›´åŠ é€‚åˆæ±‚è¾¹æ¯”è¾ƒç¨€ç–çš„å›¾çš„æœ€å°ç”Ÿæˆæ ‘ æ—¶é—´å¤æ‚åº¦æ˜¯O(mlogm) è¿è¡Œè¿‡ç¨‹ kruskalé‡Œé¢çš„è¾¹çš„ä½œç”¨å¯ä»¥ç†è§£ä¸ºåªæ˜¯ä¸ºäº†è¡¨è¾¾ä¸¤ä¸ªç‚¹çš„å…·æœ‰é•¿åº¦çš„è¿æ¥å…³ç³» é¦–å…ˆå°†æ‰€æœ‰çš„è¾¹æŒ‰ç…§è¾¹æƒä»å°åˆ°å¤§æ’åº ç„¶åæšä¸¾æ¯ä¸€æ¡è¾¹ï¼Œå¦‚æœæ­£åœ¨æšä¸¾çš„è¾¹çš„ä¸¤ä¸ªç»“ç‚¹æ— è”é€šå…³ç³»ï¼Œåˆ™å°†è¯¥è¾¹è¾¹æƒè®¡å…¥ç­”æ¡ˆä¸­ã€å¹¶ç”¨å¹¶æŸ¥é›†æ ‡è®°ä¸¤ç‚¹çš„è”é€šå…³ç³» å½“ç”Ÿæˆæ ‘è”é€šåå³å¯è·³å‡ºå¾ªç¯ æ³¨æ„å»ºè¾¹åªè¦å»ºå•å‘å³å¯ æ¨¡æ¿ struct Edge { int to; int val; int nxt; int from; }edge[MAXM]; int dad[MAXN]; bool judge(Edge x,Edge y) {return x.val &lt; y.val;} void kruskal() { for(int i = 1; i &lt;= n; i++) dad[i] = i; sort(edge+1,edge+n+1,judge); for(int i = 1; i &lt;= tot; i++) { int x = anc(edge[i].from); int y = anc(edge[i].to); if(x != y) { ans += edge[i].val; dad[x] = y; } } } æ³¨æ„äº‹é¡¹ çœŸæ­£çš„è¾¹æƒå¯èƒ½å¹¶ä¸æ˜¯è¾“å…¥çš„è¾¹æƒ ","link":"https://zzzcd0x.github.io/post/kruskal/"},{"title":"Floyd","content":"å¹²ä»€ä¹ˆçš„å‘¢ å¤§å¤šç”¨äºæ±‚å¤šæºå›¾ä¸­ä¸¤ç‚¹é—´çš„æœ€çŸ­è·¯ï¼Œä¹Ÿå¯ä»¥ç”¨äºä¼ é€’é—­åŒ… å†™æ³• for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]); æ—¶é—´å¤æ‚åº¦ O(n3n^3n3) æ­£ç¡®æ€§è¯æ˜ Floydç®—æ³•æ ¸å¿ƒæ€æƒ³æ˜¯åŠ¨æ€è§„åˆ’ åŸdpæ•°ç»„ä¸º dp[k][i][j] è¡¨ç¤ºç»è¿‡1~kå·èŠ‚ç‚¹çš„æƒ…å†µä¸‹iåˆ°jçš„æœ€çŸ­è·¯ çŠ¶æ€è½¬ç§»å¯ä»¥å†™æˆ dp[k][i][j] = dp[k-1][i][j] + dp[k-1][i][j] ä½†æ˜¯kå¯ä»¥ç”¨æ»šåŠ¨æ•°ç»„ä¼˜åŒ–æ‰ï¼Œæ¥èŠ‚çº¦ä¸€å¤§éƒ¨åˆ†ç©ºé—´å¤æ‚åº¦ æœ€ç»ˆçš„dpæ•°ç»„ä¸º dp[i][j] è¡¨ç¤ºi~jçš„æœ€çŸ­è·¯ å› ä¸ºiåˆ°jç»è¿‡1åˆ°kå·èŠ‚ç‚¹çš„æœ€çŸ­è·¯æ˜¯åŸºäºiåˆ°jç»è¿‡1åˆ°k-1å·èŠ‚ç‚¹çš„æœ€çŸ­è·¯è®¡ç®—çš„ï¼Œæ‰€ä»¥kçš„æšä¸¾è¦æ”¾åœ¨æœ€å¤–å±‚ ç»†èŠ‚ dp[0][i][j]è¡¨ç¤ºåˆå§‹æƒå€¼ï¼Œæœªè¿æ¥çš„èŠ‚ç‚¹ç”¨INFè¡¨ç¤º ä¸€èˆ¬ç”¨Floydæ—¶è¿˜è¦è€ƒè™‘è¾¹çš„æƒå€¼ ä¾‹é¢˜ ä¼ é€’é—­åŒ… é¢˜ç›®é“¾æ¥ å…¶å®å°±æ˜¯åˆ©ç”¨è¿é€šæ€§å¯ä¼ é€’æ€§æ¥åˆ¤æ–­å›¾ä¸­ä¸¤ä¸ªç‚¹ä¹‹é—´æ˜¯å¦è¿æ¥ æ³¨æ„è¾¹ä¸ºå•å‘ï¼Œä½†ä¸¤ä¸ªç‚¹ä¹‹é—´è¿é€šæ˜¯åŒå‘çš„ #include&lt;cstdio&gt; #include&lt;string.h&gt; using namespace std; const int MAXN = 105; const int MAXM = 4505; int ans; int n, m; bool dis[MAXN][MAXN]; void inp() { for(int i = 1; i &lt;= m; i++) { int x, y; scanf(&quot;%d %d&quot;,&amp;x,&amp;y); dis[x][y] = true; } } void floyd() { for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) dis[i][j] |= dis[i][k] &amp; dis[k][j]; } void judge() { int d[MAXN] = {0}; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) if(dis[i][j] || dis[j][i]) d[i]++; for(int i = 1; i &lt;= n; i++) if(d[i] == n-1) ans++; } void init() { ans = 0; memset(dis,0,sizeof(dis)); } int main() { while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) { init(); inp(); floyd(); judge(); printf(&quot;%d\\n&quot;,ans); } return 0; } ","link":"https://zzzcd0x.github.io/post/floyd/"},{"title":"Dijkstra","content":"Dijkstraç®—æ³•æ˜¯ä¸€ç§ç”¨äºè§£å†³æ— è´Ÿæƒè¾¹çš„æœ‰å‘å›¾çš„å•æºæœ€çŸ­è·¯é—®é¢˜çš„ç®—æ³• å¤§è‡´æ€æƒ³ åˆå§‹æ—¶å°†å›¾çš„æºç‚¹çš„æœ€çŸ­è·¯è®¾ä¸º0 å…¶ä»–ç‚¹æœ€çŸ­è·¯é•¿åº¦è®¾ä¸ºINF å°†å›¾ä¸­çš„ç‚¹åˆ†ä¸ºä¸¤ç±» ä¸€ç±»æ˜¯å·²ç»æ›´æ–°è¿‡æœ€çŸ­è·¯çš„ç‚¹ç§°ä¸ºçº¢ç‚¹ï¼Œå¦ä¸€ç±»æ˜¯æœªæ‰¾åˆ°ç¡®å®šçš„æœ€çŸ­è·¯çš„ç‚¹ï¼Œç§°ä¸ºè“ç‚¹ ä»æºç‚¹å¼€å§‹æ›´æ–°èƒ½è¾¾åˆ°çš„ç‚¹çš„æœ€çŸ­è·¯ï¼Œå°†å·²ç»æ±‚å‡ºæœ€çŸ­è·¯çš„ç‚¹æ”¾å…¥é˜Ÿåˆ— æ‰¾å‡ºå½“å‰æœ€çŸ­è·¯æœ€å°çš„è“ç‚¹ï¼Œå°†è¯¥ç‚¹æ”¹ä¸ºçº¢ç‚¹ï¼Œå†å»æ›´æ–°è¿™ä¸ªç‚¹èƒ½è¾¾åˆ°çš„ç‚¹çš„æœ€çŸ­è·¯ é‡å¤ä¸Šè¿°è¿‡ç¨‹ç›´åˆ°é˜Ÿåˆ—ä¸­æ²¡æœ‰ç‚¹ æ­£ç¡®æ€§è¯æ˜ é¦–å…ˆæºç‚¹èƒ½å¤Ÿåˆ°è¾¾çš„ç‚¹çš„æœ€çŸ­è·¯ä¸€å®šæ˜¯ä¸æºç‚¹ç›¸è¿çš„è¾¹çš„æƒå€¼ å¯æ˜¯ä¸ºä»€ä¹ˆå½“å‰æœ€çŸ­è·¯æœ€å°çš„è“ç‚¹å¯ä»¥æ”¹ä¸ºçº¢ç‚¹å‘¢ï¼Ÿ ç”¨åè¯æ³•è¯æ˜ å‡è®¾å–å‡ºçš„è“ç‚¹ä¸ºu å¦‚æœå–å‡ºçš„è“ç‚¹è¿˜å¯ä»¥æ›´æ–°æœ€çŸ­è·¯ï¼Œå³è¿˜ä¸èƒ½æ”¹ä¸ºçº¢ç‚¹ï¼Œé‚£ä¹ˆèƒ½æ›´æ–°è¯¥ç‚¹çš„æœ€çŸ­è·¯çš„ç‚¹ä¸€å®šåœ¨é˜Ÿåˆ—åé¢ï¼Œè®¾è¯¥ç‚¹ä¸ºx ç„¶è€Œé˜Ÿæ˜¯æŒ‰æœ€çŸ­è·¯å¤§å°ä»å°åˆ°å¤§æ’åºçš„ å› æ­¤ d[u] &lt; d[x] ,d[x]+val_{x-&gt;u} &gt; d[u] å¾—è¯ æœ´ç´ å†™æ³• é“¾å¼å‰å‘æ˜Ÿéƒ¨åˆ†å·²çœç•¥ int d[1005]; bool b[1005]; void dijkstra(){ memset(d,0x3f,sizeof(d)); int inf = d[s]; d[s] = 0; for(int i = 1; i &lt;= n; i++) { int Min = inf; for(int j = 1; j &lt;= n; j++) if(!b[j]) if(Min == inf || d[j]&lt;d[Min]) Min = j; if(Min == inf) return ; b[Min] = true; for(int i = head[Min]; i ;i = edge[i].next) { int to = edge[i].to; int val = edge[i].val; if(!b[to]) d[to] = d[Min]+val; } } } æ—¶é—´å¤æ‚åº¦O(n2)O(n^2)O(n2) å †ä¼˜åŒ– æœ´ç´ å†™æ³•æœ€å¤§çš„ç“¶é¢ˆæ˜¯å¯»æ‰¾å½“å‰è·¯å¾„æœ€çŸ­çš„è“ç‚¹ï¼Œè¿™ä¸ªè¿‡ç¨‹å¯ä»¥ç”¨ä¼˜å…ˆé˜Ÿåˆ—å’Œå †ä¼˜åŒ– int d[1005]; bool b[1005]; priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt; &gt;, greater&lt;pair&lt;int ,int&gt; &gt; &gt; q; void dijkstra(){ d[s] = 0; q.push(make_pair(0,s)); while(!q.empty()) { int x = q.top().second; q.pop(); if(b[x]) continue; b[x] = true; for(int i = head[x]; i ; i = edge[i].next) { int to = edge[i].to; int val = edge[i].val; if(d[to]&gt;d[x]+val) { d[to] = d[x]+val; if(!b[x]) q.push(make_pair(d[to],to)); } } } } ä¼˜åŒ–åæ—¶é—´å¤æ‚åº¦å¯ä»¥é™ä¸º O(nlogn+m) å…¶å®è¿˜æœ‰çº¿æ®µæ ‘ä¼˜åŒ– ç„¶åæˆ‘ä¸ä¼šğŸ˜­ ä¾‹é¢˜ äºŒåˆ†+æœ€çŸ­è·¯ é¢˜ç›®é“¾æ¥ é¢˜é¢ä¸­å¯ä»¥æŠ½è±¡å‡ºæ¨¡å‹ï¼šäºŒåˆ†æšä¸¾ç­”æ¡ˆï¼Œåœ¨ç­”æ¡ˆåˆæ³•çš„æƒ…å†µä¸‹æ‰¾å‡ºç¬¬K+1å¤§çš„è¾¹ **ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ**å¯¹äºä¸€ä¸ªåˆæ³•ç­”æ¡ˆï¼Œå¯ä»¥å°†å»ºè®¾ç”µè¯çº¿çš„å…è´¹åé¢èŠ±è´¹åœ¨å‰kå¤§çš„è¾¹ä¸Šï¼Œå‰©ä¸‹çš„è¾¹ä¸­è¾¹æƒæœ€å¤§çš„ä¸€å®šæ˜¯ç¬¬k+1å¤§çš„è¾¹ã€‚è¦æ±‚çš„æ˜¯ç¬¬k+1å¤§å€¼æœ€å°çš„æƒ…å†µæ‰€ä»¥ä¸éš¾æƒ³åˆ°äºŒåˆ†(æœ€å¤§å€¼æœ€å°)ï¼Œè·‘æœ€çŸ­è·¯å‰æˆ‘ä»¬å¯ä»¥å°†å‰kå¤§çš„è¾¹æ ‡è®°ä¸º0ï¼Œå…¶ä»–çš„è¾¹æ ‡è®°ä¸º1ï¼Œè¿™æ ·æœ€ç»ˆä»1åˆ°nçš„æœ€çŸ­è·¯é•¿åº¦å³ä¸ºéœ€è¦è¿æ¥çš„ç”µè¯æ†æ•°é‡ã€‚ #include&lt;queue&gt; #include&lt;cstdio&gt; #include&lt;utility&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int MAXN = 1e3+5; const int MAXP = 1e4+5; inline int read() { int x = 0; int k = 1; char c = getchar(); while(c &lt; '0' || c &gt; '9') { if(c == '-') k = -1; c = getchar(); } while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int tot; int n, p, k; int dis[MAXN]; bool vis[MAXN]; int head[MAXN]; ll val[MAXP&lt;&lt;1]; int to[MAXP&lt;&lt;1]; int nxt[MAXP&lt;&lt;1]; int flag[MAXP&lt;&lt;1]; void add(int x,int y, ll z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; } bool dijkstra(ll mid) { memset(dis,0x3f,sizeof(dis)); memset(vis,false,sizeof(vis)); priority_queue&lt;pair&lt;int,int&gt; &gt; q; dis[1] = 0; q.push(make_pair(0,1)); while(!q.empty()) { int x = q.top().second; q.pop(); if(vis[x]) continue; vis[x] = true; for(int i = head[x]; i ; i = nxt[i]) { if(dis[to[i]] &gt; dis[x] + flag[i]) { dis[to[i]] = dis[x] + flag[i]; if(!vis[to[i]]) q.push(make_pair(-dis[to[i]],to[i])); } } } if(dis[n] &gt; k) return false; return true; } void inp() { n = read(); p = read(); k = read(); for(int i = 1; i &lt;= p; i++) { int x = read(); int y = read(); ll z = read(); add(x,y,z); add(y,x,z); } } int main() { inp(); int l = 0; int r = 1e6; ll ans = -1; while(l &lt;= r) { ll mid = (l+r)&gt;&gt;1; for(int i = 1; i &lt;= tot; i++) { if(val[i] &lt;= mid) flag[i] = 0; else flag[i] = 1; } if(dijkstra(mid)) { ans = mid; r = mid-1; } else l = mid+1; } printf(&quot;%lld\\n&quot;,ans); return 0; } æœ€çŸ­è·¯å¾„ é¢˜ç›®é“¾æ¥ dijkstraæ±‚æœ€çŸ­è·¯æ—¶ä¿å­˜æ¯ä¸€ä¸ªç»“ç‚¹æœ€åä¸€æ¬¡è¢«æ›´æ–°æœ€çŸ­è·¯çš„ç»“ç‚¹å³å¯ï¼Œæœ€åå€’åºæ‰¾å‡ºæœ€çŸ­è·¯å¾„ï¼Œç„¶åç”¨æ ˆæ”¹ä¸ºé¡ºåºã€‚ #include&lt;cstdio&gt; #include&lt;queue&gt; #include&lt;stack&gt; #include&lt;utility&gt; #include&lt;string.h&gt; #include&lt;algorithm&gt; using namespace std; const int MAX = 1e5+5; typedef long long ll; int n, m, s, t; inline int read() { int x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int tot; int path[MAX]; int head[MAX]; int to[MAX&lt;&lt;1]; int nxt[MAX&lt;&lt;1]; int val[MAX&lt;&lt;1]; int from[MAX&lt;&lt;1]; void add(int x,int y, ll z) { nxt[++tot] = head[x]; head[x] = tot; to[tot] = y; val[tot] = z; from[tot] = x; } void inp() { t = n; s = 1; for(int i = 1; i &lt;= m; i++) { int x = read(); int y = read(); ll z = (ll) read(); add(x,y,z); add(y,x,z); } } ll d[MAX]; bool vis[MAX]; void dijkstra() { priority_queue&lt;pair&lt;int,int&gt; &gt; q; memset(d,0x3f,sizeof(d)); memset(path,0,sizeof(path)); memset(vis,false,sizeof(vis)); d[s] = 0; q.push(make_pair(0,s)); while(!q.empty()) { int x = q.top().second; q.pop(); if(vis[x]) continue; vis[x] = true; for(int i = head[x]; i ; i = nxt[i]) { if(d[to[i]] &gt; d[x] + val[i]) { d[to[i]] = d[x] + val[i]; if(!vis[to[i]]) q.push(make_pair(-d[to[i]],to[i])); path[to[i]] = x; } } } } void oup() { int t = n; stack&lt;int&gt; temp; bool flag = false; while(t) { temp.push(t); t = path[t]; if(t == 1) flag = true; } if(flag) while(!temp.empty()) { printf(&quot;%d &quot;,temp.top()); temp.pop(); } else printf(&quot;-1&quot;); puts(&quot;&quot;); } int main() { while(~scanf(&quot;%d %d&quot;,&amp;n,&amp;m)) { inp(); dijkstra(); oup(); } return 0; } ","link":"https://zzzcd0x.github.io/post/dijkstra/"},{"title":"æ ‘çŠ¶æ•°ç»„","content":" æ ‘çŠ¶æ•°ç»„æ˜¯ä»€ä¹ˆ è®¾æ ‘çŠ¶æ•°ç»„ä¸ºCï¼Œxçš„äºŒè¿›åˆ¶è¡¨è¾¾å½¢å¼æœ«å°¾æœ‰kä¸ª0ï¼Œåˆ™C[x]è¡¨ç¤ºåŒºé—´A[xâˆ’2k+1x-2^k+1xâˆ’2k+1,xxx]çš„å’Œ ä½¿ä½è¿ç®—lowbit(x) = x&amp;-xå¯æ±‚å‡º2k2^k2kçš„å€¼ å¤§è‡´åŸç† å‡è®¾x=6 6ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºä½110 -6æ˜¯æ±‚6çš„è¡¥ç ï¼Œå³åç +1ï¼Œä½010 110&amp;010å³ä¸ºæœ€ä½ä½1çš„ä½ç½® æ¦‚å¿µæƒ³ä¸æ˜ç™½å¯ä»¥çœ‹ä¸€ä¸‹è¿™å¼ å›¾ ä¿¡æ¯å¯å‡çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥å·®åˆ†: å•ç‚¹åŠ ï¼ŒåŒºé—´æŸ¥è¯¢ æŸ¥è¯¢åŒºé—´[l,r]å¯å·®åˆ†ä¸ºå‰rä¸ªæ•°çš„å’Œå‡å»å‰l-1ä¸ªæ•°çš„å’Œ åŒºé—´åŠ ï¼Œå•ç‚¹æŸ¥è¯¢ æŠŠåŒºé—´[l,r]åŠ å·®åˆ†ä¸ºå‰ç¼€råŠ ï¼Œå‰ç¼€l-1å‡ï¼ŒæŸ¥è¯¢å•ç‚¹åªéœ€è¦æŸ¥è¯¢åŒ…å«è¿™ä¸ªç‚¹çš„æ‰€æœ‰å‰ç¼€ä¿®æ”¹ åŒºé—´åŠ ï¼ŒåŒºé—´æŸ¥è¯¢ æŸ¥è¯¢[l,r]åªè¦ç”¨å‰rä¸ªæ•°å‡å»å‰l-1ä¸ªæ•°çš„å’Œå³å¯ åŸºæœ¬å†™æ³• æ„å»º æ„å»ºæ–¹æ³•å› é¢˜è€Œå¼‚ æŸ¥è¯¢xçš„å‰ç¼€å’Œ æ ¹æ®å®šä¹‰å¯å¾—ï¼ŒC[x]å­˜çš„æ˜¯A[x-2^k+1,x]çš„å’Œï¼Œå› æ­¤åªéœ€è¦x-lowbit(x)å¹¶ä¸”åŠ ä¸ŠC[x]çš„å€¼å°±å¯ä»¥å¾—åˆ°xçš„å‰ç¼€å’Œï¼Œç›´åˆ°å‡åˆ°0 int aks(int x){ int ans = 0; for(int i = x; i ; i-=lowbit(i)) ans+=c[i]; } ä¿®æ”¹ å†æ ¹æ®å®šä¹‰ï¼Œæ›´æ”¹A[x]çš„å€¼ï¼Œéœ€è¦æ”¹å˜Cä¸­x+lowbit(x)ç›´åˆ°å¤§äºnçš„å€¼ï¼Œè¿­ä»£è§£å†³å³å¯ ç¬¬xä½çš„æ•°åŠ kçš„å†™æ³• void modify(int x,int k){ for(int i = x; i &lt;= n; i+=lowbit(i)) c[i]+=k; } ","link":"https://zzzcd0x.github.io/post/shu-zhuang-shu-zu/"},{"title":"çº¿æ®µæ ‘","content":"ç»„æˆ 1å·ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹ï¼Œå­˜å‚¨åŸæ•°ç»„åŒºé—´1åˆ°6çš„æ•°çš„å’Œ å·¦å„¿å­ä¸‹æ ‡ä¸º2ï¼Œæ±‚æ³•ä¸º1&gt;&gt;1,å­˜å‚¨[1,3]çš„å’Œ å³å„¿å­ä¸‹æ ‡ä¸º3ï¼Œæ±‚æ³•ä¸º1&gt;&gt;1|1,å­˜å‚¨[4,6]çš„å’Œ è¿™é‡Œ3å’Œ4æ—¶åŒºé—´ä¸­ç‚¹å’Œä¸­ç‚¹+1 ç”¨äºŒè¿›åˆ¶è¿ç®—æ¯”è¾ƒå¿«ï¼Œå¤„ç†å¤§é‡æ•°æ®æ—¶å¸¸æ•°å¯ä»¥ä½ä¸€ç‚¹ å…¶å®çº¿æ®µæ ‘èƒ½ç»´æŠ¤çš„ä¸œè¥¿è¿œä¸æ­¢å’Œï¼Œè¿˜å¯ä»¥ç»´æŠ¤åŒºé—´æœ€å¤§å€¼ã€æœ€å°å€¼ã€æœ€å¤§å­æ®µå’Œç­‰ç­‰ æ€ä¹ˆç»´æŠ¤å‘¢ å…ˆä»å»ºæ ‘å¼€å§‹ ä»æ ¹èŠ‚ç‚¹å¼€å§‹é€’å½’å»ºæ ‘ å¼€å››å€ç©ºé—´ 1.æ•°ç»„å†™æ³• int a[1005]; //åŸæ•°ç»„ int t[4005]; //çº¿æ®µæ ‘ void build(int now,int l,int r){ if(l == r) { t[now] = a[l]; return; } int mid = (l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); pushup(now); //å›æº¯çš„æ—¶å€™æ›´æ–°çˆ¶äº²èŠ‚ç‚¹ } 2.ç»“æ„ä½“å†™æ³• struct Node{ int l,r; int sum; }node[4005]; void build(int now,int l,int r){ node[now].l = l; node[now].r = r; if(l == r) { node[now].sum = a[l]; return; } int mid = (l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); pushup(now); } å¥½åƒç»“æ„ä½“å†™æ³•æ›´å®¹æ˜“ç»´æŠ¤ åŒºé—´æŸ¥è¯¢ å½“å‰æŸ¥æ‰¾åˆ°çš„åŒºé—´è¢«åŒ…å«åœ¨éœ€è¦æŸ¥æ‰¾çš„åŒºé—´å†…åˆ™ç›´æ¥è¿”å› å¦åˆ™é€šè¿‡ä¸­ç‚¹åˆ¤æ–­è¦æŸ¥æ‰¾åˆ°åŒºé—´å’Œå·¦å³å­æ ‘å“ªä¸ªæœ‰äº¤é›† å¦‚æœéƒ½æœ‰åˆ™å°†ä¸¤è¾¹çš„æŸ¥æ‰¾ç»“æœè¿›è¡Œç›¸åº”çš„å¤„ç†åè¿”å› æ€æƒ³ç±»ä¼¼äºŒåˆ†æŸ¥æ‰¾ int find(int now,int L,int R){ int l = node[now].l; int r = node[now].r; if(L &lt;= l &amp;&amp; R &gt;= r) return node[now].sum; int mid = (l+r)&gt;&gt;1; if(mid &gt;= R) return find(now&lt;&lt;1,L,R); else if(mid &lt; l) return find(now&lt;&lt;1|1,L,R); else { int tot = 0; tot += find(now&lt;&lt;1,L,R); tot += find(now&lt;&lt;1|1,L,R); return tot; } } åŒºé—´ä¿®æ”¹ å¤§ä½“æ­¥éª¤å’ŒåŒºé—´æŸ¥è¯¢ç±»ä¼¼ æ ‡è®°ä¸‹æ”¾: å¦‚æœæ¯æ¬¡ä¿®æ”¹éƒ½å»ç›¸åº”çš„ä¿®æ”¹æ¶‰åŠåˆ°çš„æ‰€æœ‰çš„ç»“ç‚¹çš„è¯ä¼šäº§ç”Ÿè¾ƒå¤§çš„å¤æ‚åº¦ï¼Œå› æ­¤è€ƒè™‘ä½¿ç”¨æ ‡è®°ä¸‹æ”¾çš„æ–¹æ³•ï¼Œå³å½“è¯¥ç»“ç‚¹è¢«è®¿é—®åˆ°çš„æ—¶å€™å†å°†æ ‡è®°ä¸‹æ”¾ï¼Œä½¿å­æ ‘å¾—åˆ°æ­£ç¡®çš„ä¿¡æ¯ã€‚æ‰€ä»¥åŒºé—´ä¿®æ”¹åªæ›´æ–°åˆ°éœ€è¦ä¿®æ”¹çš„åŒºé—´çš„çœŸå­é›†å³å¯ï¼Œä½†åœ¨æ­¤ä¹‹å‰æ¯ä¸€ä¸ªè®¿é—®åˆ°çš„ç»“ç‚¹éƒ½è¦è¿›è¡Œæ ‡è®°ä¸‹æ”¾ï¼Œä¸ç„¶éœ€è¦æ›´æ–°çš„åŒºé—´å¾—ä¸åˆ°æ­£ç¡®çš„æ›´æ–°ä¿¡æ¯ int tag[40005]; void pushdown(int now){ if(tag[now]) { tag[now&lt;&lt;1] += tag[now]; tag[now&lt;&lt;1|1] += tag[now]; node[now&lt;&lt;1].sum += tag[now]*(node[now&lt;&lt;1].r-node[now&lt;&lt;1]+1); node[now&lt;&lt;1|1].sum += tag[now]*(node[now&lt;&lt;1|1].r-node[now&lt;&lt;1|1]+1); tag[now] = 0; } } void modify(int now,int L,int R,int k){ int l = node[now].l; int r = node[now].r; if(L &lt;= l &amp;&amp; R &gt;= r) { tag[now] += k; node[now].sum += k*(r-l+1); } pushdown(now); int mid = (l+r)&gt;&gt;1; if(mid &gt;= L) modify(now&lt;&lt;1,L,R,k); if(R &gt; mid) modify(now&lt;&lt;1|1,L,R,k); pushup(now); } pushupçš„ä½œç”¨æ˜¯å½“æŸä¸€ä¸ªç»“ç‚¹çš„å­æ ‘çš„å€¼è¢«ä¿®æ”¹äº†åˆ™å»ç”¨ä¿®æ”¹åçš„å­æ ‘çš„ä¿¡æ¯å»æ›´æ–°å½“å‰ç»“ç‚¹çš„ä¿¡æ¯ void pushup(int now){ node[now].sum = node[now&lt;&lt;1].sum + ndoe[now&lt;&lt;1|1].sum; } å•ç‚¹ä¿®æ”¹ void modifyP(int now,int to,int k){ int l = node[now].l; int r = node[now].r; if(l == r) { a[now] += k; t[now] += k; return; } int mid = (l+r)&gt;&gt;1; if(mid &gt;= to) modifyP(now&lt;&lt;1,to,k); else modifyP(now&lt;&lt;1|1,to,k); pushup(now); } ç»´æŠ¤æœ€å¤§å­æ®µå’Œ ä»€ä¹ˆæ˜¯æœ€å¤§å­æ®µå’Œï¼Ÿ å…¶å®å°±æ˜¯å½“å‰çº¿æ®µæ ‘åŒºé—´å†…ï¼Œä¸€ä¸ªä»»æ„çš„è¿ç»­çš„åºåˆ—çš„å’Œçš„æœ€å¤§å€¼ å…¶ä»–ä¼šç”¨åˆ°çš„æ¦‚å¿µ: æœ€å¤§å·¦å­æ®µå’Œ:ä»åŒºé—´å·¦ç«¯ç‚¹å¼€å§‹çš„æœ€å¤§å­æ®µå’Œ æœ€å¤§å³å­æ®µå’Œ:ä»åŒºé—´å³ç«¯ç‚¹å¼€å§‹çš„æœ€å¤§å­æ®µå’Œ pushup æœ€å¤§å·¦å­æ®µå’Œå¯èƒ½æ˜¯å·¦å­æ ‘çš„æœ€å¤§å·¦å­æ®µå’Œä¹Ÿå¯èƒ½æ˜¯å·¦å­æ ‘çš„åŒºé—´æ€»å’ŒåŠ å³å­æ ‘çš„æœ€å¤§å·¦å­æ®µå’Œï¼Œæœ€å¤§å³å­æ®µå’ŒåŒç† æœ€å¤§å­æ®µå’Œå¯èƒ½æ˜¯å·¦å­æ ‘çš„æœ€å¤§å­æ®µå’Œæˆ–å³å­æ ‘çš„æœ€å¤§å­æ®µå’Œæˆ–å·¦å­æ ‘çš„æœ€å¤§å³å­æ®µå’Œ+å³å­æ ‘çš„æœ€å¤§å·¦å­æ®µå’Œ void pushup(int now){ node[now].sum = node[now&lt;&lt;1].sum + node[now&lt;&lt;1|1].sum; ndoe[now].Max = max(max(node[now&lt;&lt;1].Max,node[now&lt;&lt;1|1].Max),node[now&lt;&lt;1].rm+node[now&lt;&lt;1|1].lm); node[now].lm = max(node[now&lt;&lt;1].lm,node[now&lt;&lt;1].sum+node[now&lt;&lt;1|1].lm); node[now].rm = max(node[now&lt;&lt;1|1].rm,node[now&lt;&lt;1].rm+node[now&lt;&lt;1|1].sum); } å»ºæ ‘ void build(int now,int l,int r){ node[now].l = l; ndoe[now].r = r; if(l == r) { node[now].sum = a[l]; node[now].lm = a[l]; node[now].rm = a[l]; node[now].Max = a[l]; return; } int mid = (l+r)&gt;&gt;1; builde(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); pushup(now); } åŒºé—´ä¿®æ”¹ ç›´æ¥æ›´æ”¹çº¿æ®µæ ‘ä¸ŠæŸä¸ªç‚¹çš„å€¼ void modify(int now,int to,int k){ int l = node[now].l; int r = node[now].r; if(l == r) { node[now].sum = k; node[now].Max = k; node[now].lm = k; node[now].rm = k; return; } int mid = (l+r)&gt;&gt;1; if(to &lt;= mid) modify(now&lt;&lt;1,to,k); else modify(now&lt;&lt;1|1,to,k); pushup(now); } åŒºé—´æŸ¥æ‰¾ Node ask(int now,int L,int R){ int l = node[now].l; int r = ndoe[now].r; if(L &lt;= l &amp;&amp; R &gt;= r) return node[now]; int mid = (l+r)&gt;&gt;1; if(mid &gt;= R) return ask(now&lt;&lt;1,L,R); else if(mid&lt;L) return ask(now&lt;&lt;1|1,L,R); else{ Node ans; Node left = ask(now&lt;&lt;1,L,R); Node right = ask(now&lt;&lt;1|1,L,R); ans.sum = left.sum + right.sum; ans.lm = max(left.lm,left.sum+right.lm); ans.rm = max(right.rm,right.sum+left.rm); ans.Max = max(left.rm+right.lm,max(left.Max,right.Max)); return ans; } } ä¾‹é¢˜ æœ€å¤§å­æ®µå’Œ é¢˜ç›®é“¾æ¥ #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,m; int a[500005]; struct Node{ int l,r; int sum; int Max; int lm,rm; }node[2000005]; void pushup(int now){ node[now].sum = node[now&lt;&lt;1].sum+node[now&lt;&lt;1|1].sum; node[now].lm = max(node[now&lt;&lt;1].lm,node[now&lt;&lt;1].sum+node[now&lt;&lt;1|1].lm); node[now].rm = max(node[now&lt;&lt;1|1].rm,node[now&lt;&lt;1|1].sum+node[now&lt;&lt;1].rm); node[now].Max = max(max(node[now&lt;&lt;1].Max,node[now&lt;&lt;1|1].Max),node[now&lt;&lt;1].rm+node[now&lt;&lt;1|1].lm); } void build(int now,int l,int r){ node[now].l = l; node[now].r = r; if(l == r) { node[now].sum = a[l]; node[now].lm = a[l]; node[now].rm = a[l]; node[now].Max = a[l]; return; } int mid = (l+r)&gt;&gt;1; build(now&lt;&lt;1,l,mid); build(now&lt;&lt;1|1,mid+1,r); pushup(now); } void modify(int now,int to,int k){ int l = node[now].l; int r = node[now].r; if(l == r) { // a[now] = k; node[now].sum = k; node[now].Max = k; node[now].lm = k; node[now].rm = k; return; } int mid = (l+r)&gt;&gt;1; if(to &lt;= mid) modify(now&lt;&lt;1,to,k); else modify(now&lt;&lt;1|1,to,k); pushup(now); } Node ask(int now,int L,int R){ int l = node[now].l; int r = node[now].r; if(L &lt;= l &amp;&amp; R &gt;= r) return node[now]; int mid = (l+r)&gt;&gt;1; if(mid &gt;= R) return ask(now&lt;&lt;1,L,R); else if(mid &lt; L) return ask(now&lt;&lt;1|1,L,R); else { Node ans; Node left = ask(now&lt;&lt;1,L,R); Node right = ask(now&lt;&lt;1|1,L,R); ans.sum = left.sum + right.sum; ans.lm = max(left.lm,left.sum+right.lm); ans.rm = max(right.rm,right.sum+left.rm); ans.Max = max(left.rm+right.lm,max(left.Max,right.Max)); return ans; } } int main(){ int k,x,y; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;,&amp;a[i]); build(1,1,n); for(int i = 1; i &lt;= m; i++) { scanf(&quot;%d %d %d&quot;,&amp;k,&amp;x,&amp;y); if(k == 1) { if(x &gt; y) { int t = x; x = y; y = t; } Node ans = ask(1,x,y); printf(&quot;%d\\n&quot;,ans.Max); } if(k == 2) modify(1,x,y); } return 0; } çº¿æ®µæ ‘+çŠ¶å‹ é¢˜ç›®é“¾æ¥ æœ¬é¢˜æ˜¯ç»™ä¸€ä¸ªæœ¨æ¿çš„ä¸åŒåŒºé—´æŸ“è‰²ï¼Œä¸€å…±æœ‰30ç§é¢œè‰²ï¼Œå¯ä»¥è€ƒè™‘ç”¨ä¸€ä¸ªäºŒè¿›åˆ¶æ•°å­—æ¥å‚¨å­˜è¯¥åŒºé—´å†…çš„æ•°è¢«æŸ“äº†å“ªä¸€ç§é¢œè‰²ï¼Œçº¿æ®µæ ‘ä¸­ç¬¬iä¸ªç»“ç‚¹å­˜å‚¨çš„æ•°å­—çš„äºŒè¿›åˆ¶ç¬¬jä½ä¸º1ï¼Œåˆ™è¯¥ç»“ç‚¹è¢«æŸ“æˆäº†é¢œè‰²jï¼Œè‹¥ä¸º0åˆ™æ²¡æœ‰æŸ“æˆé¢œè‰²jï¼ŒåŒºé—´é¢œè‰²ä¸ªæ•°ç»Ÿè®¡ä½¿ç”¨æŒ‰ä½ä¸è¿ç®—ï¼Œå°†æœ€ç»ˆç»“æœè¿›è¡ŒäºŒè¿›åˆ¶æ‹†åˆ†ç»Ÿè®¡ä¸º1çš„ä¸ªæ•°å³å¯ã€‚ #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; const int MAXN = 1e5+5; int n,t,o; int le[MAXN&lt;&lt;2]; int ri[MAXN&lt;&lt;2]; int tag[MAXN&lt;&lt;2]; int color[MAXN&lt;&lt;2]; inline int read() { int x = 0; char c = getchar(); while(c &lt; '0' || c &gt; '9') c = getchar(); while(c &gt;= '0' &amp;&amp; c &lt;= '9') { x = x*10 + c-'0'; c = getchar(); } return x; } int ls(int p) {return p&lt;&lt;1;} int rs(int p) {return p&lt;&lt;1|1;} void pushup(int p) {color[p] = color[ls(p)] | color[rs(p)];} void upd(int p,int v) { color[p] = v; tag[p] = v; } void pushdown(int p) { if(tag[p]) { upd(ls(p),tag[p]); upd(rs(p),tag[p]); tag[p] = 0; } } void build(int now,int l,int r) { le[now] = l; ri[now] = r; color[now] = 0; tag[now] = 0; if(l == r) { color[now] = 1; return; } int mid = (l+r)&gt;&gt;1; build(ls(now),l,mid); build(rs(now),mid+1,r); pushup(now); } void modify(int now,int l,int r,int v) { int L = le[now]; int R = ri[now]; if(r &lt; L || l &gt; R) return; if(l &lt;= L &amp;&amp; r &gt;= R) { tag[now] = 1&lt;&lt;(v-1); color[now] = 1&lt;&lt;(v-1); return; } pushdown(now); int mid = (L+R)&gt;&gt;1; if(l &lt;= mid) modify(ls(now),l,r,v); if(r &gt; mid) modify(rs(now),l,r,v); pushup(now); } int query(int now,int l,int r) { int L = le[now]; int R = ri[now]; if(r &lt; L || l &gt; R) return 0; if(l &lt;= L &amp;&amp; r &gt;= R) { return color[now]; } int ans = 0; int mid = (L+R)&gt;&gt;1; pushdown(now); if(l &lt;= mid) ans |= query(ls(now),l,r); if(r &gt; mid) ans |= query(rs(now),l,r); return ans; } int main() { while(~scanf(&quot;%d %d %d&quot;,&amp;n,&amp;t,&amp;o)) { int x, y, z; char c[2]; build(1,1,n); while(o--) { scanf(&quot;%s&quot;,c); if(c[0] == 'C') { scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); if(x &gt; y) swap(x,y); modify(1,x,y,z); } else if(c[0] == 'P') { scanf(&quot;%d %d&quot;,&amp;x,&amp;y); if(x &gt; y) swap(x,y); int cnt = 0; int tot = query(1,x,y); while(tot) { if(tot&amp;1) cnt++; tot &gt;&gt;= 1; } printf(&quot;%d\\n&quot;,cnt); } } } return 0; } ","link":"https://zzzcd0x.github.io/post/SegmentTree/"}]}