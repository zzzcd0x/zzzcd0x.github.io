{"posts":[{"fileName":"wang-luo-liu-chu-bu","abstract":"","description":"相关定义 网络流图 是一个满足以下条件的 DAG 只有一个入度为0的点，称为源点。 只有一个出度为0的点，称为汇点。 每条边都有一个非负权值，称为这条边的容量。 容许流 网络流图中，对于每条边e=(i,j)e=(i,j)e=(i,j)，...","title":"网络流初步","tags":[{"index":-1,"name":"图论","slug":"UlLnG_SI0","used":true,"link":"https://zzzcd0x.github.io/tag/UlLnG_SI0/"}],"feature":"","link":"https://zzzcd0x.github.io/post/wang-luo-liu-chu-bu/","stats":{"text":"22 min read","time":1312000,"words":4285,"minutes":22},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E7%9B%B8%E5%85%B3%E5%AE%9A%E4%B9%89\">相关定义</a></li>\n<li><a href=\"#%E6%9C%80%E5%A4%A7%E6%B5%81\">最大流</a>\n<ul>\n<li><a href=\"#ek%E7%AE%97%E6%B3%95\">EK算法</a></li>\n<li><a href=\"#%E6%A8%A1%E6%9D%BF\">模板</a></li>\n<li><a href=\"#dinic%E7%AE%97%E6%B3%95\">Dinic算法</a>\n<ul>\n<li><a href=\"#%E6%A8%A1%E6%9D%BF-2\">模板</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E5%AE%9A%E7%90%86\">最大流最小割定理</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%B4%B9%E7%94%A8%E6%B5%81\">费用流</a>\n<ul>\n<li><a href=\"#ek%E7%AE%97%E6%B3%95-2\">EK算法</a>\n<ul>\n<li><a href=\"#%E6%A8%A1%E6%9D%BF-3\">模板</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BE%8B%E9%A2%98\">例题</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-08-12 20:59:55","dateFormat":"2020-08-12"},{"fileName":"zui-jin-gong-gong-zu-xian","abstract":"","description":"树上倍增法 怎么计算的？ 假设要计算树上x和y结点的最近公共祖先，d[x]表示结点x的深度，F[x,k]表示结点x向上跳2 设d[x] &gt;= d[y]否则交换x和y 将x结点尝试向上走2^{log(n)}...2^{log(0)}步，...","title":"最近公共祖先","tags":[{"index":-1,"name":"图论","slug":"UlLnG_SI0","used":true,"link":"https://zzzcd0x.github.io/tag/UlLnG_SI0/"}],"feature":"","link":"https://zzzcd0x.github.io/post/zui-jin-gong-gong-zu-xian/","stats":{"text":"4 min read","time":188000,"words":587,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E%E6%B3%95\">树上倍增法</a>\n<ul>\n<li><a href=\"#%E6%80%8E%E4%B9%88%E8%AE%A1%E7%AE%97%E7%9A%84\">怎么计算的？</a></li>\n<li><a href=\"#%E4%BE%8B%E9%A2%98\">例题</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-07-25 15:45:50","dateFormat":"2020-07-25"},{"fileName":"spfa","abstract":"","description":"虽然spfa算法赛场上会各种被卡，但还是蛮不错的。 大致思想 首先将源点加入队列 然后更新源点能够到达的点的最短路 如果被更新的点不在队列中，则加入队列 重复上述2~3步直到队列为空 其实思想与dijkstra比较相似，不同的是dijk...","title":"SPFA","tags":[{"index":-1,"name":"图论","slug":"UlLnG_SI0","used":true,"link":"https://zzzcd0x.github.io/tag/UlLnG_SI0/"}],"feature":"","link":"https://zzzcd0x.github.io/post/spfa/","stats":{"text":"4 min read","time":196000,"words":623,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%A4%A7%E8%87%B4%E6%80%9D%E6%83%B3\">大致思想</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0\">实现</a>\n<ul>\n<li><a href=\"#%E4%BE%8B%E9%A2%98\">例题</a>\n<ul>\n<li><a href=\"#%E5%88%A4%E6%96%AD%E8%B4%9F%E7%8E%AF\">判断负环</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-07-22 20:06:46","dateFormat":"2020-07-22"},{"fileName":"bing-cha-ji-dsu","abstract":"","description":" 引入 假设现在有n个仅知道自己的父亲是谁的人，现在要存储他们每个人之间的关系，并查询其中几个人是否属于同一家族 思路 首先可以想到每一个家族可以组成一个树，但如果每一个结点都只储存自己的父亲是谁，那这几棵树就会 进化 变成一个森林 ...","title":"并查集DSU","tags":[{"index":-1,"name":"数据结构","slug":"nPXiRYhFe","used":true,"link":"https://zzzcd0x.github.io/tag/nPXiRYhFe/"}],"feature":"","link":"https://zzzcd0x.github.io/post/bing-cha-ji-dsu/","stats":{"text":"3 min read","time":136000,"words":615,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%BC%95%E5%85%A5\">引入</a>\n<ul>\n<li><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></li>\n<li><a href=\"#%E6%9C%B4%E7%B4%A0%E5%86%99%E6%B3%95\">朴素写法</a></li>\n<li><a href=\"#%E8%B7%AF%E5%BE%84%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96\">路径压缩优化</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%B9%B6%E6%9F%A5%E9%9B%86\">并查集</a></li>\n</ul>\n","date":"2020-07-17 10:29:14","dateFormat":"2020-07-17"},{"fileName":"gcd-lcm","abstract":"","description":"最大公因数(gcd) 性质： gcd(1,n) = 1 设d = gcd(a,b) 则 gcd(a/d,b/d) = 1 gcd(a,b) = gcd(a+-b,b) = gcd(a,b+-a) 辗转相除法求解： 由gcd(a,b) =...","title":"gcd lcm","tags":[{"index":-1,"name":"数论","slug":"vr6Cb8Hkz","used":true,"link":"https://zzzcd0x.github.io/tag/vr6Cb8Hkz/"}],"feature":"","link":"https://zzzcd0x.github.io/post/gcd-lcm/","stats":{"text":"1 min read","time":44000,"words":145,"minutes":1},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0gcd\">最大公因数(gcd)</a>\n<ul>\n<li><a href=\"#%E6%80%A7%E8%B4%A8\">性质：</a></li>\n<li><a href=\"#%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%E6%B1%82%E8%A7%A3\">辗转相除法求解：</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0lcm\">最小公倍数(lcm)</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-07-14 16:33:34","dateFormat":"2020-07-14"},{"fileName":"su-shu-shai","abstract":"","description":"埃氏筛 主要过程 从2到n枚举，如果该数字没有标记(是素数) 枚举范围内的该数字的倍数，将枚举到的数字标记为素数 这样枚举结束后所有的合数就被打了标记，没打标记的就是素数 实现 以找100以内的素数为例 int n = 10...","title":"素数筛","tags":[{"index":-1,"name":"数论","slug":"vr6Cb8Hkz","used":true,"link":"https://zzzcd0x.github.io/tag/vr6Cb8Hkz/"}],"feature":"","link":"https://zzzcd0x.github.io/post/su-shu-shai/","stats":{"text":"2 min read","time":98000,"words":398,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%9F%83%E6%B0%8F%E7%AD%9B\">埃氏筛</a>\n<ul>\n<li><a href=\"#%E4%B8%BB%E8%A6%81%E8%BF%87%E7%A8%8B\">主要过程</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0\">实现</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%AC%A7%E6%8B%89%E7%AD%9B\">欧拉筛</a>\n<ul>\n<li><a href=\"#%E8%BF%87%E7%A8%8B\">过程</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0-2\">实现</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-07-14 16:32:57","dateFormat":"2020-07-14"},{"fileName":"lian-shi-qian-xiang-xing","abstract":"","description":"原理 链式前向星与邻接表类似，用一个数组存储了一个点可以到达的所有的点，区别是链式前向星使用链表将从每一个点出发的每一条边用链表的形式链在了一起，对边的存储方式是存储指向的顶点，边权，以及一下一条边的编号 怎么写呢 结构体写法 str...","title":"链式前向星","tags":[{"index":-1,"name":"图论","slug":"UlLnG_SI0","used":true,"link":"https://zzzcd0x.github.io/tag/UlLnG_SI0/"}],"feature":"","link":"https://zzzcd0x.github.io/post/lian-shi-qian-xiang-xing/","stats":{"text":"2 min read","time":82000,"words":311,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E5%8E%9F%E7%90%86\">原理</a></li>\n<li><a href=\"#%E6%80%8E%E4%B9%88%E5%86%99%E5%91%A2\">怎么写呢</a></li>\n<li><a href=\"#%E9%81%8D%E5%8E%86\">遍历</a></li>\n</ul>\n","date":"2020-07-14 16:32:26","dateFormat":"2020-07-14"},{"fileName":"tuo-bu-pai-xu","abstract":"","description":"什么是DAG 通俗来说DAG就是有向无环图的简称，通过名字就可以看出，DAG的基本特点是边为有向边，且图内无环 这个图虽然看似有环，但因为边都是有向边，所以并没有构成环。 观察一下上面那个图，不难发现以每一个结点为起点都可以找到对应的一条...","title":"拓扑排序","tags":[{"index":-1,"name":"图论","slug":"UlLnG_SI0","used":true,"link":"https://zzzcd0x.github.io/tag/UlLnG_SI0/"}],"feature":"","link":"https://zzzcd0x.github.io/post/tuo-bu-pai-xu/","stats":{"text":"2 min read","time":105000,"words":453,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AFdag\">什么是DAG</a></li>\n<li><a href=\"#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F\">拓扑排序</a>\n<ul>\n<li><a href=\"#%E8%BF%87%E7%A8%8B\">过程</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-07-14 16:31:44","dateFormat":"2020-07-14"},{"fileName":"kruskal","abstract":"","description":"kruskal 是什么呢 是一种求一个图的最小生成树的算法，核心思想是贪心，其实就是个贪心，与prime相比更加适合求边比较稀疏的图的最小生成树 时间复杂度是O(mlogm) 运行过程 kruskal里面的边的作用可以理解为只是为了表达两个...","title":"kruskal","tags":[{"index":-1,"name":"图论","slug":"UlLnG_SI0","used":true,"link":"https://zzzcd0x.github.io/tag/UlLnG_SI0/"}],"feature":"","link":"https://zzzcd0x.github.io/post/kruskal/","stats":{"text":"2 min read","time":72000,"words":291,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#kruskal\">kruskal</a>\n<ul>\n<li><a href=\"#%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2\">是什么呢</a></li>\n<li><a href=\"#%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B\">运行过程</a></li>\n<li><a href=\"#%E6%A8%A1%E6%9D%BF\">模板</a></li>\n<li><a href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\">注意事项</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-07-14 16:31:25","dateFormat":"2020-07-14"},{"fileName":"floyd","abstract":"","description":"干什么的呢 大多用于求多源图中两点间的最短路，也可以用于传递闭包 写法 for(int k = 1; k &lt;= n; k++) for(int i = 1; i &lt;= n; i++) fo...","title":"Floyd","tags":[{"index":-1,"name":"图论","slug":"UlLnG_SI0","used":true,"link":"https://zzzcd0x.github.io/tag/UlLnG_SI0/"}],"feature":"","link":"https://zzzcd0x.github.io/post/floyd/","stats":{"text":"3 min read","time":141000,"words":489,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%E5%91%A2\">干什么的呢</a></li>\n<li><a href=\"#%E5%86%99%E6%B3%95\">写法</a></li>\n<li><a href=\"#%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E\">正确性证明</a></li>\n<li><a href=\"#%E7%BB%86%E8%8A%82\">细节</a></li>\n<li><a href=\"#%E4%BE%8B%E9%A2%98\">例题</a>\n<ul>\n<li><a href=\"#%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85\">传递闭包</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-07-14 16:30:51","dateFormat":"2020-07-14"},{"fileName":"dijkstra","abstract":"","description":"Dijkstra算法是一种用于解决无负权边的有向图的单源最短路问题的算法 大致思想 初始时将图的源点的最短路设为0 其他点最短路长度设为INF 将图中的点分为两类 一类是已经更新过最短路的点称为红点，另一类是未找到确定的最短路的点，称为蓝点...","title":"Dijkstra","tags":[{"index":-1,"name":"图论","slug":"UlLnG_SI0","used":true,"link":"https://zzzcd0x.github.io/tag/UlLnG_SI0/"}],"feature":"","link":"https://zzzcd0x.github.io/post/dijkstra/","stats":{"text":"8 min read","time":455000,"words":1503,"minutes":8},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E5%A4%A7%E8%87%B4%E6%80%9D%E6%83%B3\">大致思想</a></li>\n<li><a href=\"#%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E\">正确性证明</a></li>\n<li><a href=\"#%E6%9C%B4%E7%B4%A0%E5%86%99%E6%B3%95\">朴素写法</a></li>\n<li><a href=\"#%E5%A0%86%E4%BC%98%E5%8C%96\">堆优化</a></li>\n<li><a href=\"#%E4%BE%8B%E9%A2%98\">例题</a>\n<ul>\n<li><a href=\"#%E4%BA%8C%E5%88%86%E6%9C%80%E7%9F%AD%E8%B7%AF\">二分+最短路</a></li>\n<li><a href=\"#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84\">最短路径</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2020-07-14 16:30:12","dateFormat":"2020-07-14"},{"fileName":"shu-zhuang-shu-zu","abstract":"","description":" 树状数组是什么 设树状数组为C，x的二进制表达形式末尾有k个0，则C[x]表示区间A[x−2k+1x-2^k+1x−2k+1,xxx]的和 使位运算lowbit(x) = x&amp;-x可求出2k2^k2k的值 大致原理 假设x=...","title":"树状数组","tags":[{"index":-1,"name":"数据结构","slug":"nPXiRYhFe","used":true,"link":"https://zzzcd0x.github.io/tag/nPXiRYhFe/"}],"feature":"","link":"https://zzzcd0x.github.io/post/shu-zhuang-shu-zu/","stats":{"text":"2 min read","time":94000,"words":382,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%98%AF%E4%BB%80%E4%B9%88\">树状数组是什么</a></li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E5%86%99%E6%B3%95\">基本写法</a></li>\n</ul>\n","date":"2020-07-14 16:28:50","dateFormat":"2020-07-14"},{"fileName":"SegmentTree","abstract":"","description":"组成 1号结点为根结点，存储原数组区间1到6的数的和 左儿子下标为2，求法为1&gt;&gt;1,存储[1,3]的和 右儿子下标为3，求法为1&gt;&gt;1|1,存储[4,6]的和 这里3和4时区间中点和中点+1 用二进制运算比较快，...","title":"线段树","tags":[{"index":-1,"name":"数据结构","slug":"nPXiRYhFe","used":true,"link":"https://zzzcd0x.github.io/tag/nPXiRYhFe/"}],"feature":"","link":"https://zzzcd0x.github.io/post/SegmentTree/","stats":{"text":"14 min read","time":813000,"words":2552,"minutes":14},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#%E7%BB%84%E6%88%90\">组成</a></li>\n<li><a href=\"#%E6%80%8E%E4%B9%88%E7%BB%B4%E6%8A%A4%E5%91%A2\">怎么维护呢</a>\n<ul>\n<li><a href=\"#%E5%85%88%E4%BB%8E%E5%BB%BA%E6%A0%91%E5%BC%80%E5%A7%8B\">先从建树开始</a></li>\n<li><a href=\"#%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2\">区间查询</a></li>\n<li><a href=\"#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9\">区间修改</a></li>\n<li><a href=\"#%E5%8D%95%E7%82%B9%E4%BF%AE%E6%94%B9\">单点修改</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%BB%B4%E6%8A%A4%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C\">维护最大子段和</a>\n<ul>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C\">什么是最大子段和？</a>\n<ul>\n<li><a href=\"#pushup\">pushup</a></li>\n<li><a href=\"#%E5%BB%BA%E6%A0%91\">建树</a></li>\n<li><a href=\"#%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9-2\">区间修改</a></li>\n<li><a href=\"#%E5%8C%BA%E9%97%B4%E6%9F%A5%E6%89%BE\">区间查找</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E4%BE%8B%E9%A2%98\">例题</a>\n<ul>\n<li><a href=\"#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C\">最大子段和</a></li>\n<li><a href=\"#%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%8A%B6%E5%8E%8B\">线段树+状压</a></li>\n</ul>\n</li>\n</ul>\n","date":"2020-07-14 15:07:16","dateFormat":"2020-07-14"}],"tags":[{"index":-1,"name":"图论","slug":"UlLnG_SI0","used":true,"link":"https://zzzcd0x.github.io/tag/UlLnG_SI0/","count":8},{"index":-1,"name":"数据结构","slug":"nPXiRYhFe","used":true,"link":"https://zzzcd0x.github.io/tag/nPXiRYhFe/","count":3},{"index":-1,"name":"数论","slug":"vr6Cb8Hkz","used":true,"link":"https://zzzcd0x.github.io/tag/vr6Cb8Hkz/","count":2}],"menus":[{"link":"/","name":"首页","openType":"Internal"},{"link":"/archives","name":"All","openType":"Internal"},{"link":"/tags","name":"分类","openType":"Internal"}],"themeConfig":{"themeName":"Chic-master","postPageSize":10,"archivesPageSize":50,"siteName":"zzzcd0x 's Blog","siteDescription":"越学越倒退选手","footerInfo":"Powered by <a href=\"https://github.com/getgridea/gridea\" target=\"_blank\">Gridea</a>","showFeatureImage":true,"domain":"https://zzzcd0x.github.io","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":true,"feedCount":10,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"customConfig":{},"utils":{"now":1598250121960}}